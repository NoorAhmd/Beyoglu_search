{"ast":null,"code":"/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\n\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {module:ol/coordinate~Coordinate} Coordinate.\n */\n\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } // FIXME use O(1) search\n\n\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n\n  var lo = offset / stride;\n  var hi = end / stride;\n\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  var m0 = flatCoordinates[lo * stride - 1];\n\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n\n  coordinate.push(m);\n  return coordinate;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {module:ol/coordinate~Coordinate} Coordinate.\n */\n\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n\n    if (offset == end) {\n      continue;\n    }\n\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n\n    offset = end;\n  }\n\n  return null;\n} //# sourceMappingURL=interpolate.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/geom/flat/interpolate.js"],"names":["binarySearch","lerp","interpolatePoint","flatCoordinates","offset","end","stride","fraction","opt_dest","pointX","NaN","pointY","n","x1","y1","length","cumulativeLengths","i","x2","y2","Math","sqrt","push","target","index","t","o","lineStringCoordinateAtM","m","extrapolate","coordinate","slice","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","ends","interpolate","ii"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {module:ol/coordinate~Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {module:ol/coordinate~Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map"]},"metadata":{},"sourceType":"module"}