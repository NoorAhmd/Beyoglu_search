{"ast":null,"code":"/**\n * @module ol/render/canvas/Replay\n */\nimport { getUid } from '../../util.js';\nimport { UNDEFINED } from '../../functions.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, extend, extendCoordinate, intersects } from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { CANVAS_LINE_DASH } from '../../has.js';\nimport { isEmpty } from '../../obj.js';\nimport VectorContext from '../VectorContext.js';\nimport { drawImage, resetTransform, defaultPadding, defaultFillStyle, defaultStrokeStyle, defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset, defaultLineDash, defaultLineCap } from '../canvas.js';\nimport CanvasInstruction from '../canvas/Instruction.js';\nimport { TEXT_ALIGN } from '../replay.js';\nimport { create as createTransform, compose as composeTransform, apply as applyTransform, setFromArray as transformSetFromArray } from '../../transform.js';\n/**\n * @type {module:ol/extent~Extent}\n */\n\nvar tmpExtent = createEmpty();\n/**\n * @type {!module:ol/transform~Transform}\n */\n\nvar tmpTransform = createTransform();\n\nvar CanvasReplay = function (VectorContext) {\n  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    VectorContext.call(this);\n    /**\n     * @type {?}\n     */\n\n    this.declutterTree = declutterTree;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {boolean}\n     */\n\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n\n    this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n\n    this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n\n    this.instructions = [];\n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n\n    this.coordinates = [];\n    /**\n     * @private\n     * @type {!Object.<number,module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!module:ol/transform~Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n\n    this.hitDetectionInstructions = [];\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @protected\n     * @type {module:ol/render/canvas~FillStrokeState}\n     */\n\n    this.state =\n    /** @type {module:ol/render/canvas~FillStrokeState} */\n    {};\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n  }\n\n  if (VectorContext) CanvasReplay.__proto__ = VectorContext;\n  CanvasReplay.prototype = Object.create(VectorContext && VectorContext.prototype);\n  CanvasReplay.prototype.constructor = CanvasReplay;\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/coordinate~Coordinate} p1 1st point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p2 2nd point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p3 3rd point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p4 4th point of the background box.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n\n  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ =\n      /** @type {boolean} */\n      fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context,\n      /** @type {Array.<*>} */\n      strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array.<number>} padding Padding.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  CanvasReplay.prototype.replayImage_ = function replayImage_(context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > image.width ? image.width - originX : width;\n    var h = height + originY > image.height ? image.height - originY : height;\n    var boxW = padding[3] + w * scale + padding[1];\n    var boxH = padding[0] + h * scale + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n    /** @type {module:ol/coordinate~Coordinate} */\n\n    var p1;\n    /** @type {module:ol/coordinate~Coordinate} */\n\n    var p2;\n    /** @type {module:ol/coordinate~Coordinate} */\n\n    var p3;\n    /** @type {module:ol/coordinate~Coordinate} */\n\n    var p4;\n\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n\n    var transform = null;\n\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      createOrUpdateEmpty(tmpExtent);\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p1));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p2));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p3));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p4));\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 && tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n\n      extend(declutterGroup, tmpExtent);\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;\n\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n        /** @type {Array.<*>} */\n        fillInstruction,\n        /** @type {Array.<*>} */\n        strokeInstruction);\n      }\n\n      drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  };\n  /**\n   * @protected\n   * @param {Array.<number>} dashArray Dash array.\n   * @return {Array.<number>} Dash array with pixel ratio applied\n   */\n\n\n  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio(dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var this$1 = this;\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var nextCoord = [NaN, NaN];\n    var skipped = true;\n    var i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this$1.coordinates[myEnd++] = lastCoord[0];\n          this$1.coordinates[myEnd++] = lastCoord[1];\n        }\n\n        this$1.coordinates[myEnd++] = nextCoord[0];\n        this$1.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this$1.coordinates[myEnd++] = nextCoord[0];\n        this$1.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array.<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n\n\n  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, replayEnds) {\n    var this$1 = this;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var replayEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc.\n   */\n\n\n  CanvasReplay.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {\n    var this$1 = this;\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var replayBegin = this.coordinates.length;\n    var flatCoordinates, replayEnd, replayEnds, replayEndss;\n    var offset;\n\n    if (type == GeometryType.MULTI_POLYGON) {\n      geometry =\n      /** @type {module:ol/geom/MultiPolygon} */\n      geometry;\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this$1.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = type == GeometryType.POLYGON ?\n      /** @type {module:ol/geom/Polygon} */\n      geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n      /** @type {module:ol/geom/Polygon|module:ol/geom/MultiLineString} */\n      geometry.getEnds(), stride, replayEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);\n    }\n\n    this.endGeometry(geometry, feature);\n  };\n  /**\n   * @protected\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.beginGeometry = function beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  CanvasReplay.prototype.fill_ = function fill_(context) {\n    if (this.alignFill_) {\n      var origin = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.setTransform.apply(context, resetTransform);\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array.<*>} instruction Instruction.\n   */\n\n\n  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(context, instruction) {\n    context.strokeStyle =\n    /** @type {module:ol/colorlike~ColorLike} */\n    instruction[1];\n    context.lineWidth =\n    /** @type {number} */\n    instruction[2];\n    context.lineCap =\n    /** @type {string} */\n    instruction[3];\n    context.lineJoin =\n    /** @type {string} */\n    instruction[4];\n    context.miterLimit =\n    /** @type {number} */\n    instruction[5];\n\n    if (CANVAS_LINE_DASH) {\n      context.lineDashOffset =\n      /** @type {number} */\n      instruction[7];\n      context.setLineDash(\n      /** @type {Array.<number>} */\n      instruction[6]);\n    }\n  };\n  /**\n   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_(declutterGroup, feature) {\n    var this$1 = this;\n\n    if (declutterGroup && declutterGroup.length > 5) {\n      var groupCount = declutterGroup[4];\n\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {module:ol/structs/RBush~Entry} */\n        var box = {\n          minX:\n          /** @type {number} */\n          declutterGroup[0],\n          minY:\n          /** @type {number} */\n          declutterGroup[1],\n          maxX:\n          /** @type {number} */\n          declutterGroup[2],\n          maxY:\n          /** @type {number} */\n          declutterGroup[3],\n          value: feature\n        };\n\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n\n          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            var declutterData =\n            /** @type {Array} */\n            declutterGroup[j];\n\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this$1.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\n              }\n\n              drawImage.apply(undefined, declutterData);\n            }\n          }\n        }\n\n        declutterGroup.length = 5;\n        createOrUpdateEmpty(declutterGroup);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array.<*>} instructions Instructions array.\n   * @param {function((module:ol/Feature|module:ol/render/Feature)): T|undefined}\n   *     featureCallback Feature callback.\n   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplay.prototype.replay_ = function replay_(context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {\n    var this$1 = this;\n    /** @type {Array.<number>} */\n\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    var skipFeatures = !isEmpty(skippedFeaturesHash);\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var state =\n    /** @type {module:ol/render~State} */\n    {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {module:ol/Feature|module:ol/render/Feature} */\n    feature;\n    var x, y;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type =\n      /** @type {module:ol/render/canvas/Instruction} */\n      instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature =\n          /** @type {module:ol/Feature|module:ol/render/Feature} */\n          instruction[1];\n\n          if (skipFeatures && skippedFeaturesHash[getUid(feature).toString()] || !feature.getGeometry()) {\n            i =\n            /** @type {number} */\n            instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this$1.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd = instruction[2];\n          var geometry =\n          /** @type {module:ol/geom/SimpleGeometry} */\n          instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          image =\n          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX =\n          /** @type {number} */\n          instruction[4];\n          anchorY =\n          /** @type {number} */\n          instruction[5];\n          declutterGroup = featureCallback ? null :\n          /** @type {module:ol/render/canvas~DeclutterGroup} */\n          instruction[6];\n          var height =\n          /** @type {number} */\n          instruction[7];\n          var opacity =\n          /** @type {number} */\n          instruction[8];\n          var originX =\n          /** @type {number} */\n          instruction[9];\n          var originY =\n          /** @type {number} */\n          instruction[10];\n          var rotateWithView =\n          /** @type {boolean} */\n          instruction[11];\n          var rotation =\n          /** @type {number} */\n          instruction[12];\n          var scale =\n          /** @type {number} */\n          instruction[13];\n          var snapToPixel =\n          /** @type {boolean} */\n          instruction[14];\n          var width =\n          /** @type {number} */\n          instruction[15];\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 16) {\n            padding =\n            /** @type {Array.<number>} */\n            instruction[16];\n            backgroundFill =\n            /** @type {boolean} */\n            instruction[17];\n            backgroundStroke =\n            /** @type {boolean} */\n            instruction[18];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = backgroundStroke = false;\n          }\n\n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n\n          for (; d < dd; d += 2) {\n            this$1.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?\n            /** @type {Array.<*>} */\n            lastFillInstruction : null, backgroundStroke ?\n            /** @type {Array.<*>} */\n            lastStrokeInstruction : null);\n          }\n\n          this$1.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          var begin =\n          /** @type {number} */\n          instruction[1];\n          var end =\n          /** @type {number} */\n          instruction[2];\n          var baseline =\n          /** @type {number} */\n          instruction[3];\n          declutterGroup = featureCallback ? null :\n          /** @type {module:ol/render/canvas~DeclutterGroup} */\n          instruction[4];\n          var overflow =\n          /** @type {number} */\n          instruction[5];\n          var fillKey =\n          /** @type {string} */\n          instruction[6];\n          var maxAngle =\n          /** @type {number} */\n          instruction[7];\n          var measure =\n          /** @type {function(string):number} */\n          instruction[8];\n          var offsetY =\n          /** @type {number} */\n          instruction[9];\n          var strokeKey =\n          /** @type {string} */\n          instruction[10];\n          var strokeWidth =\n          /** @type {number} */\n          instruction[11];\n          var text =\n          /** @type {string} */\n          instruction[12];\n          var textKey =\n          /** @type {string} */\n          instruction[13];\n          var textScale =\n          /** @type {number} */\n          instruction[14];\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = measure(text);\n\n          if (overflow || textLength <= pathLength) {\n            var textAlign =\n            /** @type {module:ol~render} */\n            this$1.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n\n            if (parts) {\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label =\n                  /** @type {module:ol~render} */\n                  this$1.getImage(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this$1.replayImage_(context,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], textScale, false, label.width, defaultPadding, null, null);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label =\n                  /** @type {module:ol~render} */\n                  this$1.getImage(chars, textKey, fillKey, '');\n                  anchorX =\n                  /** @type {number} */\n                  part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  this$1.replayImage_(context,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], textScale, false, label.width, defaultPadding, null, null);\n                }\n              }\n            }\n          }\n\n          this$1.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature =\n            /** @type {module:ol/Feature|module:ol/render/Feature} */\n            instruction[1];\n            var result = featureCallback(feature);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this$1.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this$1.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this$1.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n          /** @type {module:ol/colorlike~ColorLike} */\n          instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this$1.setStrokeStyle_(context,\n          /** @type {Array.<*>} */\n          instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   */\n\n\n  CanvasReplay.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((module:ol/Feature|module:ol/render/Feature)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplay.prototype.replayHitDetection = function replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions() {\n    var this$1 = this;\n    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {module:ol/render/canvas/Instruction} */\n      instruction[0];\n\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this$1.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n    var state = this.state;\n\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @return {Array.<*>} Fill instruction.\n   */\n\n\n  CanvasReplay.prototype.createFill = function createFill(state, geometry) {\n    var fillStyle = state.fillStyle;\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  };\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   */\n\n\n  CanvasReplay.prototype.applyStroke = function applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @return {Array.<*>} Stroke instruction.\n   */\n\n\n  CanvasReplay.prototype.createStroke = function createStroke(state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState, (module:ol/geom/Geometry|module:ol/render/Feature)):Array.<*>} createFill Create fill.\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   */\n\n\n  CanvasReplay.prototype.updateFillStyle = function updateFillStyle(state, createFill, geometry) {\n    var fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state, geometry));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState)} applyStroke Apply stroke.\n   */\n\n\n  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle(state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.endGeometry = function endGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {module:ol/extent~Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasReplay;\n}(VectorContext);\n/**\n * FIXME empty description for jsdoc\n */\n\n\nCanvasReplay.prototype.finish = UNDEFINED;\nexport default CanvasReplay; //# sourceMappingURL=Replay.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/render/canvas/Replay.js"],"names":["getUid","UNDEFINED","equals","reverseSubArray","asColorLike","buffer","clone","coordinateRelationship","createEmpty","createOrUpdate","createOrUpdateEmpty","extend","extendCoordinate","intersects","Relationship","GeometryType","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","lineStringLength","drawTextOnPath","transform2D","CANVAS_LINE_DASH","isEmpty","VectorContext","drawImage","resetTransform","defaultPadding","defaultFillStyle","defaultStrokeStyle","defaultMiterLimit","defaultLineWidth","defaultLineJoin","defaultLineDashOffset","defaultLineDash","defaultLineCap","CanvasInstruction","TEXT_ALIGN","create","createTransform","compose","composeTransform","apply","applyTransform","setFromArray","transformSetFromArray","tmpExtent","tmpTransform","CanvasReplay","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","maxLineWidth","alignFill_","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","state","viewRotation_","__proto__","prototype","Object","constructor","replayTextBackground_","context","p1","p2","p3","p4","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","replayImage_","x","y","image","anchorX","anchorY","declutterGroup","height","opacity","originX","originY","rotation","scale","snapToPixel","width","padding","fillStroke","w","h","boxW","boxH","boxX","boxY","transform","centerX","centerY","canvas","strokePadding","Math","round","declutterArgs","slice","push","applyPixelRatio","dashArray","map","dash","appendFlatCoordinates","flatCoordinates","offset","end","stride","closed","skipFirst","this$1","myEnd","length","extent","getBufferedMaxExtent","lastCoord","nextCoord","NaN","skipped","i","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","replayEnds","ii","replayEnd","drawCustom","geometry","feature","renderer","beginGeometry","type","getType","getStride","replayBegin","replayEndss","MULTI_POLYGON","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","POLYGON","MULTI_LINE_STRING","getFlatCoordinates","getEnds","LINE_STRING","MULTI_POINT","POINT","endGeometry","BEGIN_GEOMETRY","origin","repeatSize","translate","rotate","fill","setTransform","instruction","strokeStyle","lineWidth","lineCap","lineJoin","miterLimit","lineDashOffset","setLineDash","renderDeclutter_","groupCount","box","minX","minY","maxX","maxY","value","collides","insert","j","jj","declutterData","undefined","replay_","skippedFeaturesHash","featureCallback","opt_hitExtent","pixelCoordinates","skipFeatures","d","dd","prevX","prevY","roundX","roundY","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","batchSize","toString","getGeometry","getExtent","BEGIN_PATH","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","fn","coords","DRAW_IMAGE","rotateWithView","backgroundFill","backgroundStroke","DRAW_CHARS","begin","baseline","overflow","fillKey","maxAngle","measure","offsetY","strokeKey","strokeWidth","text","textKey","textScale","pathLength","textLength","textAlign","textStates","startM","parts","c","cc","chars","label","part","getImage","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","fillStyle","SET_STROKE_STYLE","STROKE","replay","replayHitDetection","opt_featureCallback","reverseHitDetectionInstructions","reverse","n","setFillStrokeStyle","fillStyleColor","getColor","strokeStyleColor","strokeStyleLineCap","getLineCap","strokeStyleLineDash","getLineDash","lineDash","strokeStyleLineDashOffset","getLineDashOffset","strokeStyleLineJoin","getLineJoin","strokeStyleWidth","getWidth","strokeStyleMiterLimit","getMiterLimit","createFill","applyStroke","createStroke","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","finish"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/Replay\n */\nimport {getUid} from '../../util.js';\nimport {UNDEFINED} from '../../functions.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {buffer, clone, coordinateRelationship, createEmpty, createOrUpdate,\n  createOrUpdateEmpty, extend, extendCoordinate, intersects} from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport {inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray} from '../../geom/flat/inflate.js';\nimport {lineStringLength} from '../../geom/flat/length.js';\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {CANVAS_LINE_DASH} from '../../has.js';\nimport {isEmpty} from '../../obj.js';\nimport VectorContext from '../VectorContext.js';\nimport {drawImage, resetTransform, defaultPadding, defaultFillStyle, defaultStrokeStyle,\n  defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset,\n  defaultLineDash, defaultLineCap} from '../canvas.js';\nimport CanvasInstruction from '../canvas/Instruction.js';\nimport {TEXT_ALIGN} from '../replay.js';\nimport {\n  create as createTransform,\n  compose as composeTransform,\n  apply as applyTransform,\n  setFromArray as transformSetFromArray\n} from '../../transform.js';\n\n\n/**\n * @type {module:ol/extent~Extent}\n */\nvar tmpExtent = createEmpty();\n\n\n/**\n * @type {!module:ol/transform~Transform}\n */\nvar tmpTransform = createTransform();\n\n\nvar CanvasReplay = (function (VectorContext) {\n  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    VectorContext.call(this);\n\n    /**\n     * @type {?}\n     */\n    this.declutterTree = declutterTree;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {module:ol/extent~Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array.<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array.<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {!Object.<number,module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!module:ol/transform~Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array.<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @protected\n     * @type {module:ol/render/canvas~FillStrokeState}\n     */\n    this.state = /** @type {module:ol/render/canvas~FillStrokeState} */ ({});\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n  }\n\n  if ( VectorContext ) CanvasReplay.__proto__ = VectorContext;\n  CanvasReplay.prototype = Object.create( VectorContext && VectorContext.prototype );\n  CanvasReplay.prototype.constructor = CanvasReplay;\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/coordinate~Coordinate} p1 1st point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p2 2nd point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p3 3rd point of the background box.\n   * @param {module:ol/coordinate~Coordinate} p4 4th point of the background box.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_ (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction));\n      context.stroke();\n    }\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array.<number>} padding Padding.\n   * @param {Array.<*>} fillInstruction Fill instruction.\n   * @param {Array.<*>} strokeInstruction Stroke instruction.\n   */\n  CanvasReplay.prototype.replayImage_ = function replayImage_ (\n    context,\n    x,\n    y,\n    image,\n    anchorX,\n    anchorY,\n    declutterGroup,\n    height,\n    opacity,\n    originX,\n    originY,\n    rotation,\n    scale,\n    snapToPixel,\n    width,\n    padding,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n\n    var w = (width + originX > image.width) ? image.width - originX : width;\n    var h = (height + originY > image.height) ? image.height - originY : height;\n    var boxW = padding[3] + w * scale + padding[1];\n    var boxH = padding[0] + h * scale + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    /** @type {module:ol/coordinate~Coordinate} */\n    var p1;\n    /** @type {module:ol/coordinate~Coordinate} */\n    var p2;\n    /** @type {module:ol/coordinate~Coordinate} */\n    var p3;\n    /** @type {module:ol/coordinate~Coordinate} */\n    var p4;\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n\n    var transform = null;\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n\n      createOrUpdateEmpty(tmpExtent);\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p1));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p2));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p3));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p4));\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;\n    var intersects =\n        tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&\n        tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n      extend(declutterGroup, tmpExtent);\n      var declutterArgs = intersects ?\n        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :\n        null;\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n          /** @type {Array.<*>} */ (fillInstruction),\n          /** @type {Array.<*>} */ (strokeInstruction));\n      }\n      drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  };\n\n  /**\n   * @protected\n   * @param {Array.<number>} dashArray Dash array.\n   * @return {Array.<number>} Dash array with pixel ratio applied\n   */\n  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\n      return dash * pixelRatio;\n    });\n  };\n\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var this$1 = this;\n\n\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var nextCoord = [NaN, NaN];\n    var skipped = true;\n\n    var i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this$1.coordinates[myEnd++] = lastCoord[0];\n          this$1.coordinates[myEnd++] = lastCoord[1];\n        }\n        this$1.coordinates[myEnd++] = nextCoord[0];\n        this$1.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this$1.coordinates[myEnd++] = nextCoord[0];\n        this$1.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n    return myEnd;\n  };\n\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array.<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_ (flatCoordinates, offset, ends, stride, replayEnds) {\n    var this$1 = this;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var replayEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n    return offset;\n  };\n\n  /**\n   * @inheritDoc.\n   */\n  CanvasReplay.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {\n    var this$1 = this;\n\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var replayBegin = this.coordinates.length;\n    var flatCoordinates, replayEnd, replayEnds, replayEndss;\n    var offset;\n    if (type == GeometryType.MULTI_POLYGON) {\n      geometry = /** @type {module:ol/geom/MultiPolygon} */ (geometry);\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this$1.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = (type == GeometryType.POLYGON) ?\n        /** @type {module:ol/geom/Polygon} */ (geometry).getOrientedFlatCoordinates() :\n        geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {module:ol/geom/Polygon|module:ol/geom/MultiLineString} */ (geometry).getEnds(),\n        stride, replayEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer]);\n    }\n    this.endGeometry(geometry, feature);\n  };\n\n  /**\n   * @protected\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n  CanvasReplay.prototype.beginGeometry = function beginGeometry (geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  CanvasReplay.prototype.fill_ = function fill_ (context) {\n    if (this.alignFill_) {\n      var origin = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.setTransform.apply(context, resetTransform);\n    }\n  };\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array.<*>} instruction Instruction.\n   */\n  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_ (context, instruction) {\n    context.strokeStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {string} */ (instruction[3]);\n    context.lineJoin = /** @type {string} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    if (CANVAS_LINE_DASH) {\n      context.lineDashOffset = /** @type {number} */ (instruction[7]);\n      context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));\n    }\n  };\n\n  /**\n   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_ (declutterGroup, feature) {\n    var this$1 = this;\n\n    if (declutterGroup && declutterGroup.length > 5) {\n      var groupCount = declutterGroup[4];\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {module:ol/structs/RBush~Entry} */\n        var box = {\n          minX: /** @type {number} */ (declutterGroup[0]),\n          minY: /** @type {number} */ (declutterGroup[1]),\n          maxX: /** @type {number} */ (declutterGroup[2]),\n          maxY: /** @type {number} */ (declutterGroup[3]),\n          value: feature\n        };\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            var declutterData = /** @type {Array} */ (declutterGroup[j]);\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this$1.replayTextBackground_(declutterData[0],\n                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],\n                  declutterData[11], declutterData[12]);\n              }\n              drawImage.apply(undefined, declutterData);\n            }\n          }\n        }\n        declutterGroup.length = 5;\n        createOrUpdateEmpty(declutterGroup);\n      }\n    }\n  };\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array.<*>} instructions Instructions array.\n   * @param {function((module:ol/Feature|module:ol/render/Feature)): T|undefined}\n   *     featureCallback Feature callback.\n   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplay.prototype.replay_ = function replay_ (\n    context,\n    transform,\n    skippedFeaturesHash,\n    instructions,\n    featureCallback,\n    opt_hitExtent\n  ) {\n    var this$1 = this;\n\n    /** @type {Array.<number>} */\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(\n        this.coordinates, 0, this.coordinates.length, 2,\n        transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    var skipFeatures = !isEmpty(skippedFeaturesHash);\n    var i = 0; // instruction index\n    var ii = instructions.length; // end of instructions\n    var d = 0; // data index\n    var dd; // end of per-instruction data\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n\n    var state = /** @type {module:ol/render~State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    });\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var /** @type {module:ol/Feature|module:ol/render/Feature} */ feature;\n    var x, y;\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);\n          if ((skipFeatures &&\n              skippedFeaturesHash[getUid(feature).toString()]) ||\n              !feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (opt_hitExtent !== undefined && !intersects(\n            opt_hitExtent, feature.getGeometry().getExtent())) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this$1.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (instruction[3]);\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          var coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n              (instruction[3]);\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[6]);\n          var height = /** @type {number} */ (instruction[7]);\n          var opacity = /** @type {number} */ (instruction[8]);\n          var originX = /** @type {number} */ (instruction[9]);\n          var originY = /** @type {number} */ (instruction[10]);\n          var rotateWithView = /** @type {boolean} */ (instruction[11]);\n          var rotation = /** @type {number} */ (instruction[12]);\n          var scale = /** @type {number} */ (instruction[13]);\n          var snapToPixel = /** @type {boolean} */ (instruction[14]);\n          var width = /** @type {number} */ (instruction[15]);\n\n          var padding = (void 0), backgroundFill = (void 0), backgroundStroke = (void 0);\n          if (instruction.length > 16) {\n            padding = /** @type {Array.<number>} */ (instruction[16]);\n            backgroundFill = /** @type {boolean} */ (instruction[17]);\n            backgroundStroke = /** @type {boolean} */ (instruction[18]);\n          } else {\n            padding = defaultPadding;\n            backgroundFill = backgroundStroke = false;\n          }\n\n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n          for (; d < dd; d += 2) {\n            this$1.replayImage_(context,\n              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,\n              declutterGroup, height, opacity, originX, originY, rotation, scale,\n              snapToPixel, width, padding,\n              backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,\n              backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\n          }\n          this$1.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = /** @type {number} */ (instruction[1]);\n          var end = /** @type {number} */ (instruction[2]);\n          var baseline = /** @type {number} */ (instruction[3]);\n          declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[4]);\n          var overflow = /** @type {number} */ (instruction[5]);\n          var fillKey = /** @type {string} */ (instruction[6]);\n          var maxAngle = /** @type {number} */ (instruction[7]);\n          var measure = /** @type {function(string):number} */ (instruction[8]);\n          var offsetY = /** @type {number} */ (instruction[9]);\n          var strokeKey = /** @type {string} */ (instruction[10]);\n          var strokeWidth = /** @type {number} */ (instruction[11]);\n          var text = /** @type {string} */ (instruction[12]);\n          var textKey = /** @type {string} */ (instruction[13]);\n          var textScale = /** @type {number} */ (instruction[14]);\n\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = measure(text);\n          if (overflow || textLength <= pathLength) {\n            var textAlign = /** @type {module:ol~render} */ (this$1).textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(\n              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n            if (parts) {\n              var c = (void 0), cc = (void 0), chars = (void 0), label = (void 0), part = (void 0);\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this$1.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    defaultPadding, null, null);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  this$1.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    defaultPadding, null, null);\n                }\n              }\n            }\n          }\n          this$1.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);\n            var result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this$1.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this$1.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this$1.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this$1.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   */\n  CanvasReplay.prototype.replay = function replay (context, transform, viewRotation, skippedFeaturesHash) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform,\n      skippedFeaturesHash, this.instructions, undefined, undefined);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/transform~Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((module:ol/Feature|module:ol/render/Feature)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplay.prototype.replayHitDetection = function replayHitDetection (\n    context,\n    transform,\n    viewRotation,\n    skippedFeaturesHash,\n    opt_featureCallback,\n    opt_hitExtent\n  ) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash,\n      this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\n  };\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions () {\n    var this$1 = this;\n\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this$1.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ?\n        fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ?\n        strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ?\n        strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ?\n        strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ?\n        strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ?\n        strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ?\n        strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ?\n        strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @return {Array.<*>} Fill instruction.\n   */\n  CanvasReplay.prototype.createFill = function createFill (state, geometry) {\n    var fillStyle = state.fillStyle;\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  };\n\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   */\n  CanvasReplay.prototype.applyStroke = function applyStroke (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @return {Array.<*>} Stroke instruction.\n   */\n  CanvasReplay.prototype.createStroke = function createStroke (state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\n      state.lineJoin, state.miterLimit,\n      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\n    ];\n  };\n\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState, (module:ol/geom/Geometry|module:ol/render/Feature)):Array.<*>} createFill Create fill.\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   */\n  CanvasReplay.prototype.updateFillStyle = function updateFillStyle (state, createFill, geometry) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state, geometry));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  };\n\n  /**\n   * @param {module:ol/render/canvas~FillStrokeState} state State.\n   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState)} applyStroke Apply stroke.\n   */\n  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle ||\n        state.currentLineCap != lineCap ||\n        (lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash)) ||\n        state.currentLineDashOffset != lineDashOffset ||\n        state.currentLineJoin != lineJoin ||\n        state.currentLineWidth != lineWidth ||\n        state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n\n  /**\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   */\n  CanvasReplay.prototype.endGeometry = function endGeometry (geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {module:ol/extent~Extent} The buffered rendering extent.\n   * @protected\n   */\n  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasReplay;\n}(VectorContext));\n\n\n/**\n * FIXME empty description for jsdoc\n */\nCanvasReplay.prototype.finish = UNDEFINED;\n\n\nexport default CanvasReplay;\n\n//# sourceMappingURL=Replay.js.map"]},"metadata":{},"sourceType":"module"}