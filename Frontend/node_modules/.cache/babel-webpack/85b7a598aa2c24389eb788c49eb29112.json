{"ast":null,"code":"/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { modulo } from '../math.js';\nimport { getTransform } from '../proj.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array.<module:ol/coordinate~Coordinate>} source\n * @property {Array.<module:ol/coordinate~Coordinate>} target\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\n\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\n\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\n\nvar Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n  /**\n   * @type {module:ol/proj/Projection}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n  /**\n   * @type {module:ol/proj/Projection}\n   * @private\n   */\n\n  this.targetProj_ = targetProj;\n  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */\n\n  var transformInvCache = {};\n  var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n  /**\n   * @param {module:ol/coordinate~Coordinate} c A coordinate.\n   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.\n   * @private\n   */\n\n  this.transformInv_ = function (c) {\n    var key = c[0] + '/' + c[1];\n\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n\n    return transformInvCache[key];\n  };\n  /**\n   * @type {module:ol/extent~Extent}\n   * @private\n   */\n\n\n  this.maxSourceExtent_ = maxSourceExtent;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n  /**\n   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}\n   * @private\n   */\n\n  this.triangles_ = [];\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n\n  this.wrapsXInSource_ = false;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n  var destinationTopLeft = getTopLeft(targetExtent);\n  var destinationTopRight = getTopRight(targetExtent);\n  var destinationBottomRight = getBottomRight(targetExtent);\n  var destinationBottomLeft = getBottomLeft(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function (triangle, i, arr) {\n      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    }); // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n\n    this.triangles_.forEach(function (triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        } // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n\n\n        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n        if (maxX - minX < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }.bind(this));\n  }\n\n  transformInvCache = {};\n};\n/**\n * Adds triangle to the triangulation.\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\n * @private\n */\n\n\nTriangulation.prototype.addTriangle_ = function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\n * @param {module:ol/coordinate~Coordinate} d The target d coordinate.\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\n * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\n\n\nTriangulation.prototype.addQuad_ = function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n  var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth =\n  /** @type {number} */\n  this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n\n  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = boundingExtent([a, b, c, d]);\n      var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision |= targetCoverageX > MAX_TRIANGLE_WIDTH;\n    }\n\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision |= sourceCoverageX > MAX_TRIANGLE_WIDTH;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n      var dx;\n\n      if (wrapsX) {\n        var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {module:ol/extent~Extent} Calculated extent.\n */\n\n\nTriangulation.prototype.calculateSourceExtent = function calculateSourceExtent() {\n  var extent = createEmpty();\n  this.triangles_.forEach(function (triangle, i, arr) {\n    var src = triangle.source;\n    extendCoordinate(extent, src[0]);\n    extendCoordinate(extent, src[1]);\n    extendCoordinate(extent, src[2]);\n  });\n  return extent;\n};\n/**\n * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.\n */\n\n\nTriangulation.prototype.getTriangles = function getTriangles() {\n  return this.triangles_;\n};\n\nexport default Triangulation; //# sourceMappingURL=Triangulation.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/reproj/Triangulation.js"],"names":["boundingExtent","createEmpty","extendCoordinate","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","modulo","getTransform","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","addQuad_","leftBound","Infinity","forEach","triangle","i","arr","Math","min","source","max","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","maxSubdivision","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"mappings":"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","sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport {boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight,\n  getTopLeft, getTopRight, getWidth, intersects} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {getTransform} from '../proj.js';\n\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array.<module:ol/coordinate~Coordinate>} source\n * @property {Array.<module:ol/coordinate~Coordinate>} target\n */\n\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n\n  /**\n   * @type {module:ol/proj/Projection}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n\n  /**\n   * @type {module:ol/proj/Projection}\n   * @private\n   */\n  this.targetProj_ = targetProj;\n\n  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */\n  var transformInvCache = {};\n  var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n  /**\n   * @param {module:ol/coordinate~Coordinate} c A coordinate.\n   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.\n   * @private\n   */\n  this.transformInv_ = function(c) {\n    var key = c[0] + '/' + c[1];\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n    return transformInvCache[key];\n  };\n\n  /**\n   * @type {module:ol/extent~Extent}\n   * @private\n   */\n  this.maxSourceExtent_ = maxSourceExtent;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n  /**\n   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}\n   * @private\n   */\n  this.triangles_ = [];\n\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n  this.wrapsXInSource_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      (getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent()));\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\n    getWidth(this.sourceProj_.getExtent()) : null;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ?\n    getWidth(this.targetProj_.getExtent()) : null;\n\n  var destinationTopLeft = getTopLeft(targetExtent);\n  var destinationTopRight = getTopRight(targetExtent);\n  var destinationBottomRight = getBottomRight(targetExtent);\n  var destinationBottomLeft = getBottomLeft(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n  this.addQuad_(\n    destinationTopLeft, destinationTopRight,\n    destinationBottomRight, destinationBottomLeft,\n    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\n    MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function(triangle, i, arr) {\n      leftBound = Math.min(leftBound,\n        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    });\n\n    // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n    this.triangles_.forEach(function(triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0],\n        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\n          [triangle.source[1][0], triangle.source[1][1]],\n          [triangle.source[2][0], triangle.source[2][1]]];\n        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        }\n\n        // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n        var minX = Math.min(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }.bind(this));\n  }\n\n  transformInvCache = {};\n};\n\n/**\n * Adds triangle to the triangulation.\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\n * @private\n */\nTriangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\n * @param {module:ol/coordinate~Coordinate} d The target d coordinate.\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\n * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\nTriangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n\n  var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ?\n    getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n  // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n  var wrapsX = this.sourceProj_.canWrapX() &&\n               sourceCoverageX > 0.5 && sourceCoverageX < 1;\n\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = boundingExtent([a, b, c, d]);\n      var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision |=\n          targetCoverageX > MAX_TRIANGLE_WIDTH;\n    }\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision |=\n          sourceCoverageX > MAX_TRIANGLE_WIDTH;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n\n      var dx;\n      if (wrapsX) {\n        var centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n             modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX -\n            modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n\n        this.addQuad_(\n          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(\n          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n\n        this.addQuad_(\n          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(\n          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {module:ol/extent~Extent} Calculated extent.\n */\nTriangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {\n  var extent = createEmpty();\n\n  this.triangles_.forEach(function(triangle, i, arr) {\n    var src = triangle.source;\n    extendCoordinate(extent, src[0]);\n    extendCoordinate(extent, src[1]);\n    extendCoordinate(extent, src[2]);\n  });\n\n  return extent;\n};\n\n/**\n * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.\n */\nTriangulation.prototype.getTriangles = function getTriangles () {\n  return this.triangles_;\n};\n\nexport default Triangulation;\n\n//# sourceMappingURL=Triangulation.js.map"]},"metadata":{},"sourceType":"module"}