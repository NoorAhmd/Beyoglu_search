{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport { getUid } from '../util.js';\nimport { CollectionEvent } from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment } from '../coordinate.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport PointerInteraction, { handleEvent as handlePointerEvent } from '../interaction/Pointer.js';\nimport { getValues } from '../obj.js';\nimport { VectorSourceEvent } from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {module:ol/coordinate~Coordinate|null} vertex\n * @property {module:ol/pixel~Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {module:ol/Feature} feature\n * @property {Array.<module:ol/coordinate~Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\n\nvar Snap = function (PointerInteraction) {\n  function Snap(opt_options) {\n    PointerInteraction.call(this, {\n      handleEvent: handleEvent,\n      handleDownEvent: TRUE,\n      handleUpEvent: handleUpEvent,\n      stopDown: FALSE\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n     * @type {module:ol/source/Vector}\n     * @private\n     */\n\n    this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {module:ol/Collection.<module:ol/Feature>}\n     * @private\n     */\n\n    this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array.<module:ol/events~EventsKey>}\n     * @private\n     */\n\n    this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object.<number, module:ol/events~EventsKey>}\n     * @private\n     */\n\n    this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object.<number, module:ol/extent~Extent>}\n     * @private\n     */\n\n    this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object.<number, module:ol/Feature>}\n     * @private\n     */\n\n    this.pendingFeatures_ = {};\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {module:ol/coordinate~Coordinate}\n     * @private\n     */\n\n    this.pixelCoordinate_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}\n     * @private\n     */\n\n    this.sortByDistance_ = sortByDistance.bind(this);\n    /**\n    * Segment RTree for each layer\n    * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}\n    * @private\n    */\n\n    this.rBush_ = new RBush();\n    /**\n    * @const\n    * @private\n    * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}\n    */\n\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  if (PointerInteraction) Snap.__proto__ = PointerInteraction;\n  Snap.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  Snap.prototype.constructor = Snap;\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {module:ol/Feature} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n  Snap.prototype.addFeature = function addFeature(feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function getFeatures_() {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return (\n      /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */\n      features\n    );\n  };\n  /**\n   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n    var feature;\n\n    if (evt instanceof VectorSourceEvent) {\n      feature = evt.feature;\n    } else if (evt instanceof CollectionEvent) {\n      feature = evt.element;\n    }\n\n    this.addFeature(\n    /** @type {module:ol/Feature} */\n    feature);\n  };\n  /**\n   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n    var feature;\n\n    if (evt instanceof VectorSourceEvent) {\n      feature = evt.feature;\n    } else if (evt instanceof CollectionEvent) {\n      feature = evt.element;\n    }\n\n    this.removeFeature(\n    /** @type {module:ol/Feature} */\n    feature);\n  };\n  /**\n   * @param {module:ol/events/Event} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n    var feature =\n    /** @type {module:ol/Feature} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {module:ol/Feature} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function removeFeature(feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Snap.prototype.setMap = function setMap(map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    PointerInteraction.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {module:ol/pixel~Pixel} pixel Pixel\n   * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate\n   * @param {module:ol/PluggableMap} map Map.\n   * @return {module:ol/interaction/Snap~Result} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function snapTo(pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles\n\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n\n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n          /** @type {module:ol/geom/Circle} */\n          segments[0].feature.getGeometry());\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n\n    return (\n      /** @type {module:ol/interaction/Snap~Result} */\n      {\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      }\n    );\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Circle} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n    var this$1 = this;\n    var polygon = fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData =\n      /** @type {module:ol/interaction/Snap~SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this$1.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/GeometryCollection} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n    var this$1 = this;\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this$1.SEGMENT_WRITERS_[geometries[i].getType()];\n\n      if (segmentWriter) {\n        segmentWriter.call(this$1, feature, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/LineString} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n    var this$1 = this;\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData =\n      /** @type {module:ol/interaction/Snap~SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this$1.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiLineString} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n    var this$1 = this;\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData =\n        /** @type {module:ol/interaction/Snap~SegmentData} */\n        {\n          feature: feature,\n          segment: segment\n        };\n        this$1.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiPoint} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n    var this$1 = this;\n    var points = geometry.getCoordinates();\n\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData =\n      /** @type {module:ol/interaction/Snap~SegmentData} */\n      {\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this$1.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiPolygon} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n    var this$1 = this;\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData =\n          /** @type {module:ol/interaction/Snap~SegmentData} */\n          {\n            feature: feature,\n            segment: segment\n          };\n          this$1.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Point} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData =\n    /** @type {module:ol/interaction/Snap~SegmentData} */\n    {\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Polygon} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n    var this$1 = this;\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData =\n        /** @type {module:ol/interaction/Snap~SegmentData} */\n        {\n          feature: feature,\n          segment: segment\n        };\n        this$1.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n/**\n * Handle all pointer events events.\n * @param {module:ol/MapBrowserEvent} evt A move event.\n * @return {boolean} Pass the event to other interactions.\n * @this {module:ol/interaction/Snap}\n */\n\n\nexport function handleEvent(evt) {\n  var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n  if (result.snapped) {\n    evt.coordinate = result.vertex.slice(0, 2);\n    evt.pixel = result.vertexPixel;\n  }\n\n  return handlePointerEvent.call(this, evt);\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/Snap}\n */\n\nfunction handleUpEvent(evt) {\n  var featuresToUpdate = getValues(this.pendingFeatures_);\n\n  if (featuresToUpdate.length) {\n    featuresToUpdate.forEach(this.updateFeature_.bind(this));\n    this.pendingFeatures_ = {};\n  }\n\n  return false;\n}\n/**\n * Sort segments by distance, helper function\n * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.\n * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {module:ol/interaction/Snap}\n */\n\n\nfunction sortByDistance(a, b) {\n  var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap; //# sourceMappingURL=Snap.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/interaction/Snap.js"],"names":["getUid","CollectionEvent","CollectionEventType","distance","coordinateDistance","squaredDistance","squaredCoordinateDistance","closestOnCircle","closestOnSegment","squaredDistanceToSegment","listen","unlistenByKey","EventType","boundingExtent","createEmpty","TRUE","FALSE","GeometryType","fromCircle","PointerInteraction","handleEvent","handlePointerEvent","getValues","VectorSourceEvent","VectorEventType","RBush","Snap","opt_options","call","handleDownEvent","handleUpEvent","stopDown","options","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelCoordinate_","pixelTolerance_","pixelTolerance","sortByDistance_","sortByDistance","bind","rBush_","SEGMENT_WRITERS_","writePointGeometry_","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeGeometryCollectionGeometry_","writeCircleGeometry_","__proto__","prototype","Object","create","constructor","addFeature","feature","opt_listen","register","feature_uid","geometry","getGeometry","segmentWriter","getType","getExtent","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleFeatureAdd_","evt","element","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","opt_unlisten","unregister","extent","rBush","nodesToRemove","forEachInExtent","node","push","i","length","remove","setMap","map","currentMap","getMap","keys","forEach","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","snapTo","pixel","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","segments","getInExtent","filter","segment","CIRCLE","snappedToVertex","snapped","vertexPixel","dist","pixel1","pixel2","squaredDist1","squaredDist2","sort","closestSegment","isCircle","getPixelFromCoordinate","Math","sqrt","min","round","this$1","polygon","coordinates","getCoordinates","ii","slice","segmentData","insert","geometries","getGeometriesArray","lines","j","jj","points","polygons","k","kk","rings","result","coordinate","featuresToUpdate","a","b","deltaA","deltaB"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport {getUid} from '../util.js';\nimport {CollectionEvent} from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport {distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment} from '../coordinate.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {TRUE, FALSE} from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\nimport {getValues} from '../obj.js';\nimport {VectorSourceEvent} from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {module:ol/coordinate~Coordinate|null} vertex\n * @property {module:ol/pixel~Pixel|null} vertexPixel\n */\n\n\n/**\n * @typedef {Object} SegmentData\n * @property {module:ol/Feature} feature\n * @property {Array.<module:ol/coordinate~Coordinate>} segment\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nvar Snap = (function (PointerInteraction) {\n  function Snap(opt_options) {\n\n    PointerInteraction.call(this, {\n      handleEvent: handleEvent,\n      handleDownEvent: TRUE,\n      handleUpEvent: handleUpEvent,\n      stopDown: FALSE\n    });\n\n    var options = opt_options ? opt_options : {};\n\n    /**\n     * @type {module:ol/source/Vector}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {module:ol/Collection.<module:ol/Feature>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array.<module:ol/events~EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object.<number, module:ol/events~EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object.<number, module:ol/extent~Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object.<number, module:ol/Feature>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {module:ol/coordinate~Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n\n    /**\n     * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n\n    /**\n    * Segment RTree for each layer\n    * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n\n    /**\n    * @const\n    * @private\n    * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  if ( PointerInteraction ) Snap.__proto__ = PointerInteraction;\n  Snap.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );\n  Snap.prototype.constructor = Snap;\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {module:ol/Feature} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function addFeature (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_, this);\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_ (feature) {\n    this.addFeature(feature);\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_ (feature) {\n    this.removeFeature(feature);\n  };\n\n  /**\n   * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function getFeatures_ () {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return (\n      /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */ (features)\n    );\n  };\n\n  /**\n   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {\n    var feature;\n    if (evt instanceof VectorSourceEvent) {\n      feature = evt.feature;\n    } else if (evt instanceof CollectionEvent) {\n      feature = evt.element;\n    }\n    this.addFeature(/** @type {module:ol/Feature} */ (feature));\n  };\n\n  /**\n   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {\n    var feature;\n    if (evt instanceof VectorSourceEvent) {\n      feature = evt.feature;\n    } else if (evt instanceof CollectionEvent) {\n      feature = evt.element;\n    }\n    this.removeFeature(/** @type {module:ol/Feature} */ (feature));\n  };\n\n  /**\n   * @param {module:ol/events/Event} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {\n    var feature = /** @type {module:ol/Feature} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {module:ol/Feature} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function removeFeature (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove = [];\n      rBush.forEachInExtent(extent, function(node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.setMap = function setMap (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    PointerInteraction.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(this.features_, CollectionEventType.ADD,\n            this.handleFeatureAdd_, this),\n          listen(this.features_, CollectionEventType.REMOVE,\n            this.handleFeatureRemove_, this)\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(this.source_, VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_, this),\n          listen(this.source_, VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_, this)\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n\n  /**\n   * @param {module:ol/pixel~Pixel} pixel Pixel\n   * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate\n   * @param {module:ol/PluggableMap} map Map.\n   * @return {module:ol/interaction/Snap~Result} Snap result\n   */\n  Snap.prototype.snapTo = function snapTo (pixel, pixelCoordinate, map) {\n\n    var lowerLeft = map.getCoordinateFromPixel(\n      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel(\n      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n\n    var segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function(segment) {\n        return segment.feature.getGeometry().getType() !==\n            GeometryType.CIRCLE;\n      });\n    }\n\n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() ===\n          GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n            /** @type {module:ol/geom/Circle} */ (segments[0].feature.getGeometry()));\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (\n      /** @type {module:ol/interaction/Snap~Result} */ ({\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      })\n    );\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function updateFeature_ (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Circle} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var polygon = fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this$1.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/GeometryCollection} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this$1.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this$1, feature, geometries[i]);\n      }\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/LineString} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this$1.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiLineString} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this$1.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiPoint} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var points = geometry.getCoordinates();\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n        feature: feature,\n        segment: [coordinates, coordinates]\n      });\n      this$1.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/MultiPolygon} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n            feature: feature,\n            segment: segment\n          });\n          this$1.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Point} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n      feature: feature,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature\n   * @param {module:ol/geom/Polygon} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {\n    var this$1 = this;\n\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this$1.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction));\n\n\n/**\n * Handle all pointer events events.\n * @param {module:ol/MapBrowserEvent} evt A move event.\n * @return {boolean} Pass the event to other interactions.\n * @this {module:ol/interaction/Snap}\n */\nexport function handleEvent(evt) {\n  var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n  if (result.snapped) {\n    evt.coordinate = result.vertex.slice(0, 2);\n    evt.pixel = result.vertexPixel;\n  }\n  return handlePointerEvent.call(this, evt);\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/Snap}\n */\nfunction handleUpEvent(evt) {\n  var featuresToUpdate = getValues(this.pendingFeatures_);\n  if (featuresToUpdate.length) {\n    featuresToUpdate.forEach(this.updateFeature_.bind(this));\n    this.pendingFeatures_ = {};\n  }\n  return false;\n}\n\n\n/**\n * Sort segments by distance, helper function\n * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.\n * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {module:ol/interaction/Snap}\n */\nfunction sortByDistance(a, b) {\n  var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;\n\n//# sourceMappingURL=Snap.js.map"]},"metadata":{},"sourceType":"module"}