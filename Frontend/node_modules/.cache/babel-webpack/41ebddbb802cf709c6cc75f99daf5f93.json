{"ast":null,"code":"/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport { always, mouseOnly, mouseActionButton } from '../events/condition.js';\nimport { UNDEFINED } from '../functions.js';\nimport PointerInteraction from '../interaction/Pointer.js';\nimport RenderBox from '../render/Box.js';\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, module:ol/MapBrowserEvent, module:ol/pixel~Pixel, module:ol/pixel~Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~always}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {module:ol/interaction/DragBox~EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)} onBoxEnd Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\n\nvar DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\n\nvar DragBoxEvent = function (Event) {\n  function DragBoxEvent(type, coordinate, mapBrowserEvent) {\n    Event.call(this, type);\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {module:ol/coordinate~Coordinate}\n     * @api\n     */\n\n    this.coordinate = coordinate;\n    /**\n     * @const\n     * @type {module:ol/MapBrowserEvent}\n     * @api\n     */\n\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n\n  if (Event) DragBoxEvent.__proto__ = Event;\n  DragBoxEvent.prototype = Object.create(Event && Event.prototype);\n  DragBoxEvent.prototype.constructor = DragBoxEvent;\n  return DragBoxEvent;\n}(Event);\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom}).\n *\n * This interaction is only supported for mouse devices.\n *\n * @fires module:ol/interaction/DragBox~DragBoxEvent\n * @api\n */\n\n\nvar DragBox = function (PointerInteraction) {\n  function DragBox(opt_options) {\n    PointerInteraction.call(this, {\n      handleDownEvent: handleDownEvent,\n      handleDragEvent: handleDragEvent,\n      handleUpEvent: handleUpEvent\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n    * @type {module:ol/render/Box}\n    * @private\n    */\n\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n    /**\n    * @type {number}\n    * @private\n    */\n\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n    /**\n     * Function to execute just before `onboxend` is fired\n     * @type {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)}\n     * @private\n     */\n\n    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : UNDEFINED;\n    /**\n    * @type {module:ol/pixel~Pixel}\n    * @private\n    */\n\n    this.startPixel_ = null;\n    /**\n    * @private\n    * @type {module:ol/events/condition~Condition}\n    */\n\n    this.condition_ = options.condition ? options.condition : always;\n    /**\n    * @private\n    * @type {module:ol/interaction/DragBox~EndCondition}\n    */\n\n    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : defaultBoxEndCondition;\n  }\n\n  if (PointerInteraction) DragBox.__proto__ = PointerInteraction;\n  DragBox.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  DragBox.prototype.constructor = DragBox;\n  /**\n  * Returns geometry of last drawn box.\n  * @return {module:ol/geom/Polygon} Geometry.\n  * @api\n  */\n\n  DragBox.prototype.getGeometry = function getGeometry() {\n    return this.box_.getGeometry();\n  };\n\n  return DragBox;\n}(PointerInteraction);\n/**\n * The default condition for determining whether the boxend event\n * should fire.\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\n *     leading to the box end.\n * @param {module:ol/pixel~Pixel} startPixel The starting pixel of the box.\n * @param {module:ol/pixel~Pixel} endPixel The end pixel of the box.\n * @return {boolean} Whether or not the boxend condition should be fired.\n * @this {module:ol/interaction/DragBox}\n */\n\n\nfunction defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n  var width = endPixel[0] - startPixel[0];\n  var height = endPixel[1] - startPixel[1];\n  return width * width + height * height >= this.minArea_;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {module:ol/interaction/DragBox}\n */\n\n\nfunction handleDragEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return;\n  }\n\n  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n  this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/DragBox}\n */\n\n\nfunction handleUpEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return true;\n  }\n\n  this.box_.setMap(null);\n\n  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {\n    this.onBoxEnd_(mapBrowserEvent);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));\n  }\n\n  return false;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/DragBox}\n */\n\n\nfunction handleDownEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return false;\n  }\n\n  if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n    this.startPixel_ = mapBrowserEvent.pixel;\n    this.box_.setMap(mapBrowserEvent.map);\n    this.box_.setPixels(this.startPixel_, this.startPixel_);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport default DragBox; //# sourceMappingURL=DragBox.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/interaction/DragBox.js"],"names":["Event","always","mouseOnly","mouseActionButton","UNDEFINED","PointerInteraction","RenderBox","DragBoxEventType","BOXSTART","BOXDRAG","BOXEND","DragBoxEvent","type","coordinate","mapBrowserEvent","call","__proto__","prototype","Object","create","constructor","DragBox","opt_options","handleDownEvent","handleDragEvent","handleUpEvent","options","box_","className","minArea_","minArea","undefined","onBoxEnd_","onBoxEnd","startPixel_","condition_","condition","boxEndCondition_","boxEndCondition","defaultBoxEndCondition","getGeometry","startPixel","endPixel","width","height","setPixels","pixel","dispatchEvent","setMap","map"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport {always, mouseOnly, mouseActionButton} from '../events/condition.js';\nimport {UNDEFINED} from '../functions.js';\nimport PointerInteraction from '../interaction/Pointer.js';\nimport RenderBox from '../render/Box.js';\n\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, module:ol/MapBrowserEvent, module:ol/pixel~Pixel, module:ol/pixel~Pixel):boolean} EndCondition\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~always}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {module:ol/interaction/DragBox~EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)} onBoxEnd Code to execute just\n * before `boxend` is fired.\n */\n\n\n/**\n * @enum {string}\n */\nvar DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend'\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\nvar DragBoxEvent = (function (Event) {\n  function DragBoxEvent(type, coordinate, mapBrowserEvent) {\n    Event.call(this, type);\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {module:ol/coordinate~Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * @const\n     * @type {module:ol/MapBrowserEvent}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n\n  }\n\n  if ( Event ) DragBoxEvent.__proto__ = Event;\n  DragBoxEvent.prototype = Object.create( Event && Event.prototype );\n  DragBoxEvent.prototype.constructor = DragBoxEvent;\n\n  return DragBoxEvent;\n}(Event));\n\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom}).\n *\n * This interaction is only supported for mouse devices.\n *\n * @fires module:ol/interaction/DragBox~DragBoxEvent\n * @api\n */\nvar DragBox = (function (PointerInteraction) {\n  function DragBox(opt_options) {\n\n    PointerInteraction.call(this, {\n      handleDownEvent: handleDownEvent,\n      handleDragEvent: handleDragEvent,\n      handleUpEvent: handleUpEvent\n    });\n\n    var options = opt_options ? opt_options : {};\n\n    /**\n    * @type {module:ol/render/Box}\n    * @private\n    */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\n    * @type {number}\n    * @private\n    */\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n\n    /**\n     * Function to execute just before `onboxend` is fired\n     * @type {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)}\n     * @private\n     */\n    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : UNDEFINED;\n\n    /**\n    * @type {module:ol/pixel~Pixel}\n    * @private\n    */\n    this.startPixel_ = null;\n\n    /**\n    * @private\n    * @type {module:ol/events/condition~Condition}\n    */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n    * @private\n    * @type {module:ol/interaction/DragBox~EndCondition}\n    */\n    this.boxEndCondition_ = options.boxEndCondition ?\n      options.boxEndCondition : defaultBoxEndCondition;\n  }\n\n  if ( PointerInteraction ) DragBox.__proto__ = PointerInteraction;\n  DragBox.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );\n  DragBox.prototype.constructor = DragBox;\n\n  /**\n  * Returns geometry of last drawn box.\n  * @return {module:ol/geom/Polygon} Geometry.\n  * @api\n  */\n  DragBox.prototype.getGeometry = function getGeometry () {\n    return this.box_.getGeometry();\n  };\n\n  return DragBox;\n}(PointerInteraction));\n\n\n/**\n * The default condition for determining whether the boxend event\n * should fire.\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\n *     leading to the box end.\n * @param {module:ol/pixel~Pixel} startPixel The starting pixel of the box.\n * @param {module:ol/pixel~Pixel} endPixel The end pixel of the box.\n * @return {boolean} Whether or not the boxend condition should be fired.\n * @this {module:ol/interaction/DragBox}\n */\nfunction defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n  var width = endPixel[0] - startPixel[0];\n  var height = endPixel[1] - startPixel[1];\n  return width * width + height * height >= this.minArea_;\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {module:ol/interaction/DragBox}\n */\nfunction handleDragEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return;\n  }\n\n  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n  this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,\n    mapBrowserEvent.coordinate, mapBrowserEvent));\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/DragBox}\n */\nfunction handleUpEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return true;\n  }\n\n  this.box_.setMap(null);\n\n  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {\n    this.onBoxEnd_(mapBrowserEvent);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,\n      mapBrowserEvent.coordinate, mapBrowserEvent));\n  }\n  return false;\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/DragBox}\n */\nfunction handleDownEvent(mapBrowserEvent) {\n  if (!mouseOnly(mapBrowserEvent)) {\n    return false;\n  }\n\n  if (mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)) {\n    this.startPixel_ = mapBrowserEvent.pixel;\n    this.box_.setMap(mapBrowserEvent.map);\n    this.box_.setPixels(this.startPixel_, this.startPixel_);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,\n      mapBrowserEvent.coordinate, mapBrowserEvent));\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\nexport default DragBox;\n\n//# sourceMappingURL=DragBox.js.map"]},"metadata":{},"sourceType":"module"}