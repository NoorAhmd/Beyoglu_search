{"ast":null,"code":"/**\n * @module ol/geom/Circle\n */\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { deflateCoordinate } from '../geom/flat/deflate.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\n\nvar Circle = function (SimpleGeometry) {\n  function Circle(center, opt_radius, opt_layout) {\n    SimpleGeometry.call(this);\n\n    if (opt_layout !== undefined && opt_radius === undefined) {\n      this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n      this.setCenterAndRadius(center, radius, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) Circle.__proto__ = SimpleGeometry;\n  Circle.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  Circle.prototype.constructor = Circle;\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!module:ol/geom/Circle} Clone.\n   * @override\n   * @api\n   */\n\n  Circle.prototype.clone = function clone() {\n    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Circle.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (var i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n\n        for (var i$1 = 2; i$1 < this.stride; ++i$1) {\n          closestPoint[i$1] = flatCoordinates[i$1];\n        }\n      }\n\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Circle.prototype.containsXY = function containsXY(x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {module:ol/coordinate~Coordinate} Center.\n   * @api\n   */\n\n\n  Circle.prototype.getCenter = function getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Circle.prototype.computeExtent = function computeExtent(extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n  };\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n\n\n  Circle.prototype.getRadius = function getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n\n\n  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_() {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Circle.prototype.getType = function getType() {\n    return GeometryType.CIRCLE;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Circle.prototype.intersectsExtent = function intersectsExtent(extent) {\n    var circleExtent = this.getExtent();\n\n    if (intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate, this);\n    }\n\n    return false;\n  };\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {module:ol/coordinate~Coordinate} center Center.\n   * @api\n   */\n\n\n  Circle.prototype.setCenter = function setCenter(center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n\n    for (var i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!module:ol/coordinate~Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n\n\n  Circle.prototype.setCenterAndRadius = function setCenterAndRadius(center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array.<number>} */\n\n\n    var flatCoordinates = this.flatCoordinates;\n    var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n\n    for (var i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n\n    flatCoordinates.length = offset;\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Circle.prototype.getCoordinates = function getCoordinates() {};\n  /**\n   * @inheritDoc\n   */\n\n\n  Circle.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {};\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n\n\n  Circle.prototype.setRadius = function setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n\n  return Circle;\n}(SimpleGeometry);\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {module:ol/geom/Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\n\n\nCircle.prototype.transform;\nexport default Circle; //# sourceMappingURL=Circle.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/geom/Circle.js"],"names":["createOrUpdate","forEachCorner","intersects","GeometryType","SimpleGeometry","deflateCoordinate","Circle","center","opt_radius","opt_layout","call","undefined","setFlatCoordinates","radius","setCenterAndRadius","__proto__","prototype","Object","create","constructor","clone","flatCoordinates","slice","layout","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","Math","sqrt","i$1","length","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","getType","CIRCLE","intersectsExtent","circleExtent","getExtent","intersectsCoordinate","setCenter","changed","setLayout","offset","ii","getCoordinates","setCoordinates","coordinates","setRadius","transform"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/Circle\n */\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {deflateCoordinate} from '../geom/flat/deflate.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = (function (SimpleGeometry) {\n  function Circle(center, opt_radius, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout !== undefined && opt_radius === undefined) {\n      this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n      this.setCenterAndRadius(center, radius, opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;\n  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Circle.prototype.constructor = Circle;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!module:ol/geom/Circle} Clone.\n   * @override\n   * @api\n   */\n  Circle.prototype.clone = function clone () {\n    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (var i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (var i$1 = 2; i$1 < this.stride; ++i$1) {\n          closestPoint[i$1] = flatCoordinates[i$1];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.containsXY = function containsXY (x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {module:ol/coordinate~Coordinate} Center.\n   * @api\n   */\n  Circle.prototype.getCenter = function getCenter () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.computeExtent = function computeExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius, flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius, flatCoordinates[1] + radius,\n      extent);\n  };\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  Circle.prototype.getRadius = function getRadius () {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.getType = function getType () {\n    return GeometryType.CIRCLE;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate, this);\n    }\n    return false;\n\n  };\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {module:ol/coordinate~Coordinate} center Center.\n   * @api\n   */\n  Circle.prototype.setCenter = function setCenter (center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (var i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!module:ol/coordinate~Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n   * @api\n   */\n  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array.<number>} */\n    var flatCoordinates = this.flatCoordinates;\n    var offset = deflateCoordinate(\n      flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (var i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.getCoordinates = function getCoordinates () {};\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  Circle.prototype.setRadius = function setRadius (radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n\n  return Circle;\n}(SimpleGeometry));\n\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {module:ol/geom/Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n\n//# sourceMappingURL=Circle.js.map"]},"metadata":{},"sourceType":"module"}