{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nimport { DEVICE_PIXEL_RATIO } from './has.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapBrowserPointerEvent from './MapBrowserPointerEvent.js';\nimport { listen, unlistenByKey } from './events.js';\nimport EventTarget from './events/EventTarget.js';\nimport PointerEventType from './pointer/EventType.js';\nimport PointerEventHandler from './pointer/PointerEventHandler.js';\n\nvar MapBrowserEventHandler = function (EventTarget) {\n  function MapBrowserEventHandler(map, moveTolerance) {\n    EventTarget.call(this);\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {module:ol/PluggableMap}\n     * @private\n     */\n\n    this.map_ = map;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.clickTimeoutId_ = 0;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.dragging_ = false;\n    /**\n     * @type {!Array.<module:ol/events~EventsKey>}\n     * @private\n     */\n\n    this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.moveTolerance_ = moveTolerance ? moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {module:ol/pointer/PointerEvent}\n     * @private\n     */\n\n    this.down_ = null;\n    var element = this.map_.getViewport();\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.activePointers_ = 0;\n    /**\n     * @type {!Object.<number, boolean>}\n     * @private\n     */\n\n    this.trackedTouches_ = {};\n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {module:ol/pointer/PointerEventHandler}\n     * @private\n     */\n\n    this.pointerEventHandler_ = new PointerEventHandler(element);\n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {module:ol/pointer/PointerEventHandler}\n     * @private\n     */\n\n    this.documentPointerEventHandler_ = null;\n    /**\n     * @type {?module:ol/events~EventsKey}\n     * @private\n     */\n\n    this.pointerdownListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n    /**\n     * @type {?module:ol/events~EventsKey}\n     * @private\n     */\n\n    this.relayedListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERMOVE, this.relayEvent_, this);\n  }\n\n  if (EventTarget) MapBrowserEventHandler.__proto__ = EventTarget;\n  MapBrowserEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_(pointerEvent) {\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    if (this.clickTimeoutId_ !== 0) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = 0;\n      newEvent = new MapBrowserPointerEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function () {\n        this.clickTimeoutId_ = 0;\n        var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_(pointerEvent) {\n    var event = pointerEvent;\n\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  };\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = pointerEvent;\n\n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ = new PointerEventHandler(document);\n      this.dragListenerKeys_.push(listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.pointerEventHandler_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n    }\n  };\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    } // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n\n\n    pointerEvent.preventDefault();\n  };\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_(pointerEvent) {\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserPointerEvent(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n\n    EventTarget.prototype.disposeInternal.call(this);\n  };\n\n  return MapBrowserEventHandler;\n}(EventTarget);\n\nexport default MapBrowserEventHandler; //# sourceMappingURL=MapBrowserEventHandler.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/MapBrowserEventHandler.js"],"names":["DEVICE_PIXEL_RATIO","MapBrowserEventType","MapBrowserPointerEvent","listen","unlistenByKey","EventTarget","PointerEventType","PointerEventHandler","MapBrowserEventHandler","map","moveTolerance","call","map_","clickTimeoutId_","dragging_","dragListenerKeys_","moveTolerance_","down_","element","getViewport","activePointers_","trackedTouches_","pointerEventHandler_","documentPointerEventHandler_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","relayedListenerKey_","POINTERMOVE","relayEvent_","__proto__","prototype","Object","create","constructor","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","bind","updateActivePointers_","event","type","POINTERUP","POINTERCANCEL","pointerId","keys","length","handlePointerUp_","propagationStopped","isMouseActionButton_","forEach","dispose","button","document","push","handlePointerMove_","isMoving_","POINTERDRAG","preventDefault","dragging","Math","abs","clientX","clientY","disposeInternal"],"mappings":"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","sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\nimport {DEVICE_PIXEL_RATIO} from './has.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapBrowserPointerEvent from './MapBrowserPointerEvent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport EventTarget from './events/EventTarget.js';\nimport PointerEventType from './pointer/EventType.js';\nimport PointerEventHandler from './pointer/PointerEventHandler.js';\n\nvar MapBrowserEventHandler = (function (EventTarget) {\n  function MapBrowserEventHandler(map, moveTolerance) {\n\n    EventTarget.call(this);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {module:ol/PluggableMap}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.clickTimeoutId_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array.<module:ol/events~EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance ?\n      moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {module:ol/pointer/PointerEvent}\n     * @private\n     */\n    this.down_ = null;\n\n    var element = this.map_.getViewport();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.activePointers_ = 0;\n\n    /**\n     * @type {!Object.<number, boolean>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {module:ol/pointer/PointerEventHandler}\n     * @private\n     */\n    this.pointerEventHandler_ = new PointerEventHandler(element);\n\n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {module:ol/pointer/PointerEventHandler}\n     * @private\n     */\n    this.documentPointerEventHandler_ = null;\n\n    /**\n     * @type {?module:ol/events~EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(this.pointerEventHandler_,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_, this);\n\n    /**\n     * @type {?module:ol/events~EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(this.pointerEventHandler_,\n      PointerEventType.POINTERMOVE,\n      this.relayEvent_, this);\n\n  }\n\n  if ( EventTarget ) MapBrowserEventHandler.__proto__ = EventTarget;\n  MapBrowserEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );\n  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_ (pointerEvent) {\n    var newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== 0) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = 0;\n      newEvent = new MapBrowserPointerEvent(\n        MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function() {\n        this.clickTimeoutId_ = 0;\n        var newEvent = new MapBrowserPointerEvent(\n          MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_ (pointerEvent) {\n    var event = pointerEvent;\n\n    if (event.type == MapBrowserEventType.POINTERUP ||\n        event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_ (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  };\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_ (pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_ (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    this.down_ = pointerEvent;\n\n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ =\n          new PointerEventHandler(document);\n\n      this.dragListenerKeys_.push(\n        listen(this.documentPointerEventHandler_,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_, this),\n        listen(this.documentPointerEventHandler_,\n          MapBrowserEventType.POINTERUP,\n          this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(this.pointerEventHandler_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_, this)\n      );\n    }\n  };\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_ (pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new MapBrowserPointerEvent(\n        MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent,\n        this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n\n    // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n    pointerEvent.preventDefault();\n  };\n\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_ (pointerEvent) {\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserPointerEvent(\n      pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n\n  /**\n   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_ (pointerEvent) {\n    return this.dragging_ ||\n        Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||\n        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal () {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n    EventTarget.prototype.disposeInternal.call(this);\n  };\n\n  return MapBrowserEventHandler;\n}(EventTarget));\n\n\nexport default MapBrowserEventHandler;\n\n//# sourceMappingURL=MapBrowserEventHandler.js.map"]},"metadata":{},"sourceType":"module"}