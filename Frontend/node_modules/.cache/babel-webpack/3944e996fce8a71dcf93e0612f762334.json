{"ast":null,"code":"/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n\n  for (var i$1 = 0; i$1 < stride; ++i$1) {\n    closestPoint[i$1] = flatCoordinates[offset + i$1];\n  }\n\n  closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = squaredDx(x1, y1, x2, y2);\n\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return max;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n\n  return max;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n\n  return max;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n\n  var i, squaredDistance;\n\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n\n  while (index < end) {\n    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n\n  return minSquaredDistance;\n} //# sourceMappingURL=closest.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/geom/flat/closest.js"],"names":["lerp","squaredDistance","squaredDx","assignClosest","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","x1","y1","dx","dy","offset","t","i","length","i$1","maxSquaredDelta","end","max","x2","y2","squaredDelta","arrayMaxSquaredDelta","ends","ii","multiArrayMaxSquaredDelta","endss","assignClosestPoint","maxDelta","isRing","minSquaredDistance","opt_tmpPoint","tmpPoint","NaN","index","Math","sqrt","assignClosestArrayPoint","assignClosestMultiArrayPoint"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (var i$1 = 0; i$1 < stride; ++i$1) {\n    closestPoint[i$1] = flatCoordinates[offset + i$1];\n  }\n  closestPoint.length = stride;\n}\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(\n      flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(\n      flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n        ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates, offset, end, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates, offset, ends, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n\n//# sourceMappingURL=closest.js.map"]},"metadata":{},"sourceType":"module"}