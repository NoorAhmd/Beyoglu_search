{"ast":null,"code":"/**\n * @module ol/PluggableMap\n */\nimport { getUid } from './util.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport BaseObject, { getChangeEventType } from './Object.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport TileQueue from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { assert } from './asserts.js';\nimport { removeNode } from './dom.js';\nimport { listen, unlistenByKey, unlisten } from './events.js';\nimport { stopPropagation } from './events/Event.js';\nimport EventType from './events/EventType.js';\nimport { createEmpty, clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty } from './extent.js';\nimport { TRUE } from './functions.js';\nimport { DEVICE_PIXEL_RATIO, TOUCH } from './has.js';\nimport LayerGroup from './layer/Group.js';\nimport { hasArea } from './size.js';\nimport { DROP } from './structs/PriorityQueue.js';\nimport { create as createTransform, apply as applyTransform } from './transform.js';\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {module:ol/View~State} viewState The state of the current view.\n * @property {boolean} animate\n * @property {module:ol/transform~Transform} coordinateToPixelTransform\n * @property {null|module:ol/extent~Extent} extent\n * @property {module:ol/coordinate~Coordinate} focus\n * @property {number} index\n * @property {Object.<number, module:ol/layer/Layer~State>} layerStates\n * @property {Array.<module:ol/layer/Layer~State>} layerStatesArray\n * @property {module:ol/transform~Transform} pixelToCoordinateTransform\n * @property {Array.<module:ol/PluggableMap~PostRenderFunction>} postRenderFunctions\n * @property {module:ol/size~Size} size\n * @property {!Object.<string, boolean>} skippedFeatureUids\n * @property {module:ol/TileQueue} tileQueue\n * @property {Object.<string, Object.<string, module:ol/TileRange>>} usedTiles\n * @property {Array.<number>} viewHints\n * @property {!Object.<string, Object.<string, boolean>>} wantedTiles\n */\n\n/**\n * @typedef {function(module:ol/PluggableMap, ?module:ol/PluggableMap~FrameState): boolean} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {((function(module:ol/layer/Layer): boolean)|undefined)} layerFilter Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n * inside the radius around the given position will be checked for features. This only\n * works for the canvas renderer and not for WebGL.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {module:ol/Collection.<module:ol/control/Control>} [controls]\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>} [interactions]\n * @property {HTMLElement|Document} keyboardEventTarget\n * @property {module:ol/Collection.<module:ol/Overlay>} overlays\n * @property {Object.<string, *>} values\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {module:ol/Collection.<module:ol/control/Control>|Array.<module:ol/control/Control>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control/util~defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>|Array.<module:ol/interaction/Interaction>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction~defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n * will be loaded during animations. This may improve the user experience, but\n * can also make animations stutter on devices with slow memory.\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n * tiles will be loaded while interacting with the map. This may improve the\n * user experience, but can also make map panning and zooming choppy on devices\n * with slow memory.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {module:ol/Collection.<module:ol/Overlay>|Array.<module:ol/Overlay>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered.\n * @property {module:ol/View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @fires module:ol/MapBrowserEvent~MapBrowserEvent\n * @fires module:ol/MapEvent~MapEvent\n * @fires module:ol/render/Event~RenderEvent#postcompose\n * @fires module:ol/render/Event~RenderEvent#precompose\n * @api\n */\n\nvar PluggableMap = function (BaseObject) {\n  function PluggableMap(options) {\n    var this$1 = this;\n    BaseObject.call(this);\n    var optionsInternal = createOptionsInternal(options);\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.animationDelayKey_;\n    /**\n     * @private\n     */\n\n    this.animationDelay_ = function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n\n\n    this.coordinateToPixelTransform_ = createTransform();\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n\n    this.pixelToCoordinateTransform_ = createTransform();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.frameIndex_ = 0;\n    /**\n     * @private\n     * @type {?module:ol/PluggableMap~FrameState}\n     */\n\n    this.frameState_ = null;\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.previousExtent_ = null;\n    /**\n     * @private\n     * @type {?module:ol/events~EventsKey}\n     */\n\n    this.viewPropertyListenerKey_ = null;\n    /**\n     * @private\n     * @type {?module:ol/events~EventsKey}\n     */\n\n    this.viewChangeListenerKey_ = null;\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n\n    this.layerGroupPropertyListenerKeys_ = null;\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.viewport_ = document.createElement('DIV');\n    this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%'; // prevent page zoom on IE >= 10 browsers\n\n    this.viewport_.style.msTouchAction = 'none';\n    this.viewport_.style.touchAction = 'none';\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.overlayContainer_ = document.createElement('DIV');\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.overlayContainerStopEvent_ = document.createElement('DIV');\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    var overlayEvents = [EventType.CLICK, EventType.DBLCLICK, EventType.MOUSEDOWN, EventType.TOUCHSTART, EventType.MSPOINTERDOWN, MapBrowserEventType.POINTERDOWN, EventType.MOUSEWHEEL, EventType.WHEEL];\n\n    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      listen(this$1.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\n    }\n\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n    /**\n     * @private\n     * @type {module:ol/MapBrowserEventHandler}\n     */\n\n    this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\n\n    for (var key in MapBrowserEventType) {\n      listen(this$1.mapBrowserEventHandler_, MapBrowserEventType[key], this$1.handleMapBrowserEvent, this$1);\n    }\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n\n\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n\n    this.keyHandlerKeys_ = null;\n    listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n    /**\n     * @type {module:ol/Collection.<module:ol/control/Control>}\n     * @protected\n     */\n\n    this.controls = optionsInternal.controls || new Collection();\n    /**\n     * @type {module:ol/Collection.<module:ol/interaction/Interaction>}\n     * @protected\n     */\n\n    this.interactions = optionsInternal.interactions || new Collection();\n    /**\n     * @type {module:ol/Collection.<module:ol/Overlay>}\n     * @private\n     */\n\n    this.overlays_ = optionsInternal.overlays;\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object.<string, module:ol/Overlay>}\n     */\n\n    this.overlayIdIndex_ = {};\n    /**\n     * @type {module:ol/renderer/Map}\n     * @private\n     */\n\n    this.renderer_ = this.createRenderer();\n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n\n    this.handleResize_;\n    /**\n     * @private\n     * @type {module:ol/coordinate~Coordinate}\n     */\n\n    this.focus_ = null;\n    /**\n     * @private\n     * @type {!Array.<module:ol/PluggableMap~PostRenderFunction>}\n     */\n\n    this.postRenderFunctions_ = [];\n    /**\n     * @private\n     * @type {module:ol/TileQueue}\n     */\n\n    this.tileQueue_ = new TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));\n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n\n    this.skippedFeatureUids_ = {};\n    listen(this, getChangeEventType(MapProperty.LAYERGROUP), this.handleLayerGroupChanged_, this);\n    listen(this, getChangeEventType(MapProperty.VIEW), this.handleViewChanged_, this);\n    listen(this, getChangeEventType(MapProperty.SIZE), this.handleSizeChanged_, this);\n    listen(this, getChangeEventType(MapProperty.TARGET), this.handleTargetChanged_, this); // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n\n    this.setProperties(optionsInternal.values);\n    this.controls.forEach(\n    /**\n     * @param {module:ol/control/Control} control Control.\n     * @this {module:ol/PluggableMap}\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(this));\n    listen(this.controls, CollectionEventType.ADD,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    listen(this.controls, CollectionEventType.REMOVE,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.interactions.forEach(\n    /**\n     * @param {module:ol/interaction/Interaction} interaction Interaction.\n     * @this {module:ol/PluggableMap}\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(this));\n    listen(this.interactions, CollectionEventType.ADD,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    listen(this.interactions, CollectionEventType.REMOVE,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n    listen(this.overlays_, CollectionEventType.ADD,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      this.addOverlayInternal_(\n      /** @type {module:ol/Overlay} */\n      event.element);\n    }, this);\n    listen(this.overlays_, CollectionEventType.REMOVE,\n    /**\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      var overlay =\n      /** @type {module:ol/Overlay} */\n      event.element;\n      var id = overlay.getId();\n\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n\n      event.element.setMap(null);\n    }, this);\n  }\n\n  if (BaseObject) PluggableMap.__proto__ = BaseObject;\n  PluggableMap.prototype = Object.create(BaseObject && BaseObject.prototype);\n  PluggableMap.prototype.constructor = PluggableMap;\n\n  PluggableMap.prototype.createRenderer = function createRenderer() {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n  /**\n   * Add the given control to the map.\n   * @param {module:ol/control/Control} control Control.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addControl = function addControl(control) {\n    this.getControls().push(control);\n  };\n  /**\n   * Add the given interaction to the map.\n   * @param {module:ol/interaction/Interaction} interaction Interaction to add.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addInteraction = function addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  };\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {module:ol/layer/Base} layer Layer.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addLayer = function addLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  /**\n   * Add the given overlay to the map.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addOverlay = function addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  };\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @private\n   */\n\n\n  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_(overlay) {\n    var id = overlay.getId();\n\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n\n    overlay.setMap(this);\n  };\n  /**\n   *\n   * @inheritDoc\n   */\n\n\n  PluggableMap.prototype.disposeInternal = function disposeInternal() {\n    this.mapBrowserEventHandler_.dispose();\n    unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n\n    this.setTarget(null);\n    BaseObject.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),\n   *     module:ol/layer/Layer): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {Array.<module:ol/Feature|module:ol/render/Feature>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel(pixel, opt_options) {\n    var features = null;\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      if (!features) {\n        features = [];\n      }\n\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n\n\n  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel(pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  };\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {module:ol/coordinate~Coordinate} Coordinate.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event} event Event.\n   * @return {module:ol/pixel~Pixel} Pixel.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventPixel = function getEventPixel(event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = event.changedTouches ? event.changedTouches[0] : event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTarget = function getTarget() {\n    return (\n      /** @type {HTMLElement|string|undefined} */\n      this.get(MapProperty.TARGET)\n    );\n  };\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTargetElement = function getTargetElement() {\n    var target = this.getTarget();\n\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {module:ol/pixel~Pixel} pixel Pixel position in the map viewport.\n   * @return {module:ol/coordinate~Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel(pixel) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {module:ol/Collection.<module:ol/control/Control>} Controls.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getControls = function getControls() {\n    return this.controls;\n  };\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {module:ol/Collection.<module:ol/Overlay>} Overlays.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlays = function getOverlays() {\n    return this.overlays_;\n  };\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {module:ol/Overlay} Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlayById = function getOverlayById(id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {module:ol/Collection.<module:ol/interaction/Interaction>} Interactions.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getInteractions = function getInteractions() {\n    return this.interactions;\n  };\n  /**\n   * Get the layergroup associated with this map.\n   * @return {module:ol/layer/Group} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayerGroup = function getLayerGroup() {\n    return (\n      /** @type {module:ol/layer/Group} */\n      this.get(MapProperty.LAYERGROUP)\n    );\n  };\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!module:ol/Collection.<module:ol/layer/Base>} Layers.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayers = function getLayers() {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {module:ol/coordinate~Coordinate} coordinate A map coordinate.\n   * @return {module:ol/pixel~Pixel} A pixel position in the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate(coordinate) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  /**\n   * Get the map renderer.\n   * @return {module:ol/renderer/Map} Renderer\n   */\n\n\n  PluggableMap.prototype.getRenderer = function getRenderer() {\n    return this.renderer_;\n  };\n  /**\n   * Get the size of this map.\n   * @return {module:ol/size~Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getSize = function getSize() {\n    return (\n      /** @type {module:ol/size~Size|undefined} */\n      this.get(MapProperty.SIZE)\n    );\n  };\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {module:ol/View} The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getView = function getView() {\n    return (\n      /** @type {module:ol/View} */\n      this.get(MapProperty.VIEW)\n    );\n  };\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getViewport = function getViewport() {\n    return this.viewport_;\n  };\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer() {\n    return this.overlayContainer_;\n  };\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  };\n  /**\n   * @param {module:ol/Tile} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {module:ol/coordinate~Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n\n\n  PluggableMap.prototype.getTilePriority = function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    } // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n\n\n    var deltaX = tileCenter[0] - frameState.focus[0];\n    var deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n\n\n  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent(browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  /**\n   * @param {module:ol/MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n\n\n  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n\n        if (!interaction.getActive()) {\n          continue;\n        }\n\n        var cont = interaction.handleEvent(mapBrowserEvent);\n\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  PluggableMap.prototype.handlePostRender = function handlePostRender() {\n    var this$1 = this;\n    var frameState = this.frameState_; // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n\n    var tileQueue = this.tileQueue_;\n\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n\n      if (frameState) {\n        var hints = frameState.viewHints;\n\n        if (hints[ViewHint.ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n\n        if (hints[ViewHint.INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this$1, frameState);\n    }\n\n    postRenderFunctions.length = 0;\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_() {\n    var this$1 = this; // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    var targetElement;\n\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this$1.keyHandlerKeys_[i]);\n      }\n\n      this.keyHandlerKeys_ = null;\n    }\n\n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      removeNode(this.viewport_);\n\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize(); // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTileChange_ = function handleTileChange_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n\n    var view = this.getView();\n\n    if (view) {\n      this.viewport_.setAttribute('data-view', getUid(view));\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n\n    var layerGroup = this.getLayerGroup();\n\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n    }\n\n    this.render();\n  };\n  /**\n   * @return {boolean} Is rendered.\n   */\n\n\n  PluggableMap.prototype.isRendered = function isRendered() {\n    return !!this.frameState_;\n  };\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n\n\n  PluggableMap.prototype.renderSync = function renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n\n    this.animationDelay_();\n  };\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n\n\n  PluggableMap.prototype.render = function render() {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  /**\n   * Remove the given control from the map.\n   * @param {module:ol/control/Control} control Control.\n   * @return {module:ol/control/Control|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeControl = function removeControl(control) {\n    return this.getControls().remove(control);\n  };\n  /**\n   * Remove the given interaction from the map.\n   * @param {module:ol/interaction/Interaction} interaction Interaction to remove.\n   * @return {module:ol/interaction/Interaction|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeInteraction = function removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  /**\n   * Removes the given layer from the map.\n   * @param {module:ol/layer/Base} layer Layer.\n   * @return {module:ol/layer/Base|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeLayer = function removeLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  /**\n   * Remove the given overlay from the map.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @return {module:ol/Overlay|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeOverlay = function removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n\n\n  PluggableMap.prototype.renderFrame_ = function renderFrame_(time) {\n    var viewState;\n    var size = this.getSize();\n    var view = this.getView();\n    var extent = createEmpty();\n    var previousFrameState = this.frameState_;\n    /** @type {?module:ol/PluggableMap~FrameState} */\n\n    var frameState = null;\n\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      var layerStates = {};\n\n      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n\n      viewState = view.getState();\n      var focus = this.focus_;\n\n      if (!focus) {\n        focus = viewState.center;\n        var pixelResolution = viewState.resolution / this.pixelRatio_;\n        focus[0] = Math.round(focus[0] / pixelResolution) * pixelResolution;\n        focus[1] = Math.round(focus[1] / pixelResolution) * pixelResolution;\n      }\n\n      frameState =\n      /** @type {module:ol/PluggableMap~FrameState} */\n      {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: focus,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n    }\n\n    if (frameState) {\n      frameState.extent = getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);\n\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n    setTimeout(this.handlePostRender.bind(this), 0);\n  };\n  /**\n   * Sets the layergroup of this map.\n   * @param {module:ol/layer/Group} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setLayerGroup = function setLayerGroup(layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  /**\n   * Set the size of this map.\n   * @param {module:ol/size~Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setSize = function setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setTarget = function setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  /**\n   * Set the view for this map.\n   * @param {module:ol/View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setView = function setView(view) {\n    this.set(MapProperty.VIEW, view);\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   */\n\n\n  PluggableMap.prototype.skipFeature = function skipFeature(feature) {\n    var featureUid = getUid(feature).toString();\n    this.skippedFeatureUids_[featureUid] = true;\n    this.render();\n  };\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.updateSize = function updateSize() {\n    var targetElement = this.getTargetElement();\n\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);\n    }\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   */\n\n\n  PluggableMap.prototype.unskipFeature = function unskipFeature(feature) {\n    var featureUid = getUid(feature).toString();\n    delete this.skippedFeatureUids_[featureUid];\n    this.render();\n  };\n\n  return PluggableMap;\n}(BaseObject);\n/**\n * @param {MapOptions} options Map options.\n * @return {module:ol/PluggableMap~MapOptionsInternal} Internal map options.\n */\n\n\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  /**\n   * @type {Object.<string, *>}\n   */\n\n\n  var values = {};\n  var layerGroup = options.layers instanceof LayerGroup ? options.layers : new LayerGroup({\n    layers: options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View();\n  var controls;\n\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(options.controls instanceof Collection, 47); // Expected `controls` to be an array or an `module:ol/Collection~Collection`\n\n      controls = options.controls;\n    }\n  }\n\n  var interactions;\n\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(options.interactions instanceof Collection, 48); // Expected `interactions` to be an array or an `module:ol/Collection~Collection`\n\n      interactions = options.interactions;\n    }\n  }\n\n  var overlays;\n\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(options.overlays instanceof Collection, 49); // Expected `overlays` to be an array or an `module:ol/Collection~Collection`\n\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\n\nexport default PluggableMap; //# sourceMappingURL=PluggableMap.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/PluggableMap.js"],"names":["getUid","Collection","CollectionEventType","MapBrowserEvent","MapBrowserEventHandler","MapBrowserEventType","MapEvent","MapEventType","MapProperty","BaseObject","getChangeEventType","ObjectEventType","TileQueue","View","ViewHint","assert","removeNode","listen","unlistenByKey","unlisten","stopPropagation","EventType","createEmpty","clone","createOrUpdateEmpty","equals","getForViewAndSize","isEmpty","TRUE","DEVICE_PIXEL_RATIO","TOUCH","LayerGroup","hasArea","DROP","create","createTransform","apply","applyTransform","PluggableMap","options","this$1","call","optionsInternal","createOptionsInternal","maxTilesLoading_","maxTilesLoading","undefined","loadTilesWhileAnimating_","loadTilesWhileAnimating","loadTilesWhileInteracting_","loadTilesWhileInteracting","pixelRatio_","pixelRatio","animationDelayKey_","animationDelay_","renderFrame_","Date","now","bind","coordinateToPixelTransform_","pixelToCoordinateTransform_","frameIndex_","frameState_","previousExtent_","viewPropertyListenerKey_","viewChangeListenerKey_","layerGroupPropertyListenerKeys_","viewport_","document","createElement","className","style","position","overflow","width","height","msTouchAction","touchAction","overlayContainer_","appendChild","overlayContainerStopEvent_","overlayEvents","CLICK","DBLCLICK","MOUSEDOWN","TOUCHSTART","MSPOINTERDOWN","POINTERDOWN","MOUSEWHEEL","WHEEL","i","ii","length","mapBrowserEventHandler_","moveTolerance","key","handleMapBrowserEvent","keyboardEventTarget_","keyboardEventTarget","keyHandlerKeys_","CONTEXTMENU","handleBrowserEvent","controls","interactions","overlays_","overlays","overlayIdIndex_","renderer_","createRenderer","handleResize_","focus_","postRenderFunctions_","tileQueue_","getTilePriority","handleTileChange_","skippedFeatureUids_","LAYERGROUP","handleLayerGroupChanged_","VIEW","handleViewChanged_","SIZE","handleSizeChanged_","TARGET","handleTargetChanged_","setProperties","values","forEach","control","setMap","ADD","event","element","REMOVE","interaction","addOverlayInternal_","overlay","id","getId","toString","__proto__","prototype","Object","constructor","Error","addControl","getControls","push","addInteraction","getInteractions","addLayer","layer","layers","getLayerGroup","getLayers","addOverlay","getOverlays","disposeInternal","dispose","removeEventListener","RESIZE","cancelAnimationFrame","setTarget","forEachFeatureAtPixel","pixel","callback","opt_options","coordinate","getCoordinateFromPixel","hitTolerance","layerFilter","forEachFeatureAtCoordinate","getFeaturesAtPixel","features","feature","forEachLayerAtPixel","hasFeatureAtPixel","hasFeatureAtCoordinate","getEventCoordinate","getEventPixel","viewportPosition","getBoundingClientRect","eventPosition","changedTouches","clientX","left","clientY","top","getTarget","get","getTargetElement","target","getElementById","frameState","pixelToCoordinateTransform","slice","getOverlayById","getPixelFromCoordinate","coordinateToPixelTransform","getRenderer","getSize","getView","getViewport","getOverlayContainer","getOverlayContainerStopEvent","tile","tileSourceKey","tileCenter","tileResolution","wantedTiles","getKey","deltaX","focus","deltaY","Math","log","sqrt","browserEvent","opt_type","type","mapBrowserEvent","interactionsArray","getArray","dispatchEvent","getActive","cont","handleEvent","handlePostRender","tileQueue","maxTotalLoading","maxNewLoads","hints","viewHints","ANIMATING","INTERACTING","getTilesLoading","reprioritize","loadMoreTiles","postRenderFunctions","render","targetElement","removeLayerRenderers","KEYDOWN","KEYPRESS","updateSize","addEventListener","handleViewPropertyChanged_","view","setAttribute","PROPERTYCHANGE","CHANGE","layerGroup","isRendered","renderSync","requestAnimationFrame","removeControl","remove","removeInteraction","removeLayer","removeOverlay","time","viewState","size","extent","previousFrameState","isDef","getHints","layerStatesArray","getLayerStatesArray","layerStates","getState","center","pixelResolution","resolution","round","animate","index","skippedFeatureUids","usedTiles","rotation","renderFrame","Array","moveStart","MOVESTART","idle","MOVEEND","POSTRENDER","setTimeout","setLayerGroup","set","setSize","setView","skipFeature","featureUid","computedStyle","getComputedStyle","offsetWidth","parseFloat","offsetHeight","unskipFeature","isArray"],"mappings":"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","sourcesContent":["/**\n * @module ol/PluggableMap\n */\nimport {getUid} from './util.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport BaseObject, {getChangeEventType} from './Object.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport TileQueue from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport {assert} from './asserts.js';\nimport {removeNode} from './dom.js';\nimport {listen, unlistenByKey, unlisten} from './events.js';\nimport {stopPropagation} from './events/Event.js';\nimport EventType from './events/EventType.js';\nimport {createEmpty, clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty} from './extent.js';\nimport {TRUE} from './functions.js';\nimport {DEVICE_PIXEL_RATIO, TOUCH} from './has.js';\nimport LayerGroup from './layer/Group.js';\nimport {hasArea} from './size.js';\nimport {DROP} from './structs/PriorityQueue.js';\nimport {create as createTransform, apply as applyTransform} from './transform.js';\n\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {module:ol/View~State} viewState The state of the current view.\n * @property {boolean} animate\n * @property {module:ol/transform~Transform} coordinateToPixelTransform\n * @property {null|module:ol/extent~Extent} extent\n * @property {module:ol/coordinate~Coordinate} focus\n * @property {number} index\n * @property {Object.<number, module:ol/layer/Layer~State>} layerStates\n * @property {Array.<module:ol/layer/Layer~State>} layerStatesArray\n * @property {module:ol/transform~Transform} pixelToCoordinateTransform\n * @property {Array.<module:ol/PluggableMap~PostRenderFunction>} postRenderFunctions\n * @property {module:ol/size~Size} size\n * @property {!Object.<string, boolean>} skippedFeatureUids\n * @property {module:ol/TileQueue} tileQueue\n * @property {Object.<string, Object.<string, module:ol/TileRange>>} usedTiles\n * @property {Array.<number>} viewHints\n * @property {!Object.<string, Object.<string, boolean>>} wantedTiles\n */\n\n\n/**\n * @typedef {function(module:ol/PluggableMap, ?module:ol/PluggableMap~FrameState): boolean} PostRenderFunction\n */\n\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {((function(module:ol/layer/Layer): boolean)|undefined)} layerFilter Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n * inside the radius around the given position will be checked for features. This only\n * works for the canvas renderer and not for WebGL.\n */\n\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {module:ol/Collection.<module:ol/control/Control>} [controls]\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>} [interactions]\n * @property {HTMLElement|Document} keyboardEventTarget\n * @property {module:ol/Collection.<module:ol/Overlay>} overlays\n * @property {Object.<string, *>} values\n */\n\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {module:ol/Collection.<module:ol/control/Control>|Array.<module:ol/control/Control>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control/util~defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>|Array.<module:ol/interaction/Interaction>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction~defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n * will be loaded during animations. This may improve the user experience, but\n * can also make animations stutter on devices with slow memory.\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n * tiles will be loaded while interacting with the map. This may improve the\n * user experience, but can also make map panning and zooming choppy on devices\n * with slow memory.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {module:ol/Collection.<module:ol/Overlay>|Array.<module:ol/Overlay>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered.\n * @property {module:ol/View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n\n/**\n * @fires module:ol/MapBrowserEvent~MapBrowserEvent\n * @fires module:ol/MapEvent~MapEvent\n * @fires module:ol/render/Event~RenderEvent#postcompose\n * @fires module:ol/render/Event~RenderEvent#precompose\n * @api\n */\nvar PluggableMap = (function (BaseObject) {\n  function PluggableMap(options) {\n    var this$1 = this;\n\n\n    BaseObject.call(this);\n\n    var optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileAnimating_ =\n        options.loadTilesWhileAnimating !== undefined ?\n          options.loadTilesWhileAnimating : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileInteracting_ =\n        options.loadTilesWhileInteracting !== undefined ?\n          options.loadTilesWhileInteracting : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio !== undefined ?\n      options.pixelRatio : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    this.animationDelay_ = function() {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?module:ol/PluggableMap~FrameState}\n     */\n    this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n    this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?module:ol/events~EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?module:ol/events~EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.viewport_ = document.createElement('DIV');\n    this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n    // prevent page zoom on IE >= 10 browsers\n    this.viewport_.style.msTouchAction = 'none';\n    this.viewport_.style.touchAction = 'none';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainer_ = document.createElement('DIV');\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('DIV');\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    var overlayEvents = [\n      EventType.CLICK,\n      EventType.DBLCLICK,\n      EventType.MOUSEDOWN,\n      EventType.TOUCHSTART,\n      EventType.MSPOINTERDOWN,\n      MapBrowserEventType.POINTERDOWN,\n      EventType.MOUSEWHEEL,\n      EventType.WHEEL\n    ];\n    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      listen(this$1.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\n    }\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {module:ol/MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\n    for (var key in MapBrowserEventType) {\n      listen(this$1.mapBrowserEventHandler_, MapBrowserEventType[key],\n        this$1.handleMapBrowserEvent, this$1);\n    }\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n    this.keyHandlerKeys_ = null;\n\n    listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n\n    /**\n     * @type {module:ol/Collection.<module:ol/control/Control>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || new Collection();\n\n    /**\n     * @type {module:ol/Collection.<module:ol/interaction/Interaction>}\n     * @protected\n     */\n    this.interactions = optionsInternal.interactions || new Collection();\n\n    /**\n     * @type {module:ol/Collection.<module:ol/Overlay>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object.<string, module:ol/Overlay>}\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\n     * @type {module:ol/renderer/Map}\n     * @private\n     */\n    this.renderer_ = this.createRenderer();\n\n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n    this.handleResize_;\n\n    /**\n     * @private\n     * @type {module:ol/coordinate~Coordinate}\n     */\n    this.focus_ = null;\n\n    /**\n     * @private\n     * @type {!Array.<module:ol/PluggableMap~PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {module:ol/TileQueue}\n     */\n    this.tileQueue_ = new TileQueue(\n      this.getTilePriority.bind(this),\n      this.handleTileChange_.bind(this));\n\n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object.<string, boolean>}\n     * @private\n     */\n    this.skippedFeatureUids_ = {};\n\n    listen(\n      this, getChangeEventType(MapProperty.LAYERGROUP),\n      this.handleLayerGroupChanged_, this);\n    listen(this, getChangeEventType(MapProperty.VIEW),\n      this.handleViewChanged_, this);\n    listen(this, getChangeEventType(MapProperty.SIZE),\n      this.handleSizeChanged_, this);\n    listen(this, getChangeEventType(MapProperty.TARGET),\n      this.handleTargetChanged_, this);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n\n    this.controls.forEach(\n      /**\n       * @param {module:ol/control/Control} control Control.\n       * @this {module:ol/PluggableMap}\n       */\n      (function(control) {\n        control.setMap(this);\n      }).bind(this));\n\n    listen(this.controls, CollectionEventType.ADD,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(this);\n      }, this);\n\n    listen(this.controls, CollectionEventType.REMOVE,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(null);\n      }, this);\n\n    this.interactions.forEach(\n      /**\n       * @param {module:ol/interaction/Interaction} interaction Interaction.\n       * @this {module:ol/PluggableMap}\n       */\n      (function(interaction) {\n        interaction.setMap(this);\n      }).bind(this));\n\n    listen(this.interactions, CollectionEventType.ADD,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(this);\n      }, this);\n\n    listen(this.interactions, CollectionEventType.REMOVE,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(null);\n      }, this);\n\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n\n    listen(this.overlays_, CollectionEventType.ADD,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        this.addOverlayInternal_(/** @type {module:ol/Overlay} */ (event.element));\n      }, this);\n\n    listen(this.overlays_, CollectionEventType.REMOVE,\n      /**\n       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        var overlay = /** @type {module:ol/Overlay} */ (event.element);\n        var id = overlay.getId();\n        if (id !== undefined) {\n          delete this.overlayIdIndex_[id.toString()];\n        }\n        event.element.setMap(null);\n      }, this);\n\n  }\n\n  if ( BaseObject ) PluggableMap.__proto__ = BaseObject;\n  PluggableMap.prototype = Object.create( BaseObject && BaseObject.prototype );\n  PluggableMap.prototype.constructor = PluggableMap;\n\n  PluggableMap.prototype.createRenderer = function createRenderer () {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n\n  /**\n   * Add the given control to the map.\n   * @param {module:ol/control/Control} control Control.\n   * @api\n   */\n  PluggableMap.prototype.addControl = function addControl (control) {\n    this.getControls().push(control);\n  };\n\n  /**\n   * Add the given interaction to the map.\n   * @param {module:ol/interaction/Interaction} interaction Interaction to add.\n   * @api\n   */\n  PluggableMap.prototype.addInteraction = function addInteraction (interaction) {\n    this.getInteractions().push(interaction);\n  };\n\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {module:ol/layer/Base} layer Layer.\n   * @api\n   */\n  PluggableMap.prototype.addLayer = function addLayer (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n\n  /**\n   * Add the given overlay to the map.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @api\n   */\n  PluggableMap.prototype.addOverlay = function addOverlay (overlay) {\n    this.getOverlays().push(overlay);\n  };\n\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @private\n   */\n  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_ (overlay) {\n    var id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  };\n\n  /**\n   *\n   * @inheritDoc\n   */\n  PluggableMap.prototype.disposeInternal = function disposeInternal () {\n    this.mapBrowserEventHandler_.dispose();\n    unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n    this.setTarget(null);\n    BaseObject.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),\n   *     module:ol/layer/Layer): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ?\n      opt_options.layerFilter : TRUE;\n    return this.renderer_.forEachFeatureAtCoordinate(\n      coordinate, this.frameState_, hitTolerance, callback, null,\n      layerFilter, null);\n  };\n\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {Array.<module:ol/Feature|module:ol/render/Feature>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel (pixel, opt_options) {\n    var features = null;\n    this.forEachFeatureAtPixel(pixel, function(feature) {\n      if (!features) {\n        features = [];\n      }\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(\n      pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {module:ol/pixel~Pixel} pixel Pixel.\n   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel (pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(\n      coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  };\n\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {module:ol/coordinate~Coordinate} Coordinate.\n   * @api\n   */\n  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate (event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event} event Event.\n   * @return {module:ol/pixel~Pixel} Pixel.\n   * @api\n   */\n  PluggableMap.prototype.getEventPixel = function getEventPixel (event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = event.changedTouches ? event.changedTouches[0] : event;\n    return [\n      eventPosition.clientX - viewportPosition.left,\n      eventPosition.clientY - viewportPosition.top\n    ];\n  };\n\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getTarget = function getTarget () {\n    return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));\n  };\n\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n  PluggableMap.prototype.getTargetElement = function getTargetElement () {\n    var target = this.getTarget();\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {module:ol/pixel~Pixel} pixel Pixel position in the map viewport.\n   * @return {module:ol/coordinate~Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel (pixel) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {module:ol/Collection.<module:ol/control/Control>} Controls.\n   * @api\n   */\n  PluggableMap.prototype.getControls = function getControls () {\n    return this.controls;\n  };\n\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {module:ol/Collection.<module:ol/Overlay>} Overlays.\n   * @api\n   */\n  PluggableMap.prototype.getOverlays = function getOverlays () {\n    return this.overlays_;\n  };\n\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {module:ol/Overlay} Overlay.\n   * @api\n   */\n  PluggableMap.prototype.getOverlayById = function getOverlayById (id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {module:ol/Collection.<module:ol/interaction/Interaction>} Interactions.\n   * @api\n   */\n  PluggableMap.prototype.getInteractions = function getInteractions () {\n    return this.interactions;\n  };\n\n  /**\n   * Get the layergroup associated with this map.\n   * @return {module:ol/layer/Group} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getLayerGroup = function getLayerGroup () {\n    return (\n      /** @type {module:ol/layer/Group} */ (this.get(MapProperty.LAYERGROUP))\n    );\n  };\n\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!module:ol/Collection.<module:ol/layer/Base>} Layers.\n   * @api\n   */\n  PluggableMap.prototype.getLayers = function getLayers () {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {module:ol/coordinate~Coordinate} coordinate A map coordinate.\n   * @return {module:ol/pixel~Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate (coordinate) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n\n  /**\n   * Get the map renderer.\n   * @return {module:ol/renderer/Map} Renderer\n   */\n  PluggableMap.prototype.getRenderer = function getRenderer () {\n    return this.renderer_;\n  };\n\n  /**\n   * Get the size of this map.\n   * @return {module:ol/size~Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getSize = function getSize () {\n    return (\n      /** @type {module:ol/size~Size|undefined} */ (this.get(MapProperty.SIZE))\n    );\n  };\n\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {module:ol/View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getView = function getView () {\n    return (\n      /** @type {module:ol/View} */ (this.get(MapProperty.VIEW))\n    );\n  };\n\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n  PluggableMap.prototype.getViewport = function getViewport () {\n    return this.viewport_;\n  };\n\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer () {\n    return this.overlayContainer_;\n  };\n\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent () {\n    return this.overlayContainerStopEvent_;\n  };\n\n  /**\n   * @param {module:ol/Tile} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {module:ol/coordinate~Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  PluggableMap.prototype.getTilePriority = function getTilePriority (tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    }\n    // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n    var deltaX = tileCenter[0] - frameState.focus[0];\n    var deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) +\n        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n\n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent (browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n\n  /**\n   * @param {module:ol/MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent (mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n        if (!interaction.getActive()) {\n          continue;\n        }\n        var cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n\n  /**\n   * @protected\n   */\n  PluggableMap.prototype.handlePostRender = function handlePostRender () {\n    var this$1 = this;\n\n\n    var frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    var tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        var hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n        if (hints[ViewHint.INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this$1, frameState);\n    }\n    postRenderFunctions.length = 0;\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_ () {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_ () {\n    var this$1 = this;\n\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    var targetElement;\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this$1.keyHandlerKeys_[i]);\n      }\n      this.keyHandlerKeys_ = null;\n    }\n\n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      removeNode(this.viewport_);\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n\n      var keyboardEventTarget = !this.keyboardEventTarget_ ?\n        targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [\n        listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\n        listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)\n      ];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleTileChange_ = function handleTileChange_ () {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_ () {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_ () {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    var view = this.getView();\n    if (view) {\n      this.viewport_.setAttribute('data-view', getUid(view));\n      this.viewPropertyListenerKey_ = listen(\n        view, ObjectEventType.PROPERTYCHANGE,\n        this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(\n        view, EventType.CHANGE,\n        this.handleViewPropertyChanged_, this);\n    }\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_ () {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    var layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [\n        listen(\n          layerGroup, ObjectEventType.PROPERTYCHANGE,\n          this.render, this),\n        listen(\n          layerGroup, EventType.CHANGE,\n          this.render, this)\n      ];\n    }\n    this.render();\n  };\n\n  /**\n   * @return {boolean} Is rendered.\n   */\n  PluggableMap.prototype.isRendered = function isRendered () {\n    return !!this.frameState_;\n  };\n\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  PluggableMap.prototype.renderSync = function renderSync () {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  };\n\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  PluggableMap.prototype.render = function render () {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n\n  /**\n   * Remove the given control from the map.\n   * @param {module:ol/control/Control} control Control.\n   * @return {module:ol/control/Control|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeControl = function removeControl (control) {\n    return this.getControls().remove(control);\n  };\n\n  /**\n   * Remove the given interaction from the map.\n   * @param {module:ol/interaction/Interaction} interaction Interaction to remove.\n   * @return {module:ol/interaction/Interaction|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeInteraction = function removeInteraction (interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n\n  /**\n   * Removes the given layer from the map.\n   * @param {module:ol/layer/Base} layer Layer.\n   * @return {module:ol/layer/Base|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeLayer = function removeLayer (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n\n  /**\n   * Remove the given overlay from the map.\n   * @param {module:ol/Overlay} overlay Overlay.\n   * @return {module:ol/Overlay|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeOverlay = function removeOverlay (overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  PluggableMap.prototype.renderFrame_ = function renderFrame_ (time) {\n    var viewState;\n\n    var size = this.getSize();\n    var view = this.getView();\n    var extent = createEmpty();\n    var previousFrameState = this.frameState_;\n    /** @type {?module:ol/PluggableMap~FrameState} */\n    var frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      var layerStates = {};\n      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n      viewState = view.getState();\n      var focus = this.focus_;\n      if (!focus) {\n        focus = viewState.center;\n        var pixelResolution = viewState.resolution / this.pixelRatio_;\n        focus[0] = Math.round(focus[0] / pixelResolution) * pixelResolution;\n        focus[1] = Math.round(focus[1] / pixelResolution) * pixelResolution;\n      }\n      frameState = /** @type {module:ol/PluggableMap~FrameState} */ ({\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: focus,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      });\n    }\n\n    if (frameState) {\n      frameState.extent = getForViewAndSize(viewState.center,\n        viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ ||\n                    (!isEmpty(this.previousExtent_) &&\n                    !equals(frameState.extent, this.previousExtent_));\n        if (moveStart) {\n          this.dispatchEvent(\n            new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ &&\n          !frameState.viewHints[ViewHint.ANIMATING] &&\n          !frameState.viewHints[ViewHint.INTERACTING] &&\n          !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    setTimeout(this.handlePostRender.bind(this), 0);\n\n  };\n\n  /**\n   * Sets the layergroup of this map.\n   * @param {module:ol/layer/Group} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setLayerGroup = function setLayerGroup (layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n\n  /**\n   * Set the size of this map.\n   * @param {module:ol/size~Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setSize = function setSize (size) {\n    this.set(MapProperty.SIZE, size);\n  };\n\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setTarget = function setTarget (target) {\n    this.set(MapProperty.TARGET, target);\n  };\n\n  /**\n   * Set the view for this map.\n   * @param {module:ol/View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setView = function setView (view) {\n    this.set(MapProperty.VIEW, view);\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   */\n  PluggableMap.prototype.skipFeature = function skipFeature (feature) {\n    var featureUid = getUid(feature).toString();\n    this.skippedFeatureUids_[featureUid] = true;\n    this.render();\n  };\n\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  PluggableMap.prototype.updateSize = function updateSize () {\n    var targetElement = this.getTargetElement();\n\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([\n        targetElement.offsetWidth -\n            parseFloat(computedStyle['borderLeftWidth']) -\n            parseFloat(computedStyle['paddingLeft']) -\n            parseFloat(computedStyle['paddingRight']) -\n            parseFloat(computedStyle['borderRightWidth']),\n        targetElement.offsetHeight -\n            parseFloat(computedStyle['borderTopWidth']) -\n            parseFloat(computedStyle['paddingTop']) -\n            parseFloat(computedStyle['paddingBottom']) -\n            parseFloat(computedStyle['borderBottomWidth'])\n      ]);\n    }\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   */\n  PluggableMap.prototype.unskipFeature = function unskipFeature (feature) {\n    var featureUid = getUid(feature).toString();\n    delete this.skippedFeatureUids_[featureUid];\n    this.render();\n  };\n\n  return PluggableMap;\n}(BaseObject));\n\n\n/**\n * @param {MapOptions} options Map options.\n * @return {module:ol/PluggableMap~MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?\n      document.getElementById(options.keyboardEventTarget) :\n      options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object.<string, *>}\n   */\n  var values = {};\n\n  var layerGroup = (options.layers instanceof LayerGroup) ?\n    options.layers : new LayerGroup({layers: options.layers});\n  values[MapProperty.LAYERGROUP] = layerGroup;\n\n  values[MapProperty.TARGET] = options.target;\n\n  values[MapProperty.VIEW] = options.view !== undefined ?\n    options.view : new View();\n\n  var controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(options.controls instanceof Collection,\n        47); // Expected `controls` to be an array or an `module:ol/Collection~Collection`\n      controls = options.controls;\n    }\n  }\n\n  var interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(options.interactions instanceof Collection,\n        48); // Expected `interactions` to be an array or an `module:ol/Collection~Collection`\n      interactions = options.interactions;\n    }\n  }\n\n  var overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(options.overlays instanceof Collection,\n        49); // Expected `overlays` to be an array or an `module:ol/Collection~Collection`\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n\n}\nexport default PluggableMap;\n\n//# sourceMappingURL=PluggableMap.js.map"]},"metadata":{},"sourceType":"module"}