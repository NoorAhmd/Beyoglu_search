{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, createEmpty, equals, getIntersection, isEmpty } from '../../extent.js';\nimport IntermediateCanvasRenderer from '../canvas/IntermediateCanvas.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\n\nvar CanvasTileLayerRenderer = function (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n    IntermediateCanvasRenderer.call(this, tileLayer);\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = opt_noContext ? null : createCanvasContext2D();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.oversampling_;\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array.<module:ol/Tile>}\n     */\n\n    this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {module:ol/TileRange}\n     */\n\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n\n    this.imageTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.zDirection = 0;\n  }\n\n  if (IntermediateCanvasRenderer) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype);\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n  /**\n   * @private\n   * @param {module:ol/Tile} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n    var tileState = tile.getState();\n    var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/proj/Projection} projection Projection.\n   * @return {!module:ol/Tile} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var layer = this.getLayer();\n    var source =\n    /** @type {module:ol/source/Tile} */\n    layer.getSource();\n    var tile = source.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (!layer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (layer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var this$1 = this;\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var tileLayer = this.getLayer();\n    var tileSource =\n    /** @type {module:ol/source/Tile} */\n    tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    /**\n     * @type {Object.<number, Object.<string, module:ol/Tile>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n\n        tile = this$1.getTile(z, x, y, pixelRatio, projection);\n\n        if (this$1.isDrawableTile_(tile)) {\n          var uid = getUid(this$1);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (!this$1.newTiles_ && (inTransition || this$1.renderedTiles.indexOf(tile) === -1)) {\n              this$1.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n      var context = this.context;\n\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) {\n            context.clearRect(0, 0, width, height);\n          }\n\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array.<number>} */\n\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function (a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutter(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this$1.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this$1.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    var scale = this.renderedResolution / viewResolution;\n    var transform = composeTransform(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    return this.renderedTiles.length > 0;\n  };\n  /**\n   * @param {module:ol/Tile} tile Tile.\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/layer/Layer~State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = tile.getImage(this.getLayer());\n\n    if (!image) {\n      return;\n    }\n\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n\n    if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n    return this.imageTransform_;\n  };\n\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvasRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.TILE;\n};\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/TileLayer} The layer renderer.\n */\n\n\nCanvasTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(\n  /** @type {module:ol/layer/Tile} */\n  layer);\n};\n/**\n * @function\n * @return {module:ol/layer/Tile|module:ol/layer/VectorTile}\n */\n\n\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer; //# sourceMappingURL=TileLayer.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/renderer/canvas/TileLayer.js"],"names":["getUid","LayerType","TileRange","TileState","ViewHint","createCanvasContext2D","containsExtent","createEmpty","equals","getIntersection","isEmpty","IntermediateCanvasRenderer","create","createTransform","compose","composeTransform","CanvasTileLayerRenderer","tileLayer","opt_noContext","call","context","oversampling_","renderedExtent_","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","imageTransform_","zDirection","__proto__","prototype","Object","constructor","isDrawableTile_","tile","tileState","getState","useInterimTilesOnError","getLayer","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","pixelRatio","projection","layer","source","getSource","setState","getPreload","getInterimTile","prepareFrame","frameState","layerState","this$1","size","viewState","viewResolution","resolution","viewCenter","center","tileSource","sourceRevision","getRevision","tileGrid","getTileGridForProjection","getZForResolution","tileResolution","getResolution","oversampling","Math","round","extent","undefined","tileRange","getTileRangeForExtentAndZ","imageExtent","getTileRangeExtent","tilePixelRatio","getTilePixelRatio","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","hints","viewHints","animatingOrInteracting","ANIMATING","INTERACTING","tmpTileRange","minX","maxX","minY","maxY","Date","now","time","uid","tileCoord","toString","inTransition","indexOf","getAlpha","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","renderedResolution","tilePixelSize","getTilePixelSize","width","getWidth","height","getHeight","canvas","clearRect","length","zs","keys","map","Number","sort","a","b","currentResolution","currentScale","currentTilePixelSize","currentZ","i","ii","tileExtent","tileGutter","tilesToDraw","w","h","getGutter","tileCoordKey","getTileCoordExtent","getTileCoord","drawTileImage","push","scale","transform","coordinateToCanvasPixelTransform","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","gutter","transition","image","getImage","alpha","getOpaque","alphaChanged","globalAlpha","save","drawImage","restore","animate","endTransition","getImageTransform","getType","TILE","mapRenderer"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,MAAR,QAAqB,eAArB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AACA,OAAOC,SAAP,MAAsB,oBAAtB;AACA,OAAOC,QAAP,MAAqB,mBAArB;AACA,SAAQC,qBAAR,QAAoC,cAApC;AACA,SAAQC,cAAR,EAAwBC,WAAxB,EAAqCC,MAArC,EAA6CC,eAA7C,EAA8DC,OAA9D,QAA4E,iBAA5E;AACA,OAAOC,0BAAP,MAAuC,iCAAvC;AACA,SAAQC,MAAM,IAAIC,eAAlB,EAAmCC,OAAO,IAAIC,gBAA9C,QAAqE,oBAArE;AAEA;AACA;AACA;AACA;AACA;;AACA,IAAIC,uBAAuB,GAAI,UAAUL,0BAAV,EAAsC;AACnE,WAASK,uBAAT,CAAiCC,SAAjC,EAA4CC,aAA5C,EAA2D;AAEzDP,IAAAA,0BAA0B,CAACQ,IAA3B,CAAgC,IAAhC,EAAsCF,SAAtC;AAEA;AACJ;AACA;AACA;;AACI,SAAKG,OAAL,GAAeF,aAAa,GAAG,IAAH,GAAUb,qBAAqB,EAA3D;AAEA;AACJ;AACA;AACA;;AACI,SAAKgB,aAAL;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,eAAL,GAAuB,IAAvB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,gBAAL;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,aAAL,GAAqB,EAArB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,SAAL,GAAiB,KAAjB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,SAAL,GAAiBnB,WAAW,EAA5B;AAEA;AACJ;AACA;AACA;;AACI,SAAKoB,aAAL,GAAqB,IAAIzB,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAArB;AAEA;AACJ;AACA;AACA;;AACI,SAAK0B,eAAL,GAAuBf,eAAe,EAAtC;AAEA;AACJ;AACA;AACA;;AACI,SAAKgB,UAAL,GAAkB,CAAlB;AAED;;AAED,MAAKlB,0BAAL,EAAkCK,uBAAuB,CAACc,SAAxB,GAAoCnB,0BAApC;AAClCK,EAAAA,uBAAuB,CAACe,SAAxB,GAAoCC,MAAM,CAACpB,MAAP,CAAeD,0BAA0B,IAAIA,0BAA0B,CAACoB,SAAxE,CAApC;AACAf,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCE,WAAlC,GAAgDjB,uBAAhD;AAEA;AACF;AACA;AACA;AACA;;AACEA,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCG,eAAlC,GAAoD,SAASA,eAAT,CAA0BC,IAA1B,EAAgC;AAClF,QAAIC,SAAS,GAAGD,IAAI,CAACE,QAAL,EAAhB;AACA,QAAIC,sBAAsB,GAAG,KAAKC,QAAL,GAAgBC,yBAAhB,EAA7B;AACA,WAAOJ,SAAS,IAAIjC,SAAS,CAACsC,MAAvB,IACHL,SAAS,IAAIjC,SAAS,CAACuC,KADpB,IAEHN,SAAS,IAAIjC,SAAS,CAACwC,KAAvB,IAAgC,CAACL,sBAFrC;AAGD,GAND;AAQA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEtB,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCa,OAAlC,GAA4C,SAASA,OAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2BC,UAA3B,EAAuCC,UAAvC,EAAmD;AAC7F,QAAIC,KAAK,GAAG,KAAKX,QAAL,EAAZ;AACA,QAAIY,MAAM;AAAG;AAAsCD,IAAAA,KAAK,CAACE,SAAN,EAAnD;AACA,QAAIjB,IAAI,GAAGgB,MAAM,CAACP,OAAP,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,UAAxB,EAAoCC,UAApC,CAAX;;AACA,QAAId,IAAI,CAACE,QAAL,MAAmBlC,SAAS,CAACwC,KAAjC,EAAwC;AACtC,UAAI,CAACO,KAAK,CAACV,yBAAN,EAAL,EAAwC;AACtC;AACAL,QAAAA,IAAI,CAACkB,QAAL,CAAclD,SAAS,CAACsC,MAAxB;AACD,OAHD,MAGO,IAAIS,KAAK,CAACI,UAAN,KAAqB,CAAzB,EAA4B;AACjC;AACA,aAAK7B,SAAL,GAAiB,IAAjB;AACD;AACF;;AACD,QAAI,CAAC,KAAKS,eAAL,CAAqBC,IAArB,CAAL,EAAiC;AAC/BA,MAAAA,IAAI,GAAGA,IAAI,CAACoB,cAAL,EAAP;AACD;;AACD,WAAOpB,IAAP;AACD,GAjBD;AAmBA;AACF;AACA;;;AACEnB,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCyB,YAAlC,GAAiD,SAASA,YAAT,CAAuBC,UAAvB,EAAmCC,UAAnC,EAA+C;AAC9F,QAAIC,MAAM,GAAG,IAAb;AAGA,QAAIX,UAAU,GAAGS,UAAU,CAACT,UAA5B;AACA,QAAIY,IAAI,GAAGH,UAAU,CAACG,IAAtB;AACA,QAAIC,SAAS,GAAGJ,UAAU,CAACI,SAA3B;AACA,QAAIZ,UAAU,GAAGY,SAAS,CAACZ,UAA3B;AACA,QAAIa,cAAc,GAAGD,SAAS,CAACE,UAA/B;AACA,QAAIC,UAAU,GAAGH,SAAS,CAACI,MAA3B;AAEA,QAAIhD,SAAS,GAAG,KAAKsB,QAAL,EAAhB;AACA,QAAI2B,UAAU;AAAG;AAAsCjD,IAAAA,SAAS,CAACmC,SAAV,EAAvD;AACA,QAAIe,cAAc,GAAGD,UAAU,CAACE,WAAX,EAArB;AACA,QAAIC,QAAQ,GAAGH,UAAU,CAACI,wBAAX,CAAoCrB,UAApC,CAAf;AACA,QAAIJ,CAAC,GAAGwB,QAAQ,CAACE,iBAAT,CAA2BT,cAA3B,EAA2C,KAAKjC,UAAhD,CAAR;AACA,QAAI2C,cAAc,GAAGH,QAAQ,CAACI,aAAT,CAAuB5B,CAAvB,CAArB;AACA,QAAI6B,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWd,cAAc,GAAGU,cAA5B,KAA+C,CAAlE;AACA,QAAIK,MAAM,GAAGpB,UAAU,CAACoB,MAAxB;;AAEA,QAAInB,UAAU,CAACmB,MAAX,KAAsBC,SAA1B,EAAqC;AACnCD,MAAAA,MAAM,GAAGpE,eAAe,CAACoE,MAAD,EAASnB,UAAU,CAACmB,MAApB,CAAxB;AACD;;AACD,QAAInE,OAAO,CAACmE,MAAD,CAAX,EAAqB;AACnB;AACA,aAAO,KAAP;AACD;;AAED,QAAIE,SAAS,GAAGV,QAAQ,CAACW,yBAAT,CAAmCH,MAAnC,EAA2ChC,CAA3C,CAAhB;AACA,QAAIoC,WAAW,GAAGZ,QAAQ,CAACa,kBAAT,CAA4BrC,CAA5B,EAA+BkC,SAA/B,CAAlB;AAEA,QAAII,cAAc,GAAGjB,UAAU,CAACkB,iBAAX,CAA6BpC,UAA7B,CAArB;AAEA;AACJ;AACA;;AACI,QAAIqC,cAAc,GAAG,EAArB;AACAA,IAAAA,cAAc,CAACxC,CAAD,CAAd,GAAoB,EAApB;AAEA,QAAIyC,eAAe,GAAG,KAAKC,sBAAL,CACpBrB,UADoB,EACRjB,UADQ,EACIoC,cADJ,CAAtB;AAGA,QAAIG,KAAK,GAAG/B,UAAU,CAACgC,SAAvB;AACA,QAAIC,sBAAsB,GAAGF,KAAK,CAACpF,QAAQ,CAACuF,SAAV,CAAL,IAA6BH,KAAK,CAACpF,QAAQ,CAACwF,WAAV,CAA/D;AAEA,QAAIlE,SAAS,GAAG,KAAKA,SAArB;AACA,QAAImE,YAAY,GAAG,KAAKlE,aAAxB;AACA,SAAKF,SAAL,GAAiB,KAAjB;AACA,QAAIU,IAAJ,EAAUW,CAAV,EAAaC,CAAb;;AACA,SAAKD,CAAC,GAAGiC,SAAS,CAACe,IAAnB,EAAyBhD,CAAC,IAAIiC,SAAS,CAACgB,IAAxC,EAA8C,EAAEjD,CAAhD,EAAmD;AACjD,WAAKC,CAAC,GAAGgC,SAAS,CAACiB,IAAnB,EAAyBjD,CAAC,IAAIgC,SAAS,CAACkB,IAAxC,EAA8C,EAAElD,CAAhD,EAAmD;AACjD,YAAImD,IAAI,CAACC,GAAL,KAAa1C,UAAU,CAAC2C,IAAxB,GAA+B,EAA/B,IAAqCV,sBAAzC,EAAiE;AAC/D;AACD;;AACDvD,QAAAA,IAAI,GAAGwB,MAAM,CAACf,OAAP,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwBC,UAAxB,EAAoCC,UAApC,CAAP;;AACA,YAAIU,MAAM,CAACzB,eAAP,CAAuBC,IAAvB,CAAJ,EAAkC;AAChC,cAAIkE,GAAG,GAAGrG,MAAM,CAAC2D,MAAD,CAAhB;;AACA,cAAIxB,IAAI,CAACE,QAAL,MAAmBlC,SAAS,CAACsC,MAAjC,EAAyC;AACvC4C,YAAAA,cAAc,CAACxC,CAAD,CAAd,CAAkBV,IAAI,CAACmE,SAAL,CAAeC,QAAf,EAAlB,IAA+CpE,IAA/C;AACA,gBAAIqE,YAAY,GAAGrE,IAAI,CAACqE,YAAL,CAAkBH,GAAlB,CAAnB;;AACA,gBAAI,CAAC1C,MAAM,CAAClC,SAAR,KAAsB+E,YAAY,IAAI7C,MAAM,CAACnC,aAAP,CAAqBiF,OAArB,CAA6BtE,IAA7B,MAAuC,CAAC,CAA9E,CAAJ,EAAsF;AACpFwB,cAAAA,MAAM,CAAClC,SAAP,GAAmB,IAAnB;AACD;AACF;;AACD,cAAIU,IAAI,CAACuE,QAAL,CAAcL,GAAd,EAAmB5C,UAAU,CAAC2C,IAA9B,MAAwC,CAA5C,EAA+C;AAC7C;AACA;AACD;AACF;;AAED,YAAIO,cAAc,GAAGtC,QAAQ,CAACuC,0BAAT,CACnBzE,IAAI,CAACmE,SADc,EACHT,YADG,EACWnE,SADX,CAArB;AAEA,YAAImF,OAAO,GAAG,KAAd;;AACA,YAAIF,cAAJ,EAAoB;AAClBE,UAAAA,OAAO,GAAGvB,eAAe,CAACzC,CAAC,GAAG,CAAL,EAAQ8D,cAAR,CAAzB;AACD;;AACD,YAAI,CAACE,OAAL,EAAc;AACZxC,UAAAA,QAAQ,CAACyC,+BAAT,CACE3E,IAAI,CAACmE,SADP,EACkBhB,eADlB,EACmC,IADnC,EACyCO,YADzC,EACuDnE,SADvD;AAED;AAEF;AACF;;AAED,QAAIqF,kBAAkB,GAAGvC,cAAc,GAAGxB,UAAjB,GAA8BmC,cAA9B,GAA+CT,YAAxE;;AACA,QAAI,EAAE,KAAKqC,kBAAL,IAA2Bb,IAAI,CAACC,GAAL,KAAa1C,UAAU,CAAC2C,IAAxB,GAA+B,EAA1D,IAAgEV,sBAAlE,MACF,KAAKjE,SAAL,IACI,EAAE,KAAKH,eAAL,IAAwBhB,cAAc,CAAC,KAAKgB,eAAN,EAAuBuD,MAAvB,CAAxC,CADJ,IAEI,KAAKtD,gBAAL,IAAyB4C,cAF7B,IAGIO,YAAY,IAAI,KAAKrD,aAHzB,IAII,CAACqE,sBAAD,IAA2BqB,kBAAkB,IAAI,KAAKA,kBALxD,CAAJ,EAMG;AAED,UAAI3F,OAAO,GAAG,KAAKA,OAAnB;;AACA,UAAIA,OAAJ,EAAa;AACX,YAAI4F,aAAa,GAAG9C,UAAU,CAAC+C,gBAAX,CAA4BpE,CAA5B,EAA+BG,UAA/B,EAA2CC,UAA3C,CAApB;AACA,YAAIiE,KAAK,GAAGvC,IAAI,CAACC,KAAL,CAAWG,SAAS,CAACoC,QAAV,KAAuBH,aAAa,CAAC,CAAD,CAApC,GAA0CtC,YAArD,CAAZ;AACA,YAAI0C,MAAM,GAAGzC,IAAI,CAACC,KAAL,CAAWG,SAAS,CAACsC,SAAV,KAAwBL,aAAa,CAAC,CAAD,CAArC,GAA2CtC,YAAtD,CAAb;AACA,YAAI4C,MAAM,GAAGlG,OAAO,CAACkG,MAArB;;AACA,YAAIA,MAAM,CAACJ,KAAP,IAAgBA,KAAhB,IAAyBI,MAAM,CAACF,MAAP,IAAiBA,MAA9C,EAAsD;AACpD,eAAK/F,aAAL,GAAqBqD,YAArB;AACA4C,UAAAA,MAAM,CAACJ,KAAP,GAAeA,KAAf;AACAI,UAAAA,MAAM,CAACF,MAAP,GAAgBA,MAAhB;AACD,SAJD,MAIO;AACL,cAAI,KAAK9F,eAAL,IAAwB,CAACd,MAAM,CAACyE,WAAD,EAAc,KAAK3D,eAAnB,CAAnC,EAAwE;AACtEF,YAAAA,OAAO,CAACmG,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBL,KAAxB,EAA+BE,MAA/B;AACD;;AACD1C,UAAAA,YAAY,GAAG,KAAKrD,aAApB;AACD;AACF;;AAED,WAAKG,aAAL,CAAmBgG,MAAnB,GAA4B,CAA5B;AACA;;AACA,UAAIC,EAAE,GAAGzF,MAAM,CAAC0F,IAAP,CAAYrC,cAAZ,EAA4BsC,GAA5B,CAAgCC,MAAhC,CAAT;AACAH,MAAAA,EAAE,CAACI,IAAH,CAAQ,UAASC,CAAT,EAAYC,CAAZ,EAAe;AACrB,YAAID,CAAC,KAAKjF,CAAV,EAAa;AACX,iBAAO,CAAP;AACD,SAFD,MAEO,IAAIkF,CAAC,KAAKlF,CAAV,EAAa;AAClB,iBAAO,CAAC,CAAR;AACD,SAFM,MAEA;AACL,iBAAOiF,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAYD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAAhC;AACD;AACF,OARD;AASA,UAAIC,iBAAJ,EAAuBC,YAAvB,EAAqCC,oBAArC,EAA2DC,QAA3D,EAAqEC,CAArE,EAAwEC,EAAxE;AACA,UAAIC,UAAJ,EAAgBC,UAAhB,EAA4BC,WAA5B,EAAyCC,CAAzC,EAA4CC,CAA5C;;AACA,WAAKN,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGZ,EAAE,CAACD,MAApB,EAA4BY,CAAC,GAAGC,EAAhC,EAAoC,EAAED,CAAtC,EAAyC;AACvCD,QAAAA,QAAQ,GAAGV,EAAE,CAACW,CAAD,CAAb;AACAF,QAAAA,oBAAoB,GAAGhE,UAAU,CAAC+C,gBAAX,CAA4BkB,QAA5B,EAAsCnF,UAAtC,EAAkDC,UAAlD,CAAvB;AACA+E,QAAAA,iBAAiB,GAAG3D,QAAQ,CAACI,aAAT,CAAuB0D,QAAvB,CAApB;AACAF,QAAAA,YAAY,GAAGD,iBAAiB,GAAGxD,cAAnC;AACA+D,QAAAA,UAAU,GAAGpD,cAAc,GAAGjB,UAAU,CAACyE,SAAX,CAAqB1F,UAArB,CAA9B;AACAuF,QAAAA,WAAW,GAAGnD,cAAc,CAAC8C,QAAD,CAA5B;;AACA,aAAK,IAAIS,YAAT,IAAyBJ,WAAzB,EAAsC;AACpCrG,UAAAA,IAAI,GAAGqG,WAAW,CAACI,YAAD,CAAlB;AACAN,UAAAA,UAAU,GAAGjE,QAAQ,CAACwE,kBAAT,CAA4B1G,IAAI,CAAC2G,YAAL,EAA5B,EAAiDpH,SAAjD,CAAb;AACAoB,UAAAA,CAAC,GAAG,CAACwF,UAAU,CAAC,CAAD,CAAV,GAAgBrD,WAAW,CAAC,CAAD,CAA5B,IAAmCT,cAAnC,GAAoDW,cAApD,GAAqET,YAAzE;AACA3B,UAAAA,CAAC,GAAG,CAACkC,WAAW,CAAC,CAAD,CAAX,GAAiBqD,UAAU,CAAC,CAAD,CAA5B,IAAmC9D,cAAnC,GAAoDW,cAApD,GAAqET,YAAzE;AACA+D,UAAAA,CAAC,GAAGP,oBAAoB,CAAC,CAAD,CAApB,GAA0BD,YAA1B,GAAyCvD,YAA7C;AACAgE,UAAAA,CAAC,GAAGR,oBAAoB,CAAC,CAAD,CAApB,GAA0BD,YAA1B,GAAyCvD,YAA7C;AACAf,UAAAA,MAAM,CAACoF,aAAP,CAAqB5G,IAArB,EAA2BsB,UAA3B,EAAuCC,UAAvC,EAAmDZ,CAAnD,EAAsDC,CAAtD,EAAyD0F,CAAzD,EAA4DC,CAA5D,EAA+DH,UAA/D,EAA2E1F,CAAC,KAAKsF,QAAjF;AACAxE,UAAAA,MAAM,CAACnC,aAAP,CAAqBwH,IAArB,CAA0B7G,IAA1B;AACD;AACF;;AAED,WAAKZ,gBAAL,GAAwB4C,cAAxB;AACA,WAAK4C,kBAAL,GAA0BvC,cAAc,GAAGxB,UAAjB,GAA8BmC,cAA9B,GAA+CT,YAAzE;AACA,WAAKpD,eAAL,GAAuB2D,WAAvB;AACD;;AAED,QAAIgE,KAAK,GAAG,KAAKlC,kBAAL,GAA0BjD,cAAtC;AACA,QAAIoF,SAAS,GAAGnI,gBAAgB,CAAC,KAAKa,eAAN,EAC9BoB,UAAU,GAAGY,IAAI,CAAC,CAAD,CAAjB,GAAuB,CADO,EACJZ,UAAU,GAAGY,IAAI,CAAC,CAAD,CAAjB,GAAuB,CADnB,EAE9BqF,KAF8B,EAEvBA,KAFuB,EAG9B,CAH8B,EAI9B,CAAC,KAAK3H,eAAL,CAAqB,CAArB,IAA0B0C,UAAU,CAAC,CAAD,CAArC,IAA4C,KAAK+C,kBAAjD,GAAsE/D,UAJxC,EAK9B,CAACgB,UAAU,CAAC,CAAD,CAAV,GAAgB,KAAK1C,eAAL,CAAqB,CAArB,CAAjB,IAA4C,KAAKyF,kBAAjD,GAAsE/D,UALxC,CAAhC;AAMAjC,IAAAA,gBAAgB,CAAC,KAAKoI,gCAAN,EACdnG,UAAU,GAAGY,IAAI,CAAC,CAAD,CAAjB,GAAuB,CAAvB,GAA2BsF,SAAS,CAAC,CAAD,CADtB,EAC2BlG,UAAU,GAAGY,IAAI,CAAC,CAAD,CAAjB,GAAuB,CAAvB,GAA2BsF,SAAS,CAAC,CAAD,CAD/D,EAEdlG,UAAU,GAAGc,cAFC,EAEe,CAACd,UAAD,GAAcc,cAF7B,EAGd,CAHc,EAId,CAACE,UAAU,CAAC,CAAD,CAJG,EAIE,CAACA,UAAU,CAAC,CAAD,CAJb,CAAhB;AAOA,SAAKoF,eAAL,CAAqB3F,UAAU,CAAC4F,SAAhC,EAA2CnF,UAA3C,EAAuDrB,CAAvD,EAA0DkC,SAA1D;AACA,SAAKuE,iBAAL,CAAuB7F,UAAvB,EAAmCS,UAAnC,EAA+CG,QAA/C,EAAyDrB,UAAzD,EACEC,UADF,EACc4B,MADd,EACsBhC,CADtB,EACyB5B,SAAS,CAACqC,UAAV,EADzB;AAEA,SAAKiG,mBAAL,CAAyB9F,UAAzB,EAAqCS,UAArC;AAEA,WAAO,KAAK1C,aAAL,CAAmBgG,MAAnB,GAA4B,CAAnC;AACD,GAzKD;AA2KA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACExG,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCgH,aAAlC,GAAkD,SAASA,aAAT,CAAwB5G,IAAxB,EAA8BsB,UAA9B,EAA0CC,UAA1C,EAAsDZ,CAAtD,EAAyDC,CAAzD,EAA4D0F,CAA5D,EAA+DC,CAA/D,EAAkEc,MAAlE,EAA0EC,UAA1E,EAAsF;AACtI,QAAIC,KAAK,GAAGvH,IAAI,CAACwH,QAAL,CAAc,KAAKpH,QAAL,EAAd,CAAZ;;AACA,QAAI,CAACmH,KAAL,EAAY;AACV;AACD;;AACD,QAAIrD,GAAG,GAAGrG,MAAM,CAAC,IAAD,CAAhB;AACA,QAAI4J,KAAK,GAAGH,UAAU,GAAGtH,IAAI,CAACuE,QAAL,CAAcL,GAAd,EAAmB5C,UAAU,CAAC2C,IAA9B,CAAH,GAAyC,CAA/D;;AACA,QAAIwD,KAAK,KAAK,CAAV,IAAe,CAAC,KAAKrH,QAAL,GAAgBa,SAAhB,GAA4ByG,SAA5B,CAAsCpG,UAAU,CAACI,SAAX,CAAqBZ,UAA3D,CAApB,EAA4F;AAC1F,WAAK7B,OAAL,CAAamG,SAAb,CAAuBzE,CAAvB,EAA0BC,CAA1B,EAA6B0F,CAA7B,EAAgCC,CAAhC;AACD;;AACD,QAAIoB,YAAY,GAAGF,KAAK,KAAK,KAAKxI,OAAL,CAAa2I,WAA1C;;AACA,QAAID,YAAJ,EAAkB;AAChB,WAAK1I,OAAL,CAAa4I,IAAb;AACA,WAAK5I,OAAL,CAAa2I,WAAb,GAA2BH,KAA3B;AACD;;AACD,SAAKxI,OAAL,CAAa6I,SAAb,CAAuBP,KAAvB,EAA8BF,MAA9B,EAAsCA,MAAtC,EACEE,KAAK,CAACxC,KAAN,GAAc,IAAIsC,MADpB,EAC4BE,KAAK,CAACtC,MAAN,GAAe,IAAIoC,MAD/C,EACuD1G,CADvD,EAC0DC,CAD1D,EAC6D0F,CAD7D,EACgEC,CADhE;;AAGA,QAAIoB,YAAJ,EAAkB;AAChB,WAAK1I,OAAL,CAAa8I,OAAb;AACD;;AACD,QAAIN,KAAK,KAAK,CAAd,EAAiB;AACfnG,MAAAA,UAAU,CAAC0G,OAAX,GAAqB,IAArB;AACD,KAFD,MAEO,IAAIV,UAAJ,EAAgB;AACrBtH,MAAAA,IAAI,CAACiI,aAAL,CAAmB/D,GAAnB;AACD;AACF,GA1BD;AA4BA;AACF;AACA;;;AACErF,EAAAA,uBAAuB,CAACe,SAAxB,CAAkC4H,QAAlC,GAA6C,SAASA,QAAT,GAAqB;AAChE,QAAIvI,OAAO,GAAG,KAAKA,OAAnB;AACA,WAAOA,OAAO,GAAGA,OAAO,CAACkG,MAAX,GAAoB,IAAlC;AACD,GAHD;AAKA;AACF;AACA;;;AACEtG,EAAAA,uBAAuB,CAACe,SAAxB,CAAkCsI,iBAAlC,GAAsD,SAASA,iBAAT,GAA8B;AAClF,WAAO,KAAKzI,eAAZ;AACD,GAFD;;AAIA,SAAOZ,uBAAP;AACD,CApV8B,CAoV7BL,0BApV6B,CAA/B;AAuVA;AACA;AACA;AACA;AACA;;;AACAK,uBAAuB,CAAC,SAAD,CAAvB,GAAqC,UAASkC,KAAT,EAAgB;AACnD,SAAOA,KAAK,CAACoH,OAAN,OAAoBrK,SAAS,CAACsK,IAArC;AACD,CAFD;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACAvJ,uBAAuB,CAAC,QAAD,CAAvB,GAAoC,UAASwJ,WAAT,EAAsBtH,KAAtB,EAA6B;AAC/D,SAAO,IAAIlC,uBAAJ;AAA4B;AAAqCkC,EAAAA,KAAjE,CAAP;AACD,CAFD;AAKA;AACA;AACA;AACA;;;AACAlC,uBAAuB,CAACe,SAAxB,CAAkCQ,QAAlC;AAGA,eAAevB,uBAAf,C,CAEA","sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, createEmpty, equals, getIntersection, isEmpty} from '../../extent.js';\nimport IntermediateCanvasRenderer from '../canvas/IntermediateCanvas.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nvar CanvasTileLayerRenderer = (function (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n\n    IntermediateCanvasRenderer.call(this, tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array.<module:ol/Tile>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {module:ol/extent~Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {module:ol/TileRange}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {module:ol/transform~Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n\n  }\n\n  if ( IntermediateCanvasRenderer ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n\n  /**\n   * @private\n   * @param {module:ol/Tile} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {\n    var tileState = tile.getState();\n    var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\n    return tileState == TileState.LOADED ||\n        tileState == TileState.EMPTY ||\n        tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/proj/Projection} projection Projection.\n   * @return {!module:ol/Tile} Tile.\n   */\n  CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {\n    var layer = this.getLayer();\n    var source = /** @type {module:ol/source/Tile} */ (layer.getSource());\n    var tile = source.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!layer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (layer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {\n    var this$1 = this;\n\n\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n\n    var tileLayer = this.getLayer();\n    var tileSource = /** @type {module:ol/source/Tile} */ (tileLayer.getSource());\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object.<number, Object.<string, module:ol/Tile>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    var findLoadedTiles = this.createLoadedTileFinder(\n      tileSource, projection, tilesToDrawByZ);\n\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this$1.getTile(z, x, y, pixelRatio, projection);\n        if (this$1.isDrawableTile_(tile)) {\n          var uid = getUid(this$1);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (!this$1.newTiles_ && (inTransition || this$1.renderedTiles.indexOf(tile) === -1)) {\n              this$1.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n\n      }\n    }\n\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n      this.newTiles_ ||\n          !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||\n          this.renderedRevision != sourceRevision ||\n          oversampling != this.oversampling_ ||\n          !animatingOrInteracting && renderedResolution != this.renderedResolution\n    )) {\n\n      var context = this.context;\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array.<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function(a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutter(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this$1.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this$1.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    var scale = this.renderedResolution / viewResolution;\n    var transform = composeTransform(this.imageTransform_,\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n      scale, scale,\n      0,\n      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform,\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\n      0,\n      -viewCenter[0], -viewCenter[1]);\n\n\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n      projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n\n    return this.renderedTiles.length > 0;\n  };\n\n  /**\n   * @param {module:ol/Tile} tile Tile.\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/layer/Layer~State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = tile.getImage(this.getLayer());\n    if (!image) {\n      return;\n    }\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter,\n      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImage = function getImage () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {\n    return this.imageTransform_;\n  };\n\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvasRenderer));\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/TileLayer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(/** @type {module:ol/layer/Tile} */ (layer));\n};\n\n\n/**\n * @function\n * @return {module:ol/layer/Tile|module:ol/layer/VectorTile}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\n\nexport default CanvasTileLayerRenderer;\n\n//# sourceMappingURL=TileLayer.js.map"]},"metadata":{},"sourceType":"module"}