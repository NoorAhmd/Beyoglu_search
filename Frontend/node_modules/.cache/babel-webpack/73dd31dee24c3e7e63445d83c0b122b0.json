{"ast":null,"code":"/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getArea, getCenter, getIntersection } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from '../reproj/Triangulation.js';\n/**\n * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nvar ReprojTile = function (Tile) {\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n    var this$1 = this;\n    Tile.call(this, tileCoord, TileState.IDLE);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {module:ol/tilegrid/TileGrid}\n     */\n\n    this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {module:ol/tilegrid/TileGrid}\n     */\n\n    this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {module:ol/tilecoord~TileCoord}\n     */\n\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array.<module:ol/Tile>}\n     */\n\n    this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n\n    this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!module:ol/reproj/Triangulation}\n     */\n\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this$1.sourceZ_, srcX, srcY, pixelRatio);\n\n          if (tile) {\n            this$1.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  if (Tile) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create(Tile && Tile.prototype);\n  ReprojTile.prototype.constructor = ReprojTile;\n  /**\n   * @inheritDoc\n   */\n\n  ReprojTile.prototype.disposeInternal = function disposeInternal() {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n\n    Tile.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  ReprojTile.prototype.getImage = function getImage() {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.reproject_ = function reproject_() {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n      this.state = TileState.LOADED;\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ReprojTile.prototype.load = function load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n          var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile);\n\nexport default ReprojTile; //# sourceMappingURL=Tile.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/reproj/Tile.js"],"names":["ERROR_THRESHOLD","Tile","TileState","listen","unlistenByKey","EventType","getArea","getCenter","getIntersection","clamp","calculateSourceResolution","render","renderReprojected","Triangulation","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","this$1","call","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","targetCenter","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","__proto__","prototype","Object","create","constructor","disposeInternal","LOADING","unlistenSources_","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","bind","ERROR","z","size","getTileSize","width","height","changed","load","leftToLoad","sourceListenKey","CHANGE","e","setTimeout"],"mappings":"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","sourcesContent":["/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {getArea, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceResolution, render as renderReprojected} from '../reproj.js';\nimport Triangulation from '../reproj/Triangulation.js';\n\n\n/**\n * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType\n */\n\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = (function (Tile) {\n  function ReprojTile(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges\n  ) {\n    var this$1 = this;\n\n    Tile.call(this, tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {module:ol/tilegrid/TileGrid}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {module:ol/tilegrid/TileGrid}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {module:ol/tilecoord~TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array.<module:ol/Tile>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {Array.<module:ol/events~EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ?\n      getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]);\n\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(\n      sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n      opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!module:ol/reproj/Triangulation}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n      sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(\n          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent, this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this$1.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this$1.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  if ( Tile ) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create( Tile && Tile.prototype );\n  ReprojTile.prototype.constructor = ReprojTile;\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.disposeInternal = function disposeInternal () {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    Tile.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function getImage () {\n    return this.canvas_;\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function reproject_ () {\n    var sources = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_,\n        sourceResolution, this.sourceTileGrid_.getExtent(),\n        targetResolution, targetExtent, this.triangulation_, sources,\n        this.gutter_, this.renderEdges_);\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.load = function load () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      var leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          var sourceListenKey = listen(tile, EventType.CHANGE,\n            function(e) {\n              var state = tile.getState();\n              if (state == TileState.LOADED ||\n                    state == TileState.ERROR ||\n                    state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile));\n\n\nexport default ReprojTile;\n\n//# sourceMappingURL=Tile.js.map"]},"metadata":{},"sourceType":"module"}