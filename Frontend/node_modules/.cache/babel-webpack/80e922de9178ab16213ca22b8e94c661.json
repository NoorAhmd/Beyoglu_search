{"ast":null,"code":"import _classCallCheck from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Inject, Optional, Self, NgZone, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\n * \\@breaking-change 7.0.0\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\n\nvar MatTextareaAutosize = /*#__PURE__*/function (_CdkTextareaAutosize) {\n  _inherits(MatTextareaAutosize, _CdkTextareaAutosize);\n\n  var _super = _createSuper(MatTextareaAutosize);\n\n  function MatTextareaAutosize() {\n    _classCallCheck(this, MatTextareaAutosize);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MatTextareaAutosize, [{\n    key: \"matAutosizeMinRows\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this.minRows;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this.minRows = value;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"matAutosizeMaxRows\",\n    get: function get() {\n      return this.maxRows;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this.maxRows = value;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"matAutosize\",\n    get: function get() {\n      return this.enabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this.enabled = value;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"matTextareaAutosize\",\n    get: function get() {\n      return this.enabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this.enabled = value;\n    }\n  }]);\n\n  return MatTextareaAutosize;\n}(CdkTextareaAutosize);\n\nMatTextareaAutosize.ɵfac = function MatTextareaAutosize_Factory(t) {\n  return ɵMatTextareaAutosize_BaseFactory(t || MatTextareaAutosize);\n};\n\nMatTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatTextareaAutosize,\n  selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]],\n  hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"],\n  hostBindings: function MatTextareaAutosize_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"input\", function MatTextareaAutosize_input_HostBindingHandler() {\n        return ctx._noopInputHandler();\n      });\n    }\n  },\n  inputs: {\n    cdkAutosizeMinRows: \"cdkAutosizeMinRows\",\n    cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\",\n    matAutosizeMinRows: \"matAutosizeMinRows\",\n    matAutosizeMaxRows: \"matAutosizeMaxRows\",\n    matAutosize: [\"mat-autosize\", \"matAutosize\"],\n    matTextareaAutosize: \"matTextareaAutosize\"\n  },\n  exportAs: [\"matTextareaAutosize\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nMatTextareaAutosize.propDecorators = {\n  \"matAutosizeMinRows\": [{\n    type: Input\n  }],\n  \"matAutosizeMaxRows\": [{\n    type: Input\n  }],\n  \"matAutosize\": [{\n    type: Input,\n    args: ['mat-autosize']\n  }],\n  \"matTextareaAutosize\": [{\n    type: Input\n  }]\n};\nvar ɵMatTextareaAutosize_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatTextareaAutosize, [{\n    type: Directive,\n    args: [{\n      selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n      exportAs: 'matTextareaAutosize',\n      inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n      host: {\n        'class': 'cdk-textarea-autosize mat-autosize',\n        // Textarea elements that have the directive applied should have a single row by default.\n        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n        'rows': '1',\n        '(input)': '_noopInputHandler()'\n      }\n    }]\n  }], null, {\n    matAutosizeMinRows: [{\n      type: Input\n    }],\n    matAutosizeMaxRows: [{\n      type: Input\n    }],\n    matAutosize: [{\n      type: Input,\n      args: ['mat-autosize']\n    }],\n    matTextareaAutosize: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\n\n\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(\"Input type \\\"\".concat(type, \"\\\" isn't supported by matInput.\"));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\n\n\nvar\n/** @type {?} */\nMAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n\nvar\n/** @type {?} */\nMAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nvar\n/** @type {?} */\nnextUniqueId = 0;\n/**\n * \\@docs-private\n */\n\nvar MatInputBase =\n/**\n * @param {?} _defaultErrorStateMatcher\n * @param {?} _parentForm\n * @param {?} _parentFormGroup\n * @param {?} ngControl\n */\nfunction MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n  _classCallCheck(this, MatInputBase);\n\n  this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n  this._parentForm = _parentForm;\n  this._parentFormGroup = _parentFormGroup;\n  this.ngControl = ngControl;\n};\n\nvar\n/** @type {?} */\n_MatInputMixinBase = mixinErrorState(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\n\n\nvar MatInput = /*#__PURE__*/function (_MatInputMixinBase2) {\n  _inherits(MatInput, _MatInputMixinBase2);\n\n  var _super2 = _createSuper(MatInput);\n\n  /**\n   * @param {?} _elementRef\n   * @param {?} _platform\n   * @param {?} ngControl\n   * @param {?} _parentForm\n   * @param {?} _parentFormGroup\n   * @param {?} _defaultErrorStateMatcher\n   * @param {?} inputValueAccessor\n   * @param {?} _autofillMonitor\n   * @param {?} ngZone\n   */\n  function MatInput(_elementRef, _platform,\n  /** @docs-private */\n  ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n    var _this;\n\n    _classCallCheck(this, MatInput);\n\n    _this = _super2.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n    _this._elementRef = _elementRef;\n    _this._platform = _platform;\n    _this.ngControl = ngControl;\n    _this._autofillMonitor = _autofillMonitor;\n    _this._uid = \"mat-input-\".concat(nextUniqueId++);\n    /**\n     * Whether the component is being rendered on the server.\n     */\n\n    _this._isServer = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n\n    _this.focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n\n    _this.stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n\n    _this.controlType = 'mat-input';\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n\n    _this.autofilled = false;\n    _this._disabled = false;\n    _this._required = false;\n    _this._type = 'text';\n    _this._readonly = false;\n    _this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(function (t) {\n      return getSupportedInputTypes().has(t);\n    }); // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n\n    _this._inputValueAccessor = inputValueAccessor || _this._elementRef.nativeElement;\n    _this._previousNativeValue = _this.value; // Force setter to be called in case id was not specified.\n\n    _this.id = _this.id; // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(function () {\n        _elementRef.nativeElement.addEventListener('keyup', function (event) {\n          var\n          /** @type {?} */\n          el =\n          /** @type {?} */\n          event.target;\n\n          if (!el.value && !el.selectionStart && !el.selectionEnd) {\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n            // `1, 1` fixes it for the first time that you type text and\n            // then hold delete. Toggling to `1, 1` and then back to\n            // `0, 0` seems to completely fix it.\n            el.setSelectionRange(1, 1);\n            el.setSelectionRange(0, 0);\n          }\n        });\n      });\n    }\n\n    _this._isServer = !_this._platform.isBrowser;\n    return _this;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n\n\n  _createClass(MatInput, [{\n    key: \"disabled\",\n    get: function get() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n\n      return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._disabled = coerceBooleanProperty(value); // Browsers may not fire the blur event if the input is disabled too quickly.\n      // Reset from here to ensure that the element doesn't become stuck.\n\n      if (this.focused) {\n        this.focused = false;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._id = value || this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"required\",\n    get: function get() {\n      return this._required;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    /**\n     * Input type of the element.\n     * @return {?}\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._type = value || 'text';\n\n      this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native\n      // input element. To ensure that bindings for `type` work, we need to sync the setter\n      // with the native property. Textarea elements don't support the type property or attribute.\n\n\n      if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n        this._elementRef.nativeElement.type = this._type;\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._inputValueAccessor.value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== this.value) {\n        this._inputValueAccessor.value = value;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Whether the element is readonly.\n     * @return {?}\n     */\n\n  }, {\n    key: \"readonly\",\n    get: function get() {\n      return this._readonly;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this2 = this;\n\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n        _this2.autofilled = event.isAutofilled;\n\n        _this2.stateChanges.next();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      this.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.stateChanges.complete();\n\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngDoCheck\",\n    value: function ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n      } // We need to dirty-check the native element's value, because there are some cases where\n      // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n      // updating the value using `emitEvent: false`).\n\n\n      this._dirtyCheckNativeValue();\n    }\n    /**\n     * Focuses the input.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n\n  }, {\n    key: \"_focusChanged\",\n    value: function _focusChanged(isFocused) {\n      if (isFocused !== this.focused && !this.readonly) {\n        this.focused = isFocused;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"_onInput\",\n    value: function _onInput() {// This is a noop function and is used to let Angular know whenever the value changes.\n      // Angular will run a new change detection each time the `input` event has been dispatched.\n      // It's necessary that Angular recognizes the value change, because when floatingLabel\n      // is set to false and Angular forms aren't used, the placeholder won't recognize the\n      // value changes and will not disappear.\n      // Listening to the input event wouldn't be necessary when the input is using the\n      // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_dirtyCheckNativeValue\",\n    value: function _dirtyCheckNativeValue() {\n      var\n      /** @type {?} */\n      newValue = this.value;\n\n      if (this._previousNativeValue !== newValue) {\n        this._previousNativeValue = newValue;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_validateType\",\n    value: function _validateType() {\n      if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n        throw getMatInputUnsupportedTypeError(this._type);\n      }\n    }\n    /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_isNeverEmpty\",\n    value: function _isNeverEmpty() {\n      return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /**\n     * Checks whether the input is invalid based on the native validation.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_isBadInput\",\n    value: function _isBadInput() {\n      // The `validity` property won't be present on platform-server.\n      var\n      /** @type {?} */\n      validity =\n      /** @type {?} */\n      this._elementRef.nativeElement.validity;\n      return validity && validity.badInput;\n    }\n    /**\n     * Determines if the component host is a textarea.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_isTextarea\",\n    value: function _isTextarea() {\n      return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldLabelFloat\",\n    get: function get() {\n      return this.focused || !this.empty;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDescribedByIds\",\n    value: function setDescribedByIds(ids) {\n      this._ariaDescribedby = ids.join(' ');\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"onContainerClick\",\n    value: function onContainerClick() {\n      this.focus();\n    }\n  }]);\n\n  return MatInput;\n}(_MatInputMixinBase);\n\nMatInput.ɵfac = function MatInput_Factory(t) {\n  return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nMatInput.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatInput,\n  selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"]],\n  hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n  hostVars: 10,\n  hostBindings: function MatInput_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"blur\", function MatInput_blur_HostBindingHandler() {\n        return ctx._focusChanged(false);\n      })(\"focus\", function MatInput_focus_HostBindingHandler() {\n        return ctx._focusChanged(true);\n      })(\"input\", function MatInput_input_HostBindingHandler() {\n        return ctx._onInput();\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required)(\"readonly\", ctx.readonly);\n      ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"placeholder\", ctx.placeholder)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-invalid\", ctx.errorState)(\"aria-required\", ctx.required.toString());\n      ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n    }\n  },\n  inputs: {\n    id: \"id\",\n    disabled: \"disabled\",\n    required: \"required\",\n    type: \"type\",\n    value: \"value\",\n    readonly: \"readonly\",\n    placeholder: \"placeholder\",\n    errorStateMatcher: \"errorStateMatcher\"\n  },\n  exportAs: [\"matInput\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: MatFormFieldControl,\n    useExisting: MatInput\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nMatInput.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Platform\n  }, {\n    type: NgControl,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }, {\n    type: NgForm,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: FormGroupDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: ErrorStateMatcher\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [MAT_INPUT_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: AutofillMonitor\n  }, {\n    type: NgZone\n  }];\n};\n\nMatInput.propDecorators = {\n  \"disabled\": [{\n    type: Input\n  }],\n  \"id\": [{\n    type: Input\n  }],\n  \"placeholder\": [{\n    type: Input\n  }],\n  \"required\": [{\n    type: Input\n  }],\n  \"type\": [{\n    type: Input\n  }],\n  \"errorStateMatcher\": [{\n    type: Input\n  }],\n  \"value\": [{\n    type: Input\n  }],\n  \"readonly\": [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatInput, [{\n    type: Directive,\n    args: [{\n      selector: \"input[matInput], textarea[matInput]\",\n      exportAs: 'matInput',\n      host: {\n        /**\n             * @breaking-change 7.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n             */\n        'class': 'mat-input-element mat-form-field-autofill-control',\n        '[class.mat-input-server]': '_isServer',\n        // Native input properties that are overwritten by Angular inputs need to be synced with\n        // the native input element. Otherwise property bindings for those don't work.\n        '[attr.id]': 'id',\n        '[attr.placeholder]': 'placeholder',\n        '[disabled]': 'disabled',\n        '[required]': 'required',\n        '[readonly]': 'readonly',\n        '[attr.aria-describedby]': '_ariaDescribedby || null',\n        '[attr.aria-invalid]': 'errorState',\n        '[attr.aria-required]': 'required.toString()',\n        '(blur)': '_focusChanged(false)',\n        '(focus)': '_focusChanged(true)',\n        '(input)': '_onInput()'\n      },\n      providers: [{\n        provide: MatFormFieldControl,\n        useExisting: MatInput\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc1.Platform\n    }, {\n      type: ɵngcc2.NgControl,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }]\n    }, {\n      type: ɵngcc2.NgForm,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.FormGroupDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc3.ErrorStateMatcher\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }, {\n        type: Inject,\n        args: [MAT_INPUT_VALUE_ACCESSOR]\n      }]\n    }, {\n      type: ɵngcc4.AutofillMonitor\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    id: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    readonly: [{\n      type: Input\n    }],\n    placeholder: [{\n      type: Input\n    }],\n    errorStateMatcher: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar MatInputModule = function MatInputModule() {\n  _classCallCheck(this, MatInputModule);\n};\n\nMatInputModule.ɵfac = function MatInputModule_Factory(t) {\n  return new (t || MatInputModule)();\n};\n\nMatInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: MatInputModule\n});\nMatInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  providers: [ErrorStateMatcher],\n  imports: [[CommonModule, TextFieldModule, MatFormFieldModule], TextFieldModule, MatFormFieldModule]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, {\n    declarations: function declarations() {\n      return [MatInput, MatTextareaAutosize];\n    },\n    imports: function imports() {\n      return [CommonModule, TextFieldModule, MatFormFieldModule];\n    },\n    exports: function exports() {\n      return [TextFieldModule, MatFormFieldModule, MatInput, MatTextareaAutosize];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatInputModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [MatInput, MatTextareaAutosize],\n      imports: [CommonModule, TextFieldModule, MatFormFieldModule],\n      exports: [TextFieldModule, MatFormFieldModule, MatInput, MatTextareaAutosize],\n      providers: [ErrorStateMatcher]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nexport { MatTextareaAutosize, MatInputBase, _MatInputMixinBase, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR }; //# sourceMappingURL=input.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/@angular/material/__ivy_ngcc__/esm2015/input.js"],"names":["CdkTextareaAutosize","AutofillMonitor","TextFieldModule","Directive","Input","InjectionToken","ElementRef","Inject","Optional","Self","NgZone","NgModule","coerceBooleanProperty","getSupportedInputTypes","Platform","FormGroupDirective","NgControl","NgForm","ErrorStateMatcher","mixinErrorState","MatFormFieldControl","MatFormFieldModule","Subject","CommonModule","ɵngcc0","ɵngcc1","ɵngcc2","ɵngcc3","ɵngcc4","MatTextareaAutosize","minRows","value","maxRows","enabled","ɵfac","MatTextareaAutosize_Factory","t","ɵMatTextareaAutosize_BaseFactory","ɵdir","ɵɵdefineDirective","type","selectors","hostAttrs","hostBindings","MatTextareaAutosize_HostBindings","rf","ctx","ɵɵlistener","MatTextareaAutosize_input_HostBindingHandler","_noopInputHandler","inputs","cdkAutosizeMinRows","cdkAutosizeMaxRows","matAutosizeMinRows","matAutosizeMaxRows","matAutosize","matTextareaAutosize","exportAs","features","ɵɵInheritDefinitionFeature","propDecorators","args","ɵɵgetInheritedFactory","ngDevMode","ɵsetClassMetadata","selector","host","getMatInputUnsupportedTypeError","Error","MAT_INPUT_VALUE_ACCESSOR","MAT_INPUT_INVALID_TYPES","nextUniqueId","MatInputBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","_MatInputMixinBase","MatInput","_elementRef","_platform","inputValueAccessor","_autofillMonitor","ngZone","_uid","_isServer","focused","stateChanges","controlType","autofilled","_disabled","_required","_type","_readonly","_neverEmptyInputTypes","filter","has","_inputValueAccessor","nativeElement","_previousNativeValue","id","IOS","runOutsideAngular","addEventListener","event","el","target","selectionStart","selectionEnd","setSelectionRange","isBrowser","disabled","next","_id","_validateType","_isTextarea","monitor","subscribe","isAutofilled","complete","stopMonitoring","updateErrorState","_dirtyCheckNativeValue","focus","isFocused","readonly","newValue","indexOf","validity","badInput","nodeName","toLowerCase","_isNeverEmpty","_isBadInput","empty","ids","_ariaDescribedby","join","MatInput_Factory","ɵɵdirectiveInject","hostVars","MatInput_HostBindings","MatInput_blur_HostBindingHandler","_focusChanged","MatInput_focus_HostBindingHandler","MatInput_input_HostBindingHandler","_onInput","ɵɵhostProperty","required","ɵɵattribute","placeholder","errorState","toString","ɵɵclassProp","errorStateMatcher","ɵɵProvidersFeature","provide","useExisting","ɵɵNgOnChangesFeature","ctorParameters","decorators","undefined","providers","MatInputModule","MatInputModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","ngJitMode","ɵɵsetNgModuleScope","declarations","exports"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Inject, Optional, Self, NgZone, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\n * \\@breaking-change 7.0.0\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\nclass MatTextareaAutosize extends CdkTextareaAutosize {\n    /**\n     * @return {?}\n     */\n    get matAutosizeMinRows() { return this.minRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMinRows(value) { this.minRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosizeMaxRows() { return this.maxRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMaxRows(value) { this.maxRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosize(value) { this.enabled = value; }\n    /**\n     * @return {?}\n     */\n    get matTextareaAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matTextareaAutosize(value) { this.enabled = value; }\n}\nMatTextareaAutosize.ɵfac = function MatTextareaAutosize_Factory(t) { return ɵMatTextareaAutosize_BaseFactory(t || MatTextareaAutosize); };\nMatTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatTextareaAutosize, selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]], hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"], hostBindings: function MatTextareaAutosize_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function MatTextareaAutosize_input_HostBindingHandler() { return ctx._noopInputHandler(); });\n    } }, inputs: { cdkAutosizeMinRows: \"cdkAutosizeMinRows\", cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\", matAutosizeMinRows: \"matAutosizeMinRows\", matAutosizeMaxRows: \"matAutosizeMaxRows\", matAutosize: [\"mat-autosize\", \"matAutosize\"], matTextareaAutosize: \"matTextareaAutosize\" }, exportAs: [\"matTextareaAutosize\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\n/** @nocollapse */\nMatTextareaAutosize.propDecorators = {\n    \"matAutosizeMinRows\": [{ type: Input },],\n    \"matAutosizeMaxRows\": [{ type: Input },],\n    \"matAutosize\": [{ type: Input, args: ['mat-autosize',] },],\n    \"matTextareaAutosize\": [{ type: Input },],\n};\nconst ɵMatTextareaAutosize_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize);\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatTextareaAutosize, [{\n        type: Directive,\n        args: [{\n                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                exportAs: 'matTextareaAutosize',\n                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                host: {\n                    'class': 'cdk-textarea-autosize mat-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1',\n                    '(input)': '_noopInputHandler()'\n                }\n            }]\n    }], null, { matAutosizeMinRows: [{\n            type: Input\n        }], matAutosizeMaxRows: [{\n            type: Input\n        }], matAutosize: [{\n            type: Input,\n            args: ['mat-autosize']\n        }], matTextareaAutosize: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nconst /** @type {?} */ MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst /** @type {?} */ MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\nlet /** @type {?} */ nextUniqueId = 0;\n/**\n * \\@docs-private\n */\nclass MatInputBase {\n    /**\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} ngControl\n     */\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}\nconst /** @type {?} */ _MatInputMixinBase = mixinErrorState(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\nclass MatInput extends _MatInputMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} inputValueAccessor\n     * @param {?} _autofillMonitor\n     * @param {?} ngZone\n     */\n    constructor(_elementRef, _platform, /** @docs-private */\n    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this.ngControl = ngControl;\n        this._autofillMonitor = _autofillMonitor;\n        this._uid = `mat-input-${nextUniqueId++}`;\n        /**\n         * Whether the component is being rendered on the server.\n         */\n        this._isServer = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.stateChanges = new Subject();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.autofilled = false;\n        this._disabled = false;\n        this._required = false;\n        this._type = 'text';\n        this._readonly = false;\n        this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week'\n        ].filter(t => getSupportedInputTypes().has(t));\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;\n        this._previousNativeValue = this.value;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular(() => {\n                _elementRef.nativeElement.addEventListener('keyup', (event) => {\n                    let /** @type {?} */ el = /** @type {?} */ (event.target);\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                        // `1, 1` fixes it for the first time that you type text and\n                        // then hold delete. Toggling to `1, 1` and then back to\n                        // `0, 0` seems to completely fix it.\n                        el.setSelectionRange(1, 1);\n                        el.setSelectionRange(0, 0);\n                    }\n                });\n            });\n        }\n        this._isServer = !this._platform.isBrowser;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n            return this.ngControl.disabled;\n        }\n        return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n        if (this.focused) {\n            this.focused = false;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get id() { return this._id; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set id(value) { this._id = value || this._uid; }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) { this._required = coerceBooleanProperty(value); }\n    /**\n     * Input type of the element.\n     * @return {?}\n     */\n    get type() { return this._type; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set type(value) {\n        this._type = value || 'text';\n        this._validateType();\n        // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n            this._elementRef.nativeElement.type = this._type;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get value() { return this._inputValueAccessor.value; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) {\n        if (value !== this.value) {\n            this._inputValueAccessor.value = value;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Whether the element is readonly.\n     * @return {?}\n     */\n    get readonly() { return this._readonly; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set readonly(value) { this._readonly = coerceBooleanProperty(value); }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n            this.autofilled = event.isAutofilled;\n            this.stateChanges.next();\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        this.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.stateChanges.complete();\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n    }\n    /**\n     * Focuses the input.\n     * @return {?}\n     */\n    focus() { this._elementRef.nativeElement.focus(); }\n    /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n    _focusChanged(isFocused) {\n        if (isFocused !== this.focused && !this.readonly) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _onInput() {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @return {?}\n     */\n    _dirtyCheckNativeValue() {\n        const /** @type {?} */ newValue = this.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n    _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    }\n    /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @return {?}\n     */\n    _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /**\n     * Checks whether the input is invalid based on the native validation.\n     * @return {?}\n     */\n    _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        let /** @type {?} */ validity = (/** @type {?} */ (this._elementRef.nativeElement)).validity;\n        return validity && validity.badInput;\n    }\n    /**\n     * Determines if the component host is a textarea.\n     * @return {?}\n     */\n    _isTextarea() {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get empty() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n            !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get shouldLabelFloat() { return this.focused || !this.empty; }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    setDescribedByIds(ids) { this._ariaDescribedby = ids.join(' '); }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    onContainerClick() { this.focus(); }\n}\nMatInput.ɵfac = function MatInput_Factory(t) { return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nMatInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatInput, selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"]], hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"], hostVars: 10, hostBindings: function MatInput_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"blur\", function MatInput_blur_HostBindingHandler() { return ctx._focusChanged(false); })(\"focus\", function MatInput_focus_HostBindingHandler() { return ctx._focusChanged(true); })(\"input\", function MatInput_input_HostBindingHandler() { return ctx._onInput(); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required)(\"readonly\", ctx.readonly);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"placeholder\", ctx.placeholder)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-invalid\", ctx.errorState)(\"aria-required\", ctx.required.toString());\n        ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n    } }, inputs: { id: \"id\", disabled: \"disabled\", required: \"required\", type: \"type\", value: \"value\", readonly: \"readonly\", placeholder: \"placeholder\", errorStateMatcher: \"errorStateMatcher\" }, exportAs: [\"matInput\"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: MatFormFieldControl, useExisting: MatInput }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nMatInput.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: Platform, },\n    { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },\n    { type: NgForm, decorators: [{ type: Optional },] },\n    { type: FormGroupDirective, decorators: [{ type: Optional },] },\n    { type: ErrorStateMatcher, },\n    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] },] },\n    { type: AutofillMonitor, },\n    { type: NgZone, },\n];\nMatInput.propDecorators = {\n    \"disabled\": [{ type: Input },],\n    \"id\": [{ type: Input },],\n    \"placeholder\": [{ type: Input },],\n    \"required\": [{ type: Input },],\n    \"type\": [{ type: Input },],\n    \"errorStateMatcher\": [{ type: Input },],\n    \"value\": [{ type: Input },],\n    \"readonly\": [{ type: Input },],\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatInput, [{\n        type: Directive,\n        args: [{\n                selector: `input[matInput], textarea[matInput]`,\n                exportAs: 'matInput',\n                host: {\n                    /**\n                         * @breaking-change 7.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                         */\n                    'class': 'mat-input-element mat-form-field-autofill-control',\n                    '[class.mat-input-server]': '_isServer',\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\n                    // the native input element. Otherwise property bindings for those don't work.\n                    '[attr.id]': 'id',\n                    '[attr.placeholder]': 'placeholder',\n                    '[disabled]': 'disabled',\n                    '[required]': 'required',\n                    '[readonly]': 'readonly',\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\n                    '[attr.aria-invalid]': 'errorState',\n                    '[attr.aria-required]': 'required.toString()',\n                    '(blur)': '_focusChanged(false)',\n                    '(focus)': '_focusChanged(true)',\n                    '(input)': '_onInput()'\n                },\n                providers: [{ provide: MatFormFieldControl, useExisting: MatInput }]\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: ɵngcc2.NgControl, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }] }, { type: ɵngcc2.NgForm, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc2.FormGroupDirective, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc3.ErrorStateMatcher }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }, {\n                type: Inject,\n                args: [MAT_INPUT_VALUE_ACCESSOR]\n            }] }, { type: ɵngcc4.AutofillMonitor }, { type: ɵngcc0.NgZone }]; }, { id: [{\n            type: Input\n        }], disabled: [{\n            type: Input\n        }], required: [{\n            type: Input\n        }], type: [{\n            type: Input\n        }], value: [{\n            type: Input\n        }], readonly: [{\n            type: Input\n        }], placeholder: [{\n            type: Input\n        }], errorStateMatcher: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass MatInputModule {\n}\nMatInputModule.ɵfac = function MatInputModule_Factory(t) { return new (t || MatInputModule)(); };\nMatInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatInputModule });\nMatInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [ErrorStateMatcher], imports: [[\n            CommonModule,\n            TextFieldModule,\n            MatFormFieldModule,\n        ], TextFieldModule,\n        MatFormFieldModule] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, { declarations: function () { return [MatInput, MatTextareaAutosize]; }, imports: function () { return [CommonModule,\n        TextFieldModule,\n        MatFormFieldModule]; }, exports: function () { return [TextFieldModule,\n        MatFormFieldModule, MatInput, MatTextareaAutosize]; } }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatInputModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [MatInput, MatTextareaAutosize],\n                imports: [\n                    CommonModule,\n                    TextFieldModule,\n                    MatFormFieldModule,\n                ],\n                exports: [\n                    TextFieldModule,\n                    MatFormFieldModule,\n                    MatInput,\n                    MatTextareaAutosize,\n                ],\n                providers: [ErrorStateMatcher]\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatTextareaAutosize, MatInputBase, _MatInputMixinBase, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR };\n\n//# sourceMappingURL=input.js.map"]},"metadata":{},"sourceType":"module"}