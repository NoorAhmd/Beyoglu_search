{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\n\nvar TileCache = function (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n    LRUCache.call(this, opt_highWaterMark);\n  }\n\n  if (LRUCache) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create(LRUCache && LRUCache.prototype);\n  TileCache.prototype.constructor = TileCache;\n  /**\n   * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\n   */\n\n  TileCache.prototype.expireCache = function expireCache(usedTiles) {\n    var this$1 = this;\n\n    while (this.canExpireCache()) {\n      var tile = this$1.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this$1.pop().dispose();\n      }\n    }\n  };\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n\n\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n\n  return TileCache;\n}(LRUCache);\n\nexport default TileCache; //# sourceMappingURL=TileCache.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/TileCache.js"],"names":["LRUCache","fromKey","getKey","TileCache","opt_highWaterMark","call","__proto__","prototype","Object","create","constructor","expireCache","usedTiles","this$1","canExpireCache","tile","peekLast","zKey","tileCoord","toString","contains","pop","dispose","pruneExceptNewestZ","getCount","key","peekFirstKey","z","forEach","remove"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAP,MAAqB,uBAArB;AACA,SAAQC,OAAR,EAAiBC,MAAjB,QAA8B,gBAA9B;;AAEA,IAAIC,SAAS,GAAI,UAAUH,QAAV,EAAoB;AACnC,WAASG,SAAT,CAAmBC,iBAAnB,EAAsC;AAEpCJ,IAAAA,QAAQ,CAACK,IAAT,CAAc,IAAd,EAAoBD,iBAApB;AAED;;AAED,MAAKJ,QAAL,EAAgBG,SAAS,CAACG,SAAV,GAAsBN,QAAtB;AAChBG,EAAAA,SAAS,CAACI,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAeT,QAAQ,IAAIA,QAAQ,CAACO,SAApC,CAAtB;AACAJ,EAAAA,SAAS,CAACI,SAAV,CAAoBG,WAApB,GAAkCP,SAAlC;AAEA;AACF;AACA;;AACEA,EAAAA,SAAS,CAACI,SAAV,CAAoBI,WAApB,GAAkC,SAASA,WAAT,CAAsBC,SAAtB,EAAiC;AACjE,QAAIC,MAAM,GAAG,IAAb;;AAEA,WAAO,KAAKC,cAAL,EAAP,EAA8B;AAC5B,UAAIC,IAAI,GAAGF,MAAM,CAACG,QAAP,EAAX;AACA,UAAIC,IAAI,GAAGF,IAAI,CAACG,SAAL,CAAe,CAAf,EAAkBC,QAAlB,EAAX;;AACA,UAAIF,IAAI,IAAIL,SAAR,IAAqBA,SAAS,CAACK,IAAD,CAAT,CAAgBG,QAAhB,CAAyBL,IAAI,CAACG,SAA9B,CAAzB,EAAmE;AACjE;AACD,OAFD,MAEO;AACLL,QAAAA,MAAM,CAACQ,GAAP,GAAaC,OAAb;AACD;AACF;AACF,GAZD;AAcA;AACF;AACA;;;AACEnB,EAAAA,SAAS,CAACI,SAAV,CAAoBgB,kBAApB,GAAyC,SAASA,kBAAT,GAA+B;AACtE,QAAI,KAAKC,QAAL,OAAoB,CAAxB,EAA2B;AACzB;AACD;;AACD,QAAIC,GAAG,GAAG,KAAKC,YAAL,EAAV;AACA,QAAIR,SAAS,GAAGjB,OAAO,CAACwB,GAAD,CAAvB;AACA,QAAIE,CAAC,GAAGT,SAAS,CAAC,CAAD,CAAjB;AACA,SAAKU,OAAL,CAAa,UAASb,IAAT,EAAe;AAC1B,UAAIA,IAAI,CAACG,SAAL,CAAe,CAAf,MAAsBS,CAA1B,EAA6B;AAC3B,aAAKE,MAAL,CAAY3B,MAAM,CAACa,IAAI,CAACG,SAAN,CAAlB;AACAH,QAAAA,IAAI,CAACO,OAAL;AACD;AACF,KALD,EAKG,IALH;AAMD,GAbD;;AAeA,SAAOnB,SAAP;AACD,CA/CgB,CA+CfH,QA/Ce,CAAjB;;AAkDA,eAAeG,SAAf,C,CAEA","sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nvar TileCache = (function (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n\n    LRUCache.call(this, opt_highWaterMark);\n\n  }\n\n  if ( LRUCache ) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );\n  TileCache.prototype.constructor = TileCache;\n\n  /**\n   * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\n   */\n  TileCache.prototype.expireCache = function expireCache (usedTiles) {\n    var this$1 = this;\n\n    while (this.canExpireCache()) {\n      var tile = this$1.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this$1.pop().dispose();\n      }\n    }\n  };\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {\n    if (this.getCount() === 0) {\n      return;\n    }\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function(tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n\n  return TileCache;\n}(LRUCache));\n\n\nexport default TileCache;\n\n//# sourceMappingURL=TileCache.js.map"]},"metadata":{},"sourceType":"module"}