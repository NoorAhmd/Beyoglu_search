{"ast":null,"code":"/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport { createEmpty, getHeight, returnOrUpdate } from '../extent.js';\nimport { FALSE } from '../functions.js';\nimport { transform2D } from '../geom/flat/transform.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport Units from '../proj/Units.js';\nimport { create as createTransform, compose as composeTransform } from '../transform.js';\n/**\n * @type {module:ol/transform~Transform}\n */\n\nvar tmpTransform = createTransform();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\n\nvar Geometry = function (BaseObject) {\n  function Geometry() {\n    BaseObject.call(this);\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.extent_ = createEmpty();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.extentRevision_ = -1;\n    /**\n     * @protected\n     * @type {Object.<string, module:ol/geom/Geometry>}\n     */\n\n    this.simplifiedGeometryCache = {};\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.simplifiedGeometryRevision = 0;\n  }\n\n  if (BaseObject) Geometry.__proto__ = BaseObject;\n  Geometry.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Geometry.prototype.constructor = Geometry;\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!module:ol/geom/Geometry} Clone.\n   */\n\n  Geometry.prototype.clone = function clone() {};\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {module:ol/coordinate~Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  Geometry.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {};\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {module:ol/coordinate~Coordinate} point Point.\n   * @param {module:ol/coordinate~Coordinate=} opt_closestPoint Closest point.\n   * @return {module:ol/coordinate~Coordinate} Closest point.\n   * @api\n   */\n\n\n  Geometry.prototype.getClosestPoint = function getClosestPoint(point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n\n\n  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n  /**\n   * @abstract\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @protected\n   * @return {module:ol/extent~Extent} extent Extent.\n   */\n\n\n  Geometry.prototype.computeExtent = function computeExtent(extent) {};\n  /**\n   * Get the extent of the geometry.\n   * @param {module:ol/extent~Extent=} opt_extent Extent.\n   * @return {module:ol/extent~Extent} extent Extent.\n   * @api\n   */\n\n\n  Geometry.prototype.getExtent = function getExtent(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {module:ol/coordinate~Coordinate} anchor The rotation center.\n   * @api\n   */\n\n\n  Geometry.prototype.rotate = function rotate(angle, anchor) {};\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {module:ol/coordinate~Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n\n\n  Geometry.prototype.scale = function scale(sx, opt_sy, opt_anchor) {};\n  /**\n   * Translate the geometry. This modifies the geometry coordinates in place.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n\n\n  Geometry.prototype.translate = function translate(deltaX, deltaY) {};\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @function\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {module:ol/geom/Geometry} A new, simplified version of the original\n   *     geometry.\n   * @api\n   */\n\n\n  Geometry.prototype.simplify = function simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {module:ol/geom/Geometry} Simplified geometry.\n   */\n\n\n  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {};\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {module:ol/geom/GeometryType} Geometry type.\n   */\n\n\n  Geometry.prototype.getType = function getType() {};\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {module:ol/proj~TransformFunction} transformFn Transform.\n   */\n\n\n  Geometry.prototype.applyTransform = function applyTransform(transformFn) {};\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n\n\n  Geometry.prototype.intersectsExtent = function intersectsExtent(extent) {};\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   */\n\n\n  Geometry.prototype.translate = function translate(deltaX, deltaY) {};\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {module:ol/geom/Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n\n\n  Geometry.prototype.transform = function transform(source, destination) {\n    source = getProjection(source);\n    var transformFn = source.getUnits() == Units.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n      var pixelExtent = source.getExtent();\n      var projectedExtent = source.getWorldExtent();\n      var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n      return getTransform(source, destination)(inCoordinates, outCoordinates, stride);\n    } : getTransform(source, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n\n  return Geometry;\n}(BaseObject);\n/**\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n\n\nGeometry.prototype.containsXY = FALSE;\nexport default Geometry; //# sourceMappingURL=Geometry.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/geom/Geometry.js"],"names":["BaseObject","createEmpty","getHeight","returnOrUpdate","FALSE","transform2D","get","getProjection","getTransform","Units","create","createTransform","compose","composeTransform","tmpTransform","Geometry","call","extent_","extentRevision_","simplifiedGeometryCache","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","__proto__","prototype","Object","constructor","clone","closestPointXY","x","y","closestPoint","minSquaredDistance","getClosestPoint","point","opt_closestPoint","NaN","Infinity","intersectsCoordinate","coordinate","containsXY","computeExtent","extent","getExtent","opt_extent","getRevision","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","translate","deltaX","deltaY","simplify","tolerance","getSimplifiedGeometry","squaredTolerance","getType","applyTransform","transformFn","intersectsExtent","transform","source","destination","getUnits","TILE_PIXELS","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","length"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport {createEmpty, getHeight, returnOrUpdate} from '../extent.js';\nimport {FALSE} from '../functions.js';\nimport {transform2D} from '../geom/flat/transform.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport Units from '../proj/Units.js';\nimport {create as createTransform, compose as composeTransform} from '../transform.js';\n\n\n/**\n * @type {module:ol/transform~Transform}\n */\nvar tmpTransform = createTransform();\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = (function (BaseObject) {\n  function Geometry() {\n\n    BaseObject.call(this);\n\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {Object.<string, module:ol/geom/Geometry>}\n     */\n    this.simplifiedGeometryCache = {};\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n  }\n\n  if ( BaseObject ) Geometry.__proto__ = BaseObject;\n  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );\n  Geometry.prototype.constructor = Geometry;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!module:ol/geom/Geometry} Clone.\n   */\n  Geometry.prototype.clone = function clone () {};\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {module:ol/coordinate~Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {};\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {module:ol/coordinate~Coordinate} point Point.\n   * @param {module:ol/coordinate~Coordinate=} opt_closestPoint Closest point.\n   * @return {module:ol/coordinate~Coordinate} Closest point.\n   * @api\n   */\n  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n\n  /**\n   * @abstract\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @protected\n   * @return {module:ol/extent~Extent} extent Extent.\n   */\n  Geometry.prototype.computeExtent = function computeExtent (extent) {};\n\n  /**\n   * Get the extent of the geometry.\n   * @param {module:ol/extent~Extent=} opt_extent Extent.\n   * @return {module:ol/extent~Extent} extent Extent.\n   * @api\n   */\n  Geometry.prototype.getExtent = function getExtent (opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {module:ol/coordinate~Coordinate} anchor The rotation center.\n   * @api\n   */\n  Geometry.prototype.rotate = function rotate (angle, anchor) {};\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {module:ol/coordinate~Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {};\n\n  /**\n   * Translate the geometry. This modifies the geometry coordinates in place.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  Geometry.prototype.translate = function translate (deltaX, deltaY) {};\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @function\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {module:ol/geom/Geometry} A new, simplified version of the original\n   *     geometry.\n   * @api\n   */\n  Geometry.prototype.simplify = function simplify (tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {module:ol/geom/Geometry} Simplified geometry.\n   */\n  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {};\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {module:ol/geom/GeometryType} Geometry type.\n   */\n  Geometry.prototype.getType = function getType () {};\n\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {module:ol/proj~TransformFunction} transformFn Transform.\n   */\n  Geometry.prototype.applyTransform = function applyTransform (transformFn) {};\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {};\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   */\n  Geometry.prototype.translate = function translate (deltaX, deltaY) {};\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {module:ol/geom/Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  Geometry.prototype.transform = function transform (source, destination) {\n    source = getProjection(source);\n    var transformFn = source.getUnits() == Units.TILE_PIXELS ?\n      function(inCoordinates, outCoordinates, stride) {\n        var pixelExtent = source.getExtent();\n        var projectedExtent = source.getWorldExtent();\n        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform,\n          projectedExtent[0], projectedExtent[3],\n          scale, -scale, 0,\n          0, 0);\n        transform2D(inCoordinates, 0, inCoordinates.length, stride,\n          tmpTransform, outCoordinates);\n        return getTransform(source, destination)(inCoordinates, outCoordinates, stride);\n      } :\n      getTransform(source, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n\n  return Geometry;\n}(BaseObject));\n\n\n/**\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nGeometry.prototype.containsXY = FALSE;\n\n\nexport default Geometry;\n\n//# sourceMappingURL=Geometry.js.map"]},"metadata":{},"sourceType":"module"}