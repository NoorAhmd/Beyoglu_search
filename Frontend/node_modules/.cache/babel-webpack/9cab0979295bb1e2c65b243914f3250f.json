{"ast":null,"code":"/**\n * @module ol/View\n */\nimport { DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { getUid } from './util.js';\nimport { UNDEFINED } from './functions.js';\nimport { createExtent, none as centerNone } from './centerconstraint.js';\nimport BaseObject from './Object.js';\nimport { createSnapToResolutions, createSnapToPower } from './resolutionconstraint.js';\nimport { createSnapToZero, createSnapToN, none as rotationNone, disable } from './rotationconstraint.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport { linearFindNearest } from './array.js';\nimport { assert } from './asserts.js';\nimport { add as addCoordinate, rotate as rotateCoordinate, equals as coordinatesEqual } from './coordinate.js';\nimport { inAndOut } from './easing.js';\nimport { getForViewAndSize, getCenter, getHeight, getWidth, isEmpty } from './extent.js';\nimport GeometryType from './geom/GeometryType.js';\nimport { fromExtent as polygonFromExtent } from './geom/Polygon.js';\nimport SimpleGeometry from './geom/SimpleGeometry.js';\nimport { clamp, modulo } from './math.js';\nimport { assign } from './obj.js';\nimport { createProjection, METERS_PER_UNIT } from './proj.js';\nimport Units from './proj/Units.js';\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {module:ol/coordinate~Coordinate} [sourceCenter]\n * @property {module:ol/coordinate~Coordinate} [targetCenter]\n * @property {number} [sourceResolution]\n * @property {number} [targetResolution]\n * @property {number} [sourceRotation]\n * @property {number} [targetRotation]\n * @property {module:ol/coordinate~Coordinate} [anchor]\n * @property {number} start\n * @property {number} duration\n * @property {boolean} complete\n * @property {function(number):number} easing\n * @property {function(boolean)} callback\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {module:ol/centerconstraint~Type} center\n * @property {module:ol/resolutionconstraint~Type} resolution\n * @property {module:ol/rotationconstraint~Type} rotation\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {module:ol/size~Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array.<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [constrainResolution=true] Constrain the resolution.\n * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get\n * the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean)} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {module:ol/coordinate~Coordinate} [center] The initial center for\n * the view. The coordinate system for the center is specified with the\n * `projection` option. Layer sources will not be fetched if this is not set,\n * but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {module:ol/extent~Extent} [extent] The extent that constrains the\n * center, in other words, center cannot be set outside this extent.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array.<number>} [resolutions] Resolutions to determine the\n * resolution constraint. If set the `maxResolution`, `minResolution`,\n * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view. The initial\n * resolution is determined using the {@link #constrainResolution} method.\n * @property {number} [zoomFactor=2] The zoom factor used to determine the\n * resolution constraint.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {module:ol/coordinate~Coordinate|undefined} center The center of the view at the end of\n * the animation.\n * @property {number|undefined} zoom The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number|undefined} resolution The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number|undefined} rotation The rotation of the view at the end of\n * the animation.\n * @property {module:ol/coordinate~Coordinate|undefined} anchor Optional anchor to remained fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {module:ol/coordinate~Coordinate} center\n * @property {module:ol/proj/Projection} projection\n * @property {number} resolution\n * @property {number} rotation\n * @property {number} zoom\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\n\nvar DEFAULT_MIN_ZOOM = 0;\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * ### The view states\n *\n * An View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * An View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Spherical Mercator (EPSG:3857).\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view. Any value can be passed to the setters. And the value\n * that is passed to a setter will effectively be the value set in the view,\n * and returned by the corresponding getter.\n *\n * But a View object also has a *resolution constraint*, a\n * *rotation constraint* and a *center constraint*.\n *\n * As said above, no constraints are applied when the setters are used to set\n * new states for the view. Applying constraints is done explicitly through\n * the use of the `constrain*` functions (`constrainResolution` and\n * `constrainRotation` and `constrainCenter`).\n *\n * The main users of the constraints are the interactions and the\n * controls. For example, double-clicking on the map changes the view to\n * the \"next\" resolution. And releasing the fingers after pinch-zooming\n * snaps to the closest resolution (with an animation).\n *\n * The *resolution constraint* snaps to specific resolutions. It is\n * determined by the following options: `resolutions`, `maxResolution`,\n * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\n * options are ignored. See documentation for each option for more\n * information.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default the rotation value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the center is not constrained at all.\n *\n  * @api\n */\n\nvar View = function (BaseObject) {\n  function View(opt_options) {\n    BaseObject.call(this);\n    var options = assign({}, opt_options);\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this.hints_ = [0, 0];\n    /**\n     * @private\n     * @type {Array.<Array.<module:ol/View~Animation>>}\n     */\n\n    this.animations_ = [];\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.updateAnimationKey_;\n    this.updateAnimations_ = this.updateAnimations_.bind(this);\n    /**\n     * @private\n     * @const\n     * @type {module:ol/proj/Projection}\n     */\n\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n    this.applyOptions_(options);\n  }\n\n  if (BaseObject) View.__proto__ = BaseObject;\n  View.prototype = Object.create(BaseObject && BaseObject.prototype);\n  View.prototype.constructor = View;\n  /**\n   * Set up the view with the given options.\n   * @param {module:ol/View~ViewOptions} options View options.\n   */\n\n  View.prototype.applyOptions_ = function applyOptions_(options) {\n    /**\n     * @type {Object.<string, *>}\n     */\n    var properties = {};\n    properties[ViewProperty.CENTER] = options.center !== undefined ? options.center : null;\n    var resolutionConstraintInfo = createResolutionConstraint(options);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n    /**\n     * @private\n     * @type {Array.<number>|undefined}\n     */\n\n    this.resolutions_ = options.resolutions;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n    var centerConstraint = createCenterConstraint(options);\n    var resolutionConstraint = resolutionConstraintInfo.constraint;\n    var rotationConstraint = createRotationConstraint(options);\n    /**\n     * @private\n     * @type {module:ol/View~Constraints}\n     */\n\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n\n    if (options.resolution !== undefined) {\n      properties[ViewProperty.RESOLUTION] = options.resolution;\n    } else if (options.zoom !== undefined) {\n      properties[ViewProperty.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);\n\n      if (this.resolutions_) {\n        // in case map zoom is out of min/max zoom range\n        properties[ViewProperty.RESOLUTION] = clamp(Number(this.getResolution() || properties[ViewProperty.RESOLUTION]), this.minResolution_, this.maxResolution_);\n      }\n    }\n\n    properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;\n    this.setProperties(properties);\n    /**\n     * @private\n     * @type {module:ol/View~ViewOptions}\n     */\n\n    this.options_ = options;\n  };\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {module:ol/View~ViewOptions} newOptions New options to be applied.\n   * @return {module:ol/View~ViewOptions} New options updated with the current view state.\n   */\n\n\n  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_(newOptions) {\n    var options = assign({}, this.options_); // preserve resolution (or zoom)\n\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    } // preserve center\n\n\n    options.center = this.getCenter(); // preserve rotation\n\n    options.rotation = this.getRotation();\n    return assign({}, options, newOptions);\n  };\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(module:ol/View~AnimationOptions|function(boolean))} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n\n\n  View.prototype.animate = function animate(var_args) {\n    var arguments$1 = arguments;\n    var this$1 = this;\n    var animationCount = arguments.length;\n    var callback;\n\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    if (!this.isDef()) {\n      // if view properties are not yet set, shortcut to the final state\n      var state = arguments[animationCount - 1];\n\n      if (state.center) {\n        this.setCenter(state.center);\n      }\n\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      }\n\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n\n      if (callback) {\n        setTimeout(function () {\n          callback(true);\n        }, 0);\n      }\n\n      return;\n    }\n\n    var start = Date.now();\n    var center = this.getCenter().slice();\n    var resolution = this.getResolution();\n    var rotation = this.getRotation();\n    var series = [];\n\n    for (var i = 0; i < animationCount; ++i) {\n      var options =\n      /** @type {module:ol/View~AnimationOptions} */\n      arguments$1[i];\n      var animation =\n      /** @type {module:ol/View~Animation} */\n      {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center;\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this$1.constrainResolution(this$1.maxResolution_, options.zoom - this$1.minZoom_, 0);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      animation.callback = callback; // check if animation is a no-op\n\n      if (isNoopAnimation(animation)) {\n        animation.complete = true; // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n\n      series.push(animation);\n    }\n\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  };\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n\n\n  View.prototype.getAnimating = function getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  };\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n\n\n  View.prototype.getInteracting = function getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  };\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n\n\n  View.prototype.cancelAnimations = function cancelAnimations() {\n    var this$1 = this;\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n\n    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n      var series = this$1.animations_[i];\n\n      if (series[0].callback) {\n        series[0].callback(false);\n      }\n    }\n\n    this.animations_.length = 0;\n  };\n  /**\n   * Update all animations.\n   */\n\n\n  View.prototype.updateAnimations_ = function updateAnimations_() {\n    var this$1 = this;\n\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n\n    if (!this.getAnimating()) {\n      return;\n    }\n\n    var now = Date.now();\n    var more = false;\n\n    for (var i = this.animations_.length - 1; i >= 0; --i) {\n      var series = this$1.animations_[i];\n      var seriesComplete = true;\n\n      for (var j = 0, jj = series.length; j < jj; ++j) {\n        var animation = series[j];\n\n        if (animation.complete) {\n          continue;\n        }\n\n        var elapsed = now - animation.start;\n        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n\n        var progress = animation.easing(fraction);\n\n        if (animation.sourceCenter) {\n          var x0 = animation.sourceCenter[0];\n          var y0 = animation.sourceCenter[1];\n          var x1 = animation.targetCenter[0];\n          var y1 = animation.targetCenter[1];\n          var x = x0 + progress * (x1 - x0);\n          var y = y0 + progress * (y1 - y0);\n          this$1.set(ViewProperty.CENTER, [x, y]);\n        }\n\n        if (animation.sourceResolution && animation.targetResolution) {\n          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n\n          if (animation.anchor) {\n            this$1.set(ViewProperty.CENTER, this$1.calculateCenterZoom(resolution, animation.anchor));\n          }\n\n          this$1.set(ViewProperty.RESOLUTION, resolution);\n        }\n\n        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n          var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n\n          if (animation.anchor) {\n            this$1.set(ViewProperty.CENTER, this$1.calculateCenterRotate(rotation, animation.anchor));\n          }\n\n          this$1.set(ViewProperty.ROTATION, rotation);\n        }\n\n        more = true;\n\n        if (!animation.complete) {\n          break;\n        }\n      }\n\n      if (seriesComplete) {\n        this$1.animations_[i] = null;\n        this$1.setHint(ViewHint.ANIMATING, -1);\n        var callback = series[0].callback;\n\n        if (callback) {\n          setTimeout(function () {\n            callback(true);\n          }, 0);\n        }\n      }\n    } // prune completed series\n\n\n    this.animations_ = this.animations_.filter(Boolean);\n\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\n    }\n  };\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {module:ol/coordinate~Coordinate} anchor Rotation anchor.\n   * @return {module:ol/coordinate~Coordinate|undefined} Center for rotation and anchor.\n   */\n\n\n  View.prototype.calculateCenterRotate = function calculateCenterRotate(rotation, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n\n    return center;\n  };\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {module:ol/coordinate~Coordinate} anchor Zoom anchor.\n   * @return {module:ol/coordinate~Coordinate|undefined} Center for resolution and anchor.\n   */\n\n\n  View.prototype.calculateCenterZoom = function calculateCenterZoom(resolution, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    var currentResolution = this.getResolution();\n\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x, y];\n    }\n\n    return center;\n  };\n  /**\n   * @private\n   * @return {module:ol/size~Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n\n\n  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_() {\n    var size = [100, 100];\n    var selector = '.ol-viewport[data-view=\"' + getUid(this) + '\"]';\n    var element = document.querySelector(selector);\n\n    if (element) {\n      var metrics = getComputedStyle(element);\n      size[0] = parseInt(metrics.width, 10);\n      size[1] = parseInt(metrics.height, 10);\n    }\n\n    return size;\n  };\n  /**\n   * Get the constrained center of this view.\n   * @param {module:ol/coordinate~Coordinate|undefined} center Center.\n   * @return {module:ol/coordinate~Coordinate|undefined} Constrained center.\n   * @api\n   */\n\n\n  View.prototype.constrainCenter = function constrainCenter(center) {\n    return this.constraints_.center(center);\n  };\n  /**\n   * Get the constrained resolution of this view.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @param {number=} opt_direction Direction. Default is `0`.\n   * @return {number|undefined} Constrained resolution.\n   * @api\n   */\n\n\n  View.prototype.constrainResolution = function constrainResolution(resolution, opt_delta, opt_direction) {\n    var delta = opt_delta || 0;\n    var direction = opt_direction || 0;\n    return this.constraints_.resolution(resolution, delta, direction);\n  };\n  /**\n   * Get the constrained rotation of this view.\n   * @param {number|undefined} rotation Rotation.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @return {number|undefined} Constrained rotation.\n   * @api\n   */\n\n\n  View.prototype.constrainRotation = function constrainRotation(rotation, opt_delta) {\n    var delta = opt_delta || 0;\n    return this.constraints_.rotation(rotation, delta);\n  };\n  /**\n   * Get the view center.\n   * @return {module:ol/coordinate~Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getCenter = function getCenter() {\n    return (\n      /** @type {module:ol/coordinate~Coordinate|undefined} */\n      this.get(ViewProperty.CENTER)\n    );\n  };\n  /**\n   * @return {module:ol/View~Constraints} Constraints.\n   */\n\n\n  View.prototype.getConstraints = function getConstraints() {\n    return this.constraints_;\n  };\n  /**\n   * @param {Array.<number>=} opt_hints Destination array.\n   * @return {Array.<number>} Hint.\n   */\n\n\n  View.prototype.getHints = function getHints(opt_hints) {\n    if (opt_hints !== undefined) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  };\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {module:ol/size~Size=} opt_size Box pixel size. If not provided, the size of the\n   * first map that uses this view will be used.\n   * @return {module:ol/extent~Extent} Extent.\n   * @api\n   */\n\n\n  View.prototype.calculateExtent = function calculateExtent(opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var center =\n    /** @type {!module:ol/coordinate~Coordinate} */\n    this.getCenter();\n    assert(center, 1); // The view center is not defined\n\n    var resolution =\n    /** @type {!number} */\n    this.getResolution();\n    assert(resolution !== undefined, 2); // The view resolution is not defined\n\n    var rotation =\n    /** @type {!number} */\n    this.getRotation();\n    assert(rotation !== undefined, 3); // The view rotation is not defined\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  };\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n\n\n  View.prototype.getMaxResolution = function getMaxResolution() {\n    return this.maxResolution_;\n  };\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n\n\n  View.prototype.getMinResolution = function getMinResolution() {\n    return this.minResolution_;\n  };\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n\n\n  View.prototype.getMaxZoom = function getMaxZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.minResolution_)\n    );\n  };\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n\n\n  View.prototype.setMaxZoom = function setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      maxZoom: zoom\n    }));\n  };\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n\n\n  View.prototype.getMinZoom = function getMinZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  };\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n\n\n  View.prototype.setMinZoom = function setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      minZoom: zoom\n    }));\n  };\n  /**\n   * Get the view projection.\n   * @return {module:ol/proj/Projection} The projection of the view.\n   * @api\n   */\n\n\n  View.prototype.getProjection = function getProjection() {\n    return this.projection_;\n  };\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getResolution = function getResolution() {\n    return (\n      /** @type {number|undefined} */\n      this.get(ViewProperty.RESOLUTION)\n    );\n  };\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array.<number>|undefined} The resolutions of the view.\n   * @api\n   */\n\n\n  View.prototype.getResolutions = function getResolutions() {\n    return this.resolutions_;\n  };\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {module:ol/size~Size=} opt_size Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n\n\n  View.prototype.getResolutionForExtent = function getResolutionForExtent(extent, opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var xResolution = getWidth(extent) / size[0];\n    var yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  };\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n\n\n  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        var resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  };\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getRotation = function getRotation() {\n    return (\n      /** @type {number} */\n      this.get(ViewProperty.ROTATION)\n    );\n  };\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n\n\n  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        var value = Math.log(maxResolution / resolution) / Math.log(power) / max;\n        return value;\n      }\n    );\n  };\n  /**\n   * @return {module:ol/View~State} View state.\n   */\n\n\n  View.prototype.getState = function getState() {\n    var center =\n    /** @type {module:ol/coordinate~Coordinate} */\n    this.getCenter();\n    var projection = this.getProjection();\n    var resolution =\n    /** @type {number} */\n    this.getResolution();\n    var rotation = this.getRotation();\n    return (\n      /** @type {module:ol/View~State} */\n      {\n        center: center.slice(),\n        projection: projection !== undefined ? projection : null,\n        resolution: resolution,\n        rotation: rotation,\n        zoom: this.getZoom()\n      }\n    );\n  };\n  /**\n   * Get the current zoom level.  If you configured your view with a resolutions\n   * array (this is rare), this method may return non-integer zoom levels (so\n   * the zoom level is not safe to use as an index into a resolutions array).\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n\n\n  View.prototype.getZoom = function getZoom() {\n    var zoom;\n    var resolution = this.getResolution();\n\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n\n    return zoom;\n  };\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n\n\n  View.prototype.getZoomForResolution = function getZoomForResolution(resolution) {\n    var offset = this.minZoom_ || 0;\n    var max, zoomFactor;\n\n    if (this.resolutions_) {\n      var nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  };\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n\n\n  View.prototype.getResolutionForZoom = function getResolutionForZoom(zoom) {\n    return (\n      /** @type {number} */\n      this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)\n    );\n  };\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {module:ol/geom/SimpleGeometry|module:ol/extent~Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {module:ol/View~FitOptions=} opt_options Options.\n   * @api\n   */\n\n\n  View.prototype.fit = function fit(geometryOrExtent, opt_options) {\n    var options = opt_options || {};\n    var size = options.size;\n\n    if (!size) {\n      size = this.getSizeFromViewport_();\n    }\n    /** @type {module:ol/geom/SimpleGeometry} */\n\n\n    var geometry;\n\n    if (!(geometryOrExtent instanceof SimpleGeometry)) {\n      assert(Array.isArray(geometryOrExtent), 24); // Invalid extent or geometry provided as `geometry`\n\n      assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n\n      geometry = polygonFromExtent(geometryOrExtent);\n    } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n      geometryOrExtent = geometryOrExtent.getExtent();\n      geometry = polygonFromExtent(geometryOrExtent);\n      geometry.rotate(this.getRotation(), getCenter(geometryOrExtent));\n    } else {\n      geometry = geometryOrExtent;\n    }\n\n    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;\n    var nearest = options.nearest !== undefined ? options.nearest : false;\n    var minResolution;\n\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);\n    } else {\n      minResolution = 0;\n    }\n\n    var coords = geometry.getFlatCoordinates(); // calculate rotated extent\n\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var minRotX = +Infinity;\n    var minRotY = +Infinity;\n    var maxRotX = -Infinity;\n    var maxRotY = -Infinity;\n    var stride = geometry.getStride();\n\n    for (var i = 0, ii = coords.length; i < ii; i += stride) {\n      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    } // calculate resolution\n\n\n    var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);\n\n    if (constrainResolution) {\n      var constrainedResolution = this.constrainResolution(resolution, 0, 0);\n\n      if (!nearest && constrainedResolution < resolution) {\n        constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);\n      }\n\n      resolution = constrainedResolution;\n    } // calculate center\n\n\n    sinAngle = -sinAngle; // go back to original rotation\n\n    var centerRotX = (minRotX + maxRotX) / 2;\n    var centerRotY = (minRotY + maxRotY) / 2;\n    centerRotX += (padding[1] - padding[3]) / 2 * resolution;\n    centerRotY += (padding[0] - padding[2]) / 2 * resolution;\n    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;\n    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;\n    var center = [centerX, centerY];\n    var callback = options.callback ? options.callback : UNDEFINED;\n\n    if (options.duration !== undefined) {\n      this.animate({\n        resolution: resolution,\n        center: center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.setResolution(resolution);\n      this.setCenter(center);\n      setTimeout(callback.bind(undefined, true), 0);\n    }\n  };\n  /**\n   * Center on coordinate and view position.\n   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n   * @param {module:ol/size~Size} size Box pixel size.\n   * @param {module:ol/pixel~Pixel} position Position on the view to center on.\n   * @api\n   */\n\n\n  View.prototype.centerOn = function centerOn(coordinate, size, position) {\n    // calculate rotated position\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    var resolution = this.getResolution();\n    rotX += (size[0] / 2 - position[0]) * resolution;\n    rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle\n\n    sinAngle = -sinAngle; // go back to original rotation\n\n    var centerX = rotX * cosAngle - rotY * sinAngle;\n    var centerY = rotY * cosAngle + rotX * sinAngle;\n    this.setCenter([centerX, centerY]);\n  };\n  /**\n   * @return {boolean} Is defined.\n   */\n\n\n  View.prototype.isDef = function isDef() {\n    return !!this.getCenter() && this.getResolution() !== undefined;\n  };\n  /**\n   * Rotate the view around a given coordinate.\n   * @param {number} rotation New rotation value for the view.\n   * @param {module:ol/coordinate~Coordinate=} opt_anchor The rotation center.\n   * @api\n   */\n\n\n  View.prototype.rotate = function rotate(rotation, opt_anchor) {\n    if (opt_anchor !== undefined) {\n      var center = this.calculateCenterRotate(rotation, opt_anchor);\n      this.setCenter(center);\n    }\n\n    this.setRotation(rotation);\n  };\n  /**\n   * Set the center of the current view.\n   * @param {module:ol/coordinate~Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setCenter = function setCenter(center) {\n    this.set(ViewProperty.CENTER, center);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * @param {module:ol/ViewHint} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n\n\n  View.prototype.setHint = function setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  };\n  /**\n   * Set the resolution for this view.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setResolution = function setResolution(resolution) {\n    this.set(ViewProperty.RESOLUTION, resolution);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * Set the rotation for this view.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setRotation = function setRotation(rotation) {\n    this.set(ViewProperty.ROTATION, rotation);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * Zoom to a specific zoom level.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n\n\n  View.prototype.setZoom = function setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  };\n\n  return View;\n}(BaseObject);\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {module:ol/centerconstraint~Type} The constraint.\n */\n\n\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    return createExtent(options.extent);\n  } else {\n    return centerNone;\n  }\n}\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {{constraint: module:ol/resolutionconstraint~Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\n\nexport function createResolutionConstraint(options) {\n  var resolutionConstraint;\n  var maxResolution;\n  var minResolution; // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n\n  var defaultMaxZoom = 28;\n  var defaultZoomFactor = 2;\n  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  if (options.resolutions !== undefined) {\n    var resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];\n    resolutionConstraint = createSnapToResolutions(resolutions);\n  } else {\n    // calculate the default min and max resolution\n    var projection = createProjection(options.projection, 'EPSG:3857');\n    var extent = projection.getExtent();\n    var size = !extent ? // use an extent that can fit the whole world if need be\n    360 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(extent), getHeight(extent));\n    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence\n\n    maxResolution = options.maxResolution;\n\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    } // user provided minResolution takes precedence\n\n\n    minResolution = options.minResolution;\n\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    } // given discrete zoom levels, minResolution may be different than provided\n\n\n    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n    resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);\n  }\n\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor\n  };\n}\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {module:ol/rotationconstraint~Type} Rotation constraint.\n */\n\nexport function createRotationConstraint(options) {\n  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;\n\n  if (enableRotation) {\n    var constrainRotation = options.constrainRotation;\n\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationNone;\n    } else if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationNone;\n    }\n  } else {\n    return disable;\n  }\n}\n/**\n * Determine if an animation involves no view change.\n * @param {module:ol/View~Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\n\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n\n  return true;\n}\nexport default View; //# sourceMappingURL=View.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/View.js"],"names":["DEFAULT_TILE_SIZE","getUid","UNDEFINED","createExtent","none","centerNone","BaseObject","createSnapToResolutions","createSnapToPower","createSnapToZero","createSnapToN","rotationNone","disable","ViewHint","ViewProperty","linearFindNearest","assert","add","addCoordinate","rotate","rotateCoordinate","equals","coordinatesEqual","inAndOut","getForViewAndSize","getCenter","getHeight","getWidth","isEmpty","GeometryType","fromExtent","polygonFromExtent","SimpleGeometry","clamp","modulo","assign","createProjection","METERS_PER_UNIT","Units","DEFAULT_MIN_ZOOM","View","opt_options","call","options","hints_","animations_","updateAnimationKey_","updateAnimations_","bind","projection_","projection","applyOptions_","__proto__","prototype","Object","create","constructor","properties","CENTER","center","undefined","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","maxResolution","minResolution_","minResolution","zoomFactor_","zoomFactor","resolutions_","resolutions","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","resolution","rotation","RESOLUTION","zoom","constrainResolution","Number","getResolution","ROTATION","setProperties","options_","getUpdatedOptions_","newOptions","getZoom","getRotation","animate","var_args","arguments$1","arguments","this$1","animationCount","length","callback","isDef","state","setCenter","setZoom","setRotation","setTimeout","start","Date","now","slice","series","i","animation","complete","anchor","duration","easing","sourceCenter","targetCenter","sourceResolution","targetResolution","sourceRotation","delta","Math","PI","targetRotation","isNoopAnimation","push","setHint","ANIMATING","getAnimating","getInteracting","INTERACTING","cancelAnimations","ii","cancelAnimationFrame","more","seriesComplete","j","jj","elapsed","fraction","progress","x0","y0","x1","y1","x","y","set","calculateCenterZoom","calculateCenterRotate","filter","Boolean","requestAnimationFrame","currentCenter","currentResolution","getSizeFromViewport_","size","selector","element","document","querySelector","metrics","getComputedStyle","parseInt","width","height","constrainCenter","opt_delta","opt_direction","direction","constrainRotation","get","getConstraints","getHints","opt_hints","calculateExtent","opt_size","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","getProjection","getResolutions","getResolutionForExtent","extent","xResolution","yResolution","max","getResolutionForValueFunction","opt_power","power","log","value","pow","getValueForResolutionFunction","getState","offset","nearest","getResolutionForZoom","fit","geometryOrExtent","geometry","Array","isArray","getType","CIRCLE","getExtent","padding","coords","getFlatCoordinates","cosAngle","cos","sinAngle","sin","minRotX","Infinity","minRotY","maxRotX","maxRotY","stride","getStride","rotX","rotY","min","isNaN","constrainedResolution","centerRotX","centerRotY","centerX","centerY","setResolution","centerOn","coordinate","position","opt_anchor","hint","changed","defaultMaxZoom","defaultZoomFactor","DEGREES","getMetersPerUnit","defaultMaxResolution","defaultMinResolution","floor","enableRotation"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,iBAAR,QAAgC,sBAAhC;AACA,SAAQC,MAAR,QAAqB,WAArB;AACA,SAAQC,SAAR,QAAwB,gBAAxB;AACA,SAAQC,YAAR,EAAsBC,IAAI,IAAIC,UAA9B,QAA+C,uBAA/C;AACA,OAAOC,UAAP,MAAuB,aAAvB;AACA,SAAQC,uBAAR,EAAiCC,iBAAjC,QAAyD,2BAAzD;AACA,SAAQC,gBAAR,EAA0BC,aAA1B,EAAyCN,IAAI,IAAIO,YAAjD,EAA+DC,OAA/D,QAA6E,yBAA7E;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,SAAQC,iBAAR,QAAgC,YAAhC;AACA,SAAQC,MAAR,QAAqB,cAArB;AACA,SAAQC,GAAG,IAAIC,aAAf,EAA8BC,MAAM,IAAIC,gBAAxC,EAA0DC,MAAM,IAAIC,gBAApE,QAA2F,iBAA3F;AACA,SAAQC,QAAR,QAAuB,aAAvB;AACA,SAAQC,iBAAR,EAA2BC,SAA3B,EAAsCC,SAAtC,EAAiDC,QAAjD,EAA2DC,OAA3D,QAAyE,aAAzE;AACA,OAAOC,YAAP,MAAyB,wBAAzB;AACA,SAAQC,UAAU,IAAIC,iBAAtB,QAA8C,mBAA9C;AACA,OAAOC,cAAP,MAA2B,0BAA3B;AACA,SAAQC,KAAR,EAAeC,MAAf,QAA4B,WAA5B;AACA,SAAQC,MAAR,QAAqB,UAArB;AACA,SAAQC,gBAAR,EAA0BC,eAA1B,QAAgD,WAAhD;AACA,OAAOC,KAAP,MAAkB,iBAAlB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,IAAI,GAAI,UAAUlC,UAAV,EAAsB;AAChC,WAASkC,IAAT,CAAcC,WAAd,EAA2B;AACzBnC,IAAAA,UAAU,CAACoC,IAAX,CAAgB,IAAhB;AAEA,QAAIC,OAAO,GAAGR,MAAM,CAAC,EAAD,EAAKM,WAAL,CAApB;AAEA;AACJ;AACA;AACA;;AACI,SAAKG,MAAL,GAAc,CAAC,CAAD,EAAI,CAAJ,CAAd;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,WAAL,GAAmB,EAAnB;AAEA;AACJ;AACA;AACA;;AACI,SAAKC,mBAAL;AAEA,SAAKC,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBC,IAAvB,CAA4B,IAA5B,CAAzB;AAEA;AACJ;AACA;AACA;AACA;;AACI,SAAKC,WAAL,GAAmBb,gBAAgB,CAACO,OAAO,CAACO,UAAT,EAAqB,WAArB,CAAnC;AAEA,SAAKC,aAAL,CAAmBR,OAAnB;AACD;;AAED,MAAKrC,UAAL,EAAkBkC,IAAI,CAACY,SAAL,GAAiB9C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","sourcesContent":["/**\n * @module ol/View\n */\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {getUid} from './util.js';\nimport {UNDEFINED} from './functions.js';\nimport {createExtent, none as centerNone} from './centerconstraint.js';\nimport BaseObject from './Object.js';\nimport {createSnapToResolutions, createSnapToPower} from './resolutionconstraint.js';\nimport {createSnapToZero, createSnapToN, none as rotationNone, disable} from './rotationconstraint.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {linearFindNearest} from './array.js';\nimport {assert} from './asserts.js';\nimport {add as addCoordinate, rotate as rotateCoordinate, equals as coordinatesEqual} from './coordinate.js';\nimport {inAndOut} from './easing.js';\nimport {getForViewAndSize, getCenter, getHeight, getWidth, isEmpty} from './extent.js';\nimport GeometryType from './geom/GeometryType.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\nimport SimpleGeometry from './geom/SimpleGeometry.js';\nimport {clamp, modulo} from './math.js';\nimport {assign} from './obj.js';\nimport {createProjection, METERS_PER_UNIT} from './proj.js';\nimport Units from './proj/Units.js';\n\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {module:ol/coordinate~Coordinate} [sourceCenter]\n * @property {module:ol/coordinate~Coordinate} [targetCenter]\n * @property {number} [sourceResolution]\n * @property {number} [targetResolution]\n * @property {number} [sourceRotation]\n * @property {number} [targetRotation]\n * @property {module:ol/coordinate~Coordinate} [anchor]\n * @property {number} start\n * @property {number} duration\n * @property {boolean} complete\n * @property {function(number):number} easing\n * @property {function(boolean)} callback\n */\n\n\n/**\n * @typedef {Object} Constraints\n * @property {module:ol/centerconstraint~Type} center\n * @property {module:ol/resolutionconstraint~Type} resolution\n * @property {module:ol/rotationconstraint~Type} rotation\n */\n\n\n/**\n * @typedef {Object} FitOptions\n * @property {module:ol/size~Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array.<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [constrainResolution=true] Constrain the resolution.\n * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get\n * the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean)} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n\n/**\n * @typedef {Object} ViewOptions\n * @property {module:ol/coordinate~Coordinate} [center] The initial center for\n * the view. The coordinate system for the center is specified with the\n * `projection` option. Layer sources will not be fetched if this is not set,\n * but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {module:ol/extent~Extent} [extent] The extent that constrains the\n * center, in other words, center cannot be set outside this extent.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array.<number>} [resolutions] Resolutions to determine the\n * resolution constraint. If set the `maxResolution`, `minResolution`,\n * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view. The initial\n * resolution is determined using the {@link #constrainResolution} method.\n * @property {number} [zoomFactor=2] The zoom factor used to determine the\n * resolution constraint.\n */\n\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {module:ol/coordinate~Coordinate|undefined} center The center of the view at the end of\n * the animation.\n * @property {number|undefined} zoom The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number|undefined} resolution The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number|undefined} rotation The rotation of the view at the end of\n * the animation.\n * @property {module:ol/coordinate~Coordinate|undefined} anchor Optional anchor to remained fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n\n/**\n * @typedef {Object} State\n * @property {module:ol/coordinate~Coordinate} center\n * @property {module:ol/proj/Projection} projection\n * @property {number} resolution\n * @property {number} rotation\n * @property {number} zoom\n */\n\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nvar DEFAULT_MIN_ZOOM = 0;\n\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * ### The view states\n *\n * An View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * An View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Spherical Mercator (EPSG:3857).\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view. Any value can be passed to the setters. And the value\n * that is passed to a setter will effectively be the value set in the view,\n * and returned by the corresponding getter.\n *\n * But a View object also has a *resolution constraint*, a\n * *rotation constraint* and a *center constraint*.\n *\n * As said above, no constraints are applied when the setters are used to set\n * new states for the view. Applying constraints is done explicitly through\n * the use of the `constrain*` functions (`constrainResolution` and\n * `constrainRotation` and `constrainCenter`).\n *\n * The main users of the constraints are the interactions and the\n * controls. For example, double-clicking on the map changes the view to\n * the \"next\" resolution. And releasing the fingers after pinch-zooming\n * snaps to the closest resolution (with an animation).\n *\n * The *resolution constraint* snaps to specific resolutions. It is\n * determined by the following options: `resolutions`, `maxResolution`,\n * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\n * options are ignored. See documentation for each option for more\n * information.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default the rotation value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the center is not constrained at all.\n *\n  * @api\n */\nvar View = (function (BaseObject) {\n  function View(opt_options) {\n    BaseObject.call(this);\n\n    var options = assign({}, opt_options);\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array.<Array.<module:ol/View~Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    this.updateAnimations_ = this.updateAnimations_.bind(this);\n\n    /**\n     * @private\n     * @const\n     * @type {module:ol/proj/Projection}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    this.applyOptions_(options);\n  }\n\n  if ( BaseObject ) View.__proto__ = BaseObject;\n  View.prototype = Object.create( BaseObject && BaseObject.prototype );\n  View.prototype.constructor = View;\n\n  /**\n   * Set up the view with the given options.\n   * @param {module:ol/View~ViewOptions} options View options.\n   */\n  View.prototype.applyOptions_ = function applyOptions_ (options) {\n\n    /**\n     * @type {Object.<string, *>}\n     */\n    var properties = {};\n    properties[ViewProperty.CENTER] = options.center !== undefined ?\n      options.center : null;\n\n    var resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array.<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    var centerConstraint = createCenterConstraint(options);\n    var resolutionConstraint = resolutionConstraintInfo.constraint;\n    var rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {module:ol/View~Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n\n    if (options.resolution !== undefined) {\n      properties[ViewProperty.RESOLUTION] = options.resolution;\n    } else if (options.zoom !== undefined) {\n      properties[ViewProperty.RESOLUTION] = this.constrainResolution(\n        this.maxResolution_, options.zoom - this.minZoom_);\n\n      if (this.resolutions_) { // in case map zoom is out of min/max zoom range\n        properties[ViewProperty.RESOLUTION] = clamp(\n          Number(this.getResolution() || properties[ViewProperty.RESOLUTION]),\n          this.minResolution_, this.maxResolution_);\n      }\n    }\n    properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;\n    this.setProperties(properties);\n\n    /**\n     * @private\n     * @type {module:ol/View~ViewOptions}\n     */\n    this.options_ = options;\n\n  };\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {module:ol/View~ViewOptions} newOptions New options to be applied.\n   * @return {module:ol/View~ViewOptions} New options updated with the current view state.\n   */\n  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_ (newOptions) {\n    var options = assign({}, this.options_);\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenter();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return assign({}, options, newOptions);\n  };\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(module:ol/View~AnimationOptions|function(boolean))} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  View.prototype.animate = function animate (var_args) {\n    var arguments$1 = arguments;\n    var this$1 = this;\n\n    var animationCount = arguments.length;\n    var callback;\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n    if (!this.isDef()) {\n      // if view properties are not yet set, shortcut to the final state\n      var state = arguments[animationCount - 1];\n      if (state.center) {\n        this.setCenter(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n      if (callback) {\n        setTimeout(function() {\n          callback(true);\n        }, 0);\n      }\n      return;\n    }\n    var start = Date.now();\n    var center = this.getCenter().slice();\n    var resolution = this.getResolution();\n    var rotation = this.getRotation();\n    var series = [];\n    for (var i = 0; i < animationCount; ++i) {\n      var options = /** @type {module:ol/View~AnimationOptions} */ (arguments$1[i]);\n\n      var animation = /** @type {module:ol/View~Animation} */ ({\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut\n      });\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center;\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this$1.constrainResolution(\n          this$1.maxResolution_, options.zoom - this$1.minZoom_, 0);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      animation.callback = callback;\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  };\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  View.prototype.getAnimating = function getAnimating () {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  };\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  View.prototype.getInteracting = function getInteracting () {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  };\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  View.prototype.cancelAnimations = function cancelAnimations () {\n    var this$1 = this;\n\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n      var series = this$1.animations_[i];\n      if (series[0].callback) {\n        series[0].callback(false);\n      }\n    }\n    this.animations_.length = 0;\n  };\n\n  /**\n   * Update all animations.\n   */\n  View.prototype.updateAnimations_ = function updateAnimations_ () {\n    var this$1 = this;\n\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    var now = Date.now();\n    var more = false;\n    for (var i = this.animations_.length - 1; i >= 0; --i) {\n      var series = this$1.animations_[i];\n      var seriesComplete = true;\n      for (var j = 0, jj = series.length; j < jj; ++j) {\n        var animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        var elapsed = now - animation.start;\n        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        var progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          var x0 = animation.sourceCenter[0];\n          var y0 = animation.sourceCenter[1];\n          var x1 = animation.targetCenter[0];\n          var y1 = animation.targetCenter[1];\n          var x = x0 + progress * (x1 - x0);\n          var y = y0 + progress * (y1 - y0);\n          this$1.set(ViewProperty.CENTER, [x, y]);\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          var resolution = progress === 1 ?\n            animation.targetResolution :\n            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            this$1.set(ViewProperty.CENTER,\n              this$1.calculateCenterZoom(resolution, animation.anchor));\n          }\n          this$1.set(ViewProperty.RESOLUTION, resolution);\n        }\n        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n          var rotation = progress === 1 ?\n            modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :\n            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            this$1.set(ViewProperty.CENTER,\n              this$1.calculateCenterRotate(rotation, animation.anchor));\n          }\n          this$1.set(ViewProperty.ROTATION, rotation);\n        }\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this$1.animations_[i] = null;\n        this$1.setHint(ViewHint.ANIMATING, -1);\n        var callback = series[0].callback;\n        if (callback) {\n          setTimeout(function() {\n            callback(true);\n          }, 0);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\n    }\n  };\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {module:ol/coordinate~Coordinate} anchor Rotation anchor.\n   * @return {module:ol/coordinate~Coordinate|undefined} Center for rotation and anchor.\n   */\n  View.prototype.calculateCenterRotate = function calculateCenterRotate (rotation, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  };\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {module:ol/coordinate~Coordinate} anchor Zoom anchor.\n   * @return {module:ol/coordinate~Coordinate|undefined} Center for resolution and anchor.\n   */\n  View.prototype.calculateCenterZoom = function calculateCenterZoom (resolution, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    var currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  };\n\n  /**\n   * @private\n   * @return {module:ol/size~Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_ () {\n    var size = [100, 100];\n    var selector = '.ol-viewport[data-view=\"' + getUid(this) + '\"]';\n    var element = document.querySelector(selector);\n    if (element) {\n      var metrics = getComputedStyle(element);\n      size[0] = parseInt(metrics.width, 10);\n      size[1] = parseInt(metrics.height, 10);\n    }\n    return size;\n  };\n\n  /**\n   * Get the constrained center of this view.\n   * @param {module:ol/coordinate~Coordinate|undefined} center Center.\n   * @return {module:ol/coordinate~Coordinate|undefined} Constrained center.\n   * @api\n   */\n  View.prototype.constrainCenter = function constrainCenter (center) {\n    return this.constraints_.center(center);\n  };\n\n  /**\n   * Get the constrained resolution of this view.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @param {number=} opt_direction Direction. Default is `0`.\n   * @return {number|undefined} Constrained resolution.\n   * @api\n   */\n  View.prototype.constrainResolution = function constrainResolution (resolution, opt_delta, opt_direction) {\n    var delta = opt_delta || 0;\n    var direction = opt_direction || 0;\n    return this.constraints_.resolution(resolution, delta, direction);\n  };\n\n  /**\n   * Get the constrained rotation of this view.\n   * @param {number|undefined} rotation Rotation.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @return {number|undefined} Constrained rotation.\n   * @api\n   */\n  View.prototype.constrainRotation = function constrainRotation (rotation, opt_delta) {\n    var delta = opt_delta || 0;\n    return this.constraints_.rotation(rotation, delta);\n  };\n\n  /**\n   * Get the view center.\n   * @return {module:ol/coordinate~Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  View.prototype.getCenter = function getCenter () {\n    return (\n      /** @type {module:ol/coordinate~Coordinate|undefined} */ (this.get(ViewProperty.CENTER))\n    );\n  };\n\n  /**\n   * @return {module:ol/View~Constraints} Constraints.\n   */\n  View.prototype.getConstraints = function getConstraints () {\n    return this.constraints_;\n  };\n\n  /**\n   * @param {Array.<number>=} opt_hints Destination array.\n   * @return {Array.<number>} Hint.\n   */\n  View.prototype.getHints = function getHints (opt_hints) {\n    if (opt_hints !== undefined) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  };\n\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {module:ol/size~Size=} opt_size Box pixel size. If not provided, the size of the\n   * first map that uses this view will be used.\n   * @return {module:ol/extent~Extent} Extent.\n   * @api\n   */\n  View.prototype.calculateExtent = function calculateExtent (opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var center = /** @type {!module:ol/coordinate~Coordinate} */ (this.getCenter());\n    assert(center, 1); // The view center is not defined\n    var resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 2); // The view resolution is not defined\n    var rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 3); // The view rotation is not defined\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  };\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  View.prototype.getMaxResolution = function getMaxResolution () {\n    return this.maxResolution_;\n  };\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  View.prototype.getMinResolution = function getMinResolution () {\n    return this.minResolution_;\n  };\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  View.prototype.getMaxZoom = function getMaxZoom () {\n    return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));\n  };\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  View.prototype.setMaxZoom = function setMaxZoom (zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  };\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  View.prototype.getMinZoom = function getMinZoom () {\n    return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));\n  };\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  View.prototype.setMinZoom = function setMinZoom (zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  };\n\n  /**\n   * Get the view projection.\n   * @return {module:ol/proj/Projection} The projection of the view.\n   * @api\n   */\n  View.prototype.getProjection = function getProjection () {\n    return this.projection_;\n  };\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  View.prototype.getResolution = function getResolution () {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  };\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array.<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  View.prototype.getResolutions = function getResolutions () {\n    return this.resolutions_;\n  };\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {module:ol/size~Size=} opt_size Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  View.prototype.getResolutionForExtent = function getResolutionForExtent (extent, opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var xResolution = getWidth(extent) / size[0];\n    var yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  };\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction (opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function(value) {\n        var resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      });\n  };\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  View.prototype.getRotation = function getRotation () {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  };\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction (opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function(resolution) {\n        var value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;\n        return value;\n      });\n  };\n\n  /**\n   * @return {module:ol/View~State} View state.\n   */\n  View.prototype.getState = function getState () {\n    var center = /** @type {module:ol/coordinate~Coordinate} */ (this.getCenter());\n    var projection = this.getProjection();\n    var resolution = /** @type {number} */ (this.getResolution());\n    var rotation = this.getRotation();\n    return (\n      /** @type {module:ol/View~State} */ ({\n        center: center.slice(),\n        projection: projection !== undefined ? projection : null,\n        resolution: resolution,\n        rotation: rotation,\n        zoom: this.getZoom()\n      })\n    );\n  };\n\n  /**\n   * Get the current zoom level.  If you configured your view with a resolutions\n   * array (this is rare), this method may return non-integer zoom levels (so\n   * the zoom level is not safe to use as an index into a resolutions array).\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  View.prototype.getZoom = function getZoom () {\n    var zoom;\n    var resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  };\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  View.prototype.getZoomForResolution = function getZoomForResolution (resolution) {\n    var offset = this.minZoom_ || 0;\n    var max, zoomFactor;\n    if (this.resolutions_) {\n      var nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  };\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  View.prototype.getResolutionForZoom = function getResolutionForZoom (zoom) {\n    return /** @type {number} */ (this.constrainResolution(\n      this.maxResolution_, zoom - this.minZoom_, 0));\n  };\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {module:ol/geom/SimpleGeometry|module:ol/extent~Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {module:ol/View~FitOptions=} opt_options Options.\n   * @api\n   */\n  View.prototype.fit = function fit (geometryOrExtent, opt_options) {\n    var options = opt_options || {};\n    var size = options.size;\n    if (!size) {\n      size = this.getSizeFromViewport_();\n    }\n    /** @type {module:ol/geom/SimpleGeometry} */\n    var geometry;\n    if (!(geometryOrExtent instanceof SimpleGeometry)) {\n      assert(Array.isArray(geometryOrExtent),\n        24); // Invalid extent or geometry provided as `geometry`\n      assert(!isEmpty(geometryOrExtent),\n        25); // Cannot fit empty extent provided as `geometry`\n      geometry = polygonFromExtent(geometryOrExtent);\n    } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n      geometryOrExtent = geometryOrExtent.getExtent();\n      geometry = polygonFromExtent(geometryOrExtent);\n      geometry.rotate(this.getRotation(), getCenter(geometryOrExtent));\n    } else {\n      geometry = geometryOrExtent;\n    }\n\n    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    var constrainResolution = options.constrainResolution !== undefined ?\n      options.constrainResolution : true;\n    var nearest = options.nearest !== undefined ? options.nearest : false;\n    var minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.constrainResolution(\n        this.maxResolution_, options.maxZoom - this.minZoom_, 0);\n    } else {\n      minResolution = 0;\n    }\n    var coords = geometry.getFlatCoordinates();\n\n    // calculate rotated extent\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var minRotX = +Infinity;\n    var minRotY = +Infinity;\n    var maxRotX = -Infinity;\n    var maxRotY = -Infinity;\n    var stride = geometry.getStride();\n    for (var i = 0, ii = coords.length; i < ii; i += stride) {\n      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n\n    // calculate resolution\n    var resolution = this.getResolutionForExtent(\n      [minRotX, minRotY, maxRotX, maxRotY],\n      [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n    resolution = isNaN(resolution) ? minResolution :\n      Math.max(resolution, minResolution);\n    if (constrainResolution) {\n      var constrainedResolution = this.constrainResolution(resolution, 0, 0);\n      if (!nearest && constrainedResolution < resolution) {\n        constrainedResolution = this.constrainResolution(\n          constrainedResolution, -1, 0);\n      }\n      resolution = constrainedResolution;\n    }\n\n    // calculate center\n    sinAngle = -sinAngle; // go back to original rotation\n    var centerRotX = (minRotX + maxRotX) / 2;\n    var centerRotY = (minRotY + maxRotY) / 2;\n    centerRotX += (padding[1] - padding[3]) / 2 * resolution;\n    centerRotY += (padding[0] - padding[2]) / 2 * resolution;\n    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;\n    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;\n    var center = [centerX, centerY];\n    var callback = options.callback ? options.callback : UNDEFINED;\n\n    if (options.duration !== undefined) {\n      this.animate({\n        resolution: resolution,\n        center: center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.setResolution(resolution);\n      this.setCenter(center);\n      setTimeout(callback.bind(undefined, true), 0);\n    }\n  };\n\n  /**\n   * Center on coordinate and view position.\n   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n   * @param {module:ol/size~Size} size Box pixel size.\n   * @param {module:ol/pixel~Pixel} position Position on the view to center on.\n   * @api\n   */\n  View.prototype.centerOn = function centerOn (coordinate, size, position) {\n    // calculate rotated position\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    var resolution = this.getResolution();\n    rotX += (size[0] / 2 - position[0]) * resolution;\n    rotY += (position[1] - size[1] / 2) * resolution;\n\n    // go back to original angle\n    sinAngle = -sinAngle; // go back to original rotation\n    var centerX = rotX * cosAngle - rotY * sinAngle;\n    var centerY = rotY * cosAngle + rotX * sinAngle;\n\n    this.setCenter([centerX, centerY]);\n  };\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  View.prototype.isDef = function isDef () {\n    return !!this.getCenter() && this.getResolution() !== undefined;\n  };\n\n  /**\n   * Rotate the view around a given coordinate.\n   * @param {number} rotation New rotation value for the view.\n   * @param {module:ol/coordinate~Coordinate=} opt_anchor The rotation center.\n   * @api\n   */\n  View.prototype.rotate = function rotate (rotation, opt_anchor) {\n    if (opt_anchor !== undefined) {\n      var center = this.calculateCenterRotate(rotation, opt_anchor);\n      this.setCenter(center);\n    }\n    this.setRotation(rotation);\n  };\n\n  /**\n   * Set the center of the current view.\n   * @param {module:ol/coordinate~Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  View.prototype.setCenter = function setCenter (center) {\n    this.set(ViewProperty.CENTER, center);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n\n  /**\n   * @param {module:ol/ViewHint} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  View.prototype.setHint = function setHint (hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  };\n\n  /**\n   * Set the resolution for this view.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  View.prototype.setResolution = function setResolution (resolution) {\n    this.set(ViewProperty.RESOLUTION, resolution);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n\n  /**\n   * Set the rotation for this view.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  View.prototype.setRotation = function setRotation (rotation) {\n    this.set(ViewProperty.ROTATION, rotation);\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n\n  /**\n   * Zoom to a specific zoom level.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  View.prototype.setZoom = function setZoom (zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  };\n\n  return View;\n}(BaseObject));\n\n\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {module:ol/centerconstraint~Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    return createExtent(options.extent);\n  } else {\n    return centerNone;\n  }\n}\n\n\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {{constraint: module:ol/resolutionconstraint~Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  var resolutionConstraint;\n  var maxResolution;\n  var minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  var defaultMaxZoom = 28;\n  var defaultZoomFactor = 2;\n\n  var minZoom = options.minZoom !== undefined ?\n    options.minZoom : DEFAULT_MIN_ZOOM;\n\n  var maxZoom = options.maxZoom !== undefined ?\n    options.maxZoom : defaultMaxZoom;\n\n  var zoomFactor = options.zoomFactor !== undefined ?\n    options.zoomFactor : defaultZoomFactor;\n\n  if (options.resolutions !== undefined) {\n    var resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution = resolutions[maxZoom] !== undefined ?\n      resolutions[maxZoom] : resolutions[resolutions.length - 1];\n    resolutionConstraint = createSnapToResolutions(\n      resolutions);\n  } else {\n    // calculate the default min and max resolution\n    var projection = createProjection(options.projection, 'EPSG:3857');\n    var extent = projection.getExtent();\n    var size = !extent ?\n      // use an extent that can fit the whole world if need be\n      360 * METERS_PER_UNIT[Units.DEGREES] /\n            projection.getMetersPerUnit() :\n      Math.max(getWidth(extent), getHeight(extent));\n\n    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(\n      defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    var defaultMinResolution = defaultMaxResolution / Math.pow(\n      defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom = minZoom + Math.floor(\n      Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    resolutionConstraint = createSnapToPower(\n      zoomFactor, maxResolution, maxZoom - minZoom);\n  }\n  return {constraint: resolutionConstraint, maxResolution: maxResolution,\n    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};\n}\n\n\n/**\n * @param {module:ol/View~ViewOptions} options View options.\n * @return {module:ol/rotationconstraint~Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  var enableRotation = options.enableRotation !== undefined ?\n    options.enableRotation : true;\n  if (enableRotation) {\n    var constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationNone;\n    } else if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationNone;\n    }\n  } else {\n    return disable;\n  }\n}\n\n\n/**\n * Determine if an animation involves no view change.\n * @param {module:ol/View~Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\nexport default View;\n\n//# sourceMappingURL=View.js.map"]},"metadata":{},"sourceType":"module"}