{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, createEmpty, containsExtent, getWidth } from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from '../canvas/Layer.js';\nimport { defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\n\nvar CanvasVectorLayerRenderer = function (CanvasLayerRenderer) {\n  function CanvasVectorLayerRenderer(vectorLayer) {\n    CanvasLayerRenderer.call(this, vectorLayer);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedResolution_ = NaN;\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n\n    this.renderedExtent_ = createEmpty();\n    /**\n     * @private\n     * @type {function(module:ol/Feature, module:ol/Feature): number|null}\n     */\n\n    this.renderedRenderOrder_ = null;\n    /**\n     * @private\n     * @type {module:ol/render/canvas/ReplayGroup}\n     */\n\n    this.replayGroup_ = null;\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n\n    this.replayGroupChanged = true;\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = createCanvasContext2D();\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n\n  if (CanvasLayerRenderer) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;\n  CanvasVectorLayerRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasLayerRenderer.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/layer/Layer~State} layerState Layer state.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.compose = function compose(context, frameState, layerState) {\n    var this$1 = this;\n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource =\n    /** @type {module:ol/source/Vector} */\n    this.getLayer().getSource();\n    var transform = this.getTransform(frameState, 0); // clipped rendering if layer extent is set\n\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n\n    if (clipped) {\n      this.clip(context, frameState,\n      /** @type {module:ol/extent~Extent} */\n      clipExtent);\n    }\n\n    var replayGroup = this.replayGroup_;\n\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n\n      var layer =\n      /** @type {module:ol/layer/Vector} */\n      this.getLayer();\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        } // resize and clear\n\n\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      var alpha = replayContext.globalAlpha;\n\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation, width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n\n      if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = getWidth(projectionExtent);\n        var world = 0;\n        var offsetX;\n\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this$1.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX += worldWidth;\n        }\n\n        world = 0;\n        startX = extent[2];\n\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this$1.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX -= worldWidth;\n        }\n      }\n\n      rotateAtOffset(replayContext, rotation, width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n\n      if (replayContext != context) {\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    var transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer =\n      /** @type {module:ol/layer/Vector} */\n      this.getLayer();\n      /** @type {!Object.<string, boolean>} */\n\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n      /**\n       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n       * @return {?} Callback result.\n       */\n      function (feature) {\n        var key = getUid(feature).toString();\n\n        if (!(key in features)) {\n          features[key] = true;\n          return callback.call(thisArg, feature, layer);\n        }\n      }, null);\n      return result;\n    }\n  };\n  /**\n   * @param {module:ol/events/Event} event Event.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {module:ol/events/Event} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var vectorLayer =\n    /** @type {module:ol/layer/Vector} */\n    this.getLayer();\n    var vectorSource = vectorLayer.getSource();\n    var animating = frameState.viewHints[ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n      return true;\n    }\n\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = getWidth(projectionExtent);\n      var gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n    this.dirty_ = false;\n    var replayGroup = new CanvasReplayGroup(getRenderTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {module:ol/Feature} feature Feature.\n     * @this {module:ol/renderer/canvas/VectorLayer}\n     */\n\n    var render = function (feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n\n      if (styles) {\n        var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n\n    if (vectorLayerRenderOrder) {\n      /** @type {Array.<module:ol/Feature>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n      /**\n       * @param {module:ol/Feature} feature Feature.\n       */\n      function (feature) {\n        features.push(feature);\n      }, this);\n      features.sort(vectorLayerRenderOrder);\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render, this);\n    }\n\n    replayGroup.finish();\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n    this.replayGroupChanged = true;\n    return true;\n  };\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.\n   * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n    var this$1 = this;\n\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], getSquaredRenderTolerance(resolution, pixelRatio), this$1.handleStyleImageChange_, this$1) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, getSquaredRenderTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);\n    }\n\n    return loading;\n  };\n\n  return CanvasVectorLayerRenderer;\n}(CanvasLayerRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasVectorLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/VectorLayer} The layer renderer.\n */\n\n\nCanvasVectorLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(\n  /** @type {module:ol/layer/Vector} */\n  layer);\n};\n\nexport default CanvasVectorLayerRenderer; //# sourceMappingURL=VectorLayer.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/renderer/canvas/VectorLayer.js"],"names":["getUid","LayerType","ViewHint","createCanvasContext2D","listen","unlisten","EventType","rbush","buffer","createEmpty","containsExtent","getWidth","RenderEventType","labelCache","rotateAtOffset","CanvasReplayGroup","CanvasLayerRenderer","defaultOrder","defaultRenderOrder","getTolerance","getRenderTolerance","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","CanvasVectorLayerRenderer","vectorLayer","call","declutterTree_","getDeclutter","undefined","dirty_","renderedRevision_","renderedResolution_","NaN","renderedExtent_","renderedRenderOrder_","replayGroup_","replayGroupChanged","context","CLEAR","handleFontsChanged_","__proto__","prototype","Object","create","constructor","disposeInternal","compose","frameState","layerState","this$1","extent","pixelRatio","skippedFeatureUids","managed","viewState","projection","rotation","projectionExtent","getExtent","vectorSource","getLayer","getSource","transform","getTransform","clipExtent","clipped","clip","replayGroup","isEmpty","clear","layer","drawOffsetX","drawOffsetY","replayContext","transparentLayer","opacity","hasRenderListeners","hasListener","RENDER","drawWidth","canvas","width","drawHeight","height","drawSize","Math","round","sqrt","alpha","globalAlpha","translate","size","replay","getWrapX","canWrapX","startX","worldWidth","world","offsetX","dispatchRenderEvent","mainContextAlpha","drawImage","restore","composeFrame","preCompose","postCompose","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","thisArg","resolution","features","result","feature","key","toString","event","getVisible","changed","handleStyleImageChange_","renderIfReadyAndVisible","prepareFrame","animating","viewHints","ANIMATING","interacting","INTERACTING","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","getRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","gutter","max","getOverlaps","loadFeatures","render","styles","styleFunction","getStyleFunction","dirty","bind","forEachFeatureInExtent","push","sort","i","ii","length","finish","renderFeature$1","loading","Array","isArray","getType","VECTOR","mapRenderer"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, createEmpty, containsExtent, getWidth} from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from '../canvas/Layer.js';\nimport {defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nvar CanvasVectorLayerRenderer = (function (CanvasLayerRenderer) {\n  function CanvasVectorLayerRenderer(vectorLayer) {\n\n    CanvasLayerRenderer.call(this, vectorLayer);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {module:ol/extent~Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {function(module:ol/Feature, module:ol/Feature): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {module:ol/render/canvas/ReplayGroup}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = createCanvasContext2D();\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  if ( CanvasLayerRenderer ) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;\n  CanvasVectorLayerRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );\n  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal () {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasLayerRenderer.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/layer/Layer~State} layerState Layer state.\n   */\n  CanvasVectorLayerRenderer.prototype.compose = function compose (context, frameState, layerState) {\n    var this$1 = this;\n\n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ?\n      frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource = /** @type {module:ol/source/Vector} */ (this.getLayer().getSource());\n\n    var transform = this.getTransform(frameState, 0);\n\n    // clipped rendering if layer extent is set\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n    if (clipped) {\n      this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (clipExtent));\n    }\n    var replayGroup = this.replayGroup_;\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n      var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        }\n        // resize and clear\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      var alpha = replayContext.globalAlpha;\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation,\n        width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n      if (vectorSource.getWrapX() && projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = getWidth(projectionExtent);\n        var world = 0;\n        var offsetX;\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this$1.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX += worldWidth;\n        }\n        world = 0;\n        startX = extent[2];\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this$1.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\n          startX -= worldWidth;\n        }\n      }\n      rotateAtOffset(replayContext, rotation,\n        width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n      if (replayContext != context) {\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {\n    var transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\n      /** @type {!Object.<string, boolean>} */\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          var key = getUid(feature).toString();\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      return result;\n    }\n  };\n\n  /**\n   * @param {module:ol/events/Event} event Event.\n   */\n  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n\n  /**\n   * Handle changes in image style state.\n   * @param {module:ol/events/Event} event Image style change event.\n   * @private\n   */\n  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {\n    this.renderIfReadyAndVisible();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {\n    var vectorLayer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\n    var vectorSource = vectorLayer.getSource();\n\n    var animating = frameState.viewHints[ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && (!updateWhileAnimating && animating) ||\n        (!updateWhileInteracting && interacting)) {\n      return true;\n    }\n\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    var extent = buffer(frameStateExtent,\n      vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&\n        !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = getWidth(projectionExtent);\n      var gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ &&\n        this.renderedResolution_ == resolution &&\n        this.renderedRevision_ == vectorLayerRevision &&\n        this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n        containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    this.dirty_ = false;\n\n    var replayGroup = new CanvasReplayGroup(\n      getRenderTolerance(resolution, pixelRatio), extent, resolution,\n      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {module:ol/Feature} feature Feature.\n     * @this {module:ol/renderer/canvas/VectorLayer}\n     */\n    var render = function(feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n      if (styles) {\n        var dirty = this.renderFeature(\n          feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    if (vectorLayerRenderOrder) {\n      /** @type {Array.<module:ol/Feature>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n        /**\n         * @param {module:ol/Feature} feature Feature.\n         */\n        function(feature) {\n          features.push(feature);\n        }, this);\n      features.sort(vectorLayerRenderOrder);\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render, this);\n    }\n    replayGroup.finish();\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n\n    this.replayGroupChanged = true;\n    return true;\n  };\n\n  /**\n   * @param {module:ol/Feature} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.\n   * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, resolution, pixelRatio, styles, replayGroup) {\n    var this$1 = this;\n\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i],\n          getSquaredRenderTolerance(resolution, pixelRatio),\n          this$1.handleStyleImageChange_, this$1) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles,\n        getSquaredRenderTolerance(resolution, pixelRatio),\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n\n  return CanvasVectorLayerRenderer;\n}(CanvasLayerRenderer));\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/VectorLayer} The layer renderer.\n */\nCanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(/** @type {module:ol/layer/Vector} */ (layer));\n};\n\n\nexport default CanvasVectorLayerRenderer;\n\n//# sourceMappingURL=VectorLayer.js.map"]},"metadata":{},"sourceType":"module"}