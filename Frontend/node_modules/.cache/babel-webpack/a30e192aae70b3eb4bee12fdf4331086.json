{"ast":null,"code":"/**\n * @module ol/interaction/DragPan\n */\nimport ViewHint from '../ViewHint.js';\nimport { scale as scaleCoordinate, rotate as rotateCoordinate, add as addCoordinate } from '../coordinate.js';\nimport { easeOut } from '../easing.js';\nimport { noModifierKeys } from '../events/condition.js';\nimport { FALSE } from '../functions.js';\nimport PointerInteraction, { centroid as centroidFromPointers } from '../interaction/Pointer.js';\n/**\n * @typedef {Object} Options\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition~noModifierKeys}.\n * @property {module:ol/Kinetic} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\n\nvar DragPan = function (PointerInteraction) {\n  function DragPan(opt_options) {\n    PointerInteraction.call(this, {\n      handleDownEvent: handleDownEvent,\n      handleDragEvent: handleDragEvent,\n      handleUpEvent: handleUpEvent,\n      stopDown: FALSE\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {module:ol/Kinetic|undefined}\n     */\n\n    this.kinetic_ = options.kinetic;\n    /**\n     * @type {module:ol/pixel~Pixel}\n     */\n\n    this.lastCentroid = null;\n    /**\n     * @type {number}\n     */\n\n    this.lastPointersCount_;\n    /**\n     * @private\n     * @type {module:ol/events/condition~Condition}\n     */\n\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.noKinetic_ = false;\n  }\n\n  if (PointerInteraction) DragPan.__proto__ = PointerInteraction;\n  DragPan.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  DragPan.prototype.constructor = DragPan;\n  return DragPan;\n}(PointerInteraction);\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {module:ol/interaction/DragPan}\n */\n\n\nfunction handleDragEvent(mapBrowserEvent) {\n  var targetPointers = this.targetPointers;\n  var centroid = centroidFromPointers(targetPointers);\n\n  if (targetPointers.length == this.lastPointersCount_) {\n    if (this.kinetic_) {\n      this.kinetic_.update(centroid[0], centroid[1]);\n    }\n\n    if (this.lastCentroid) {\n      var deltaX = this.lastCentroid[0] - centroid[0];\n      var deltaY = centroid[1] - this.lastCentroid[1];\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      var center = [deltaX, deltaY];\n      scaleCoordinate(center, view.getResolution());\n      rotateCoordinate(center, view.getRotation());\n      addCoordinate(center, view.getCenter());\n      center = view.constrainCenter(center);\n      view.setCenter(center);\n    }\n  } else if (this.kinetic_) {\n    // reset so we don't overestimate the kinetic energy after\n    // after one finger down, tiny drag, second finger down\n    this.kinetic_.begin();\n  }\n\n  this.lastCentroid = centroid;\n  this.lastPointersCount_ = targetPointers.length;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/DragPan}\n */\n\n\nfunction handleUpEvent(mapBrowserEvent) {\n  var map = mapBrowserEvent.map;\n  var view = map.getView();\n\n  if (this.targetPointers.length === 0) {\n    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n      var distance = this.kinetic_.getDistance();\n      var angle = this.kinetic_.getAngle();\n      var center =\n      /** @type {!module:ol/coordinate~Coordinate} */\n      view.getCenter();\n      var centerpx = map.getPixelFromCoordinate(center);\n      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);\n      view.animate({\n        center: view.constrainCenter(dest),\n        duration: 500,\n        easing: easeOut\n      });\n    }\n\n    view.setHint(ViewHint.INTERACTING, -1);\n    return false;\n  } else {\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n\n    this.lastCentroid = null;\n    return true;\n  }\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/DragPan}\n */\n\n\nfunction handleDownEvent(mapBrowserEvent) {\n  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    this.lastCentroid = null;\n\n    if (!this.handlingDownUpSequence) {\n      view.setHint(ViewHint.INTERACTING, 1);\n    } // stop any current animation\n\n\n    if (view.getAnimating()) {\n      view.setCenter(mapBrowserEvent.frameState.viewState.center);\n    }\n\n    if (this.kinetic_) {\n      this.kinetic_.begin();\n    } // No kinetic as soon as more than one pointer on the screen is\n    // detected. This is to prevent nasty pans after pinch.\n\n\n    this.noKinetic_ = this.targetPointers.length > 1;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport default DragPan; //# sourceMappingURL=DragPan.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/interaction/DragPan.js"],"names":["ViewHint","scale","scaleCoordinate","rotate","rotateCoordinate","add","addCoordinate","easeOut","noModifierKeys","FALSE","PointerInteraction","centroid","centroidFromPointers","DragPan","opt_options","call","handleDownEvent","handleDragEvent","handleUpEvent","stopDown","options","kinetic_","kinetic","lastCentroid","lastPointersCount_","condition_","condition","noKinetic_","__proto__","prototype","Object","create","constructor","mapBrowserEvent","targetPointers","length","update","deltaX","deltaY","map","view","getView","center","getResolution","getRotation","getCenter","constrainCenter","setCenter","begin","end","distance","getDistance","angle","getAngle","centerpx","getPixelFromCoordinate","dest","getCoordinateFromPixel","Math","cos","sin","animate","duration","easing","setHint","INTERACTING","handlingDownUpSequence","getAnimating","frameState","viewState"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/DragPan\n */\nimport ViewHint from '../ViewHint.js';\nimport {scale as scaleCoordinate, rotate as rotateCoordinate, add as addCoordinate} from '../coordinate.js';\nimport {easeOut} from '../easing.js';\nimport {noModifierKeys} from '../events/condition.js';\nimport {FALSE} from '../functions.js';\nimport PointerInteraction, {centroid as centroidFromPointers} from '../interaction/Pointer.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition~noModifierKeys}.\n * @property {module:ol/Kinetic} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nvar DragPan = (function (PointerInteraction) {\n  function DragPan(opt_options) {\n\n    PointerInteraction.call(this, {\n      handleDownEvent: handleDownEvent,\n      handleDragEvent: handleDragEvent,\n      handleUpEvent: handleUpEvent,\n      stopDown: FALSE\n    });\n\n    var options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {module:ol/Kinetic|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {module:ol/pixel~Pixel}\n     */\n    this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     */\n    this.lastPointersCount_;\n\n    /**\n     * @private\n     * @type {module:ol/events/condition~Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n\n  }\n\n  if ( PointerInteraction ) DragPan.__proto__ = PointerInteraction;\n  DragPan.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );\n  DragPan.prototype.constructor = DragPan;\n\n  return DragPan;\n}(PointerInteraction));\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {module:ol/interaction/DragPan}\n */\nfunction handleDragEvent(mapBrowserEvent) {\n  var targetPointers = this.targetPointers;\n  var centroid = centroidFromPointers(targetPointers);\n  if (targetPointers.length == this.lastPointersCount_) {\n    if (this.kinetic_) {\n      this.kinetic_.update(centroid[0], centroid[1]);\n    }\n    if (this.lastCentroid) {\n      var deltaX = this.lastCentroid[0] - centroid[0];\n      var deltaY = centroid[1] - this.lastCentroid[1];\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      var center = [deltaX, deltaY];\n      scaleCoordinate(center, view.getResolution());\n      rotateCoordinate(center, view.getRotation());\n      addCoordinate(center, view.getCenter());\n      center = view.constrainCenter(center);\n      view.setCenter(center);\n    }\n  } else if (this.kinetic_) {\n    // reset so we don't overestimate the kinetic energy after\n    // after one finger down, tiny drag, second finger down\n    this.kinetic_.begin();\n  }\n  this.lastCentroid = centroid;\n  this.lastPointersCount_ = targetPointers.length;\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/DragPan}\n */\nfunction handleUpEvent(mapBrowserEvent) {\n  var map = mapBrowserEvent.map;\n  var view = map.getView();\n  if (this.targetPointers.length === 0) {\n    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n      var distance = this.kinetic_.getDistance();\n      var angle = this.kinetic_.getAngle();\n      var center = /** @type {!module:ol/coordinate~Coordinate} */ (view.getCenter());\n      var centerpx = map.getPixelFromCoordinate(center);\n      var dest = map.getCoordinateFromPixel([\n        centerpx[0] - distance * Math.cos(angle),\n        centerpx[1] - distance * Math.sin(angle)\n      ]);\n      view.animate({\n        center: view.constrainCenter(dest),\n        duration: 500,\n        easing: easeOut\n      });\n    }\n    view.setHint(ViewHint.INTERACTING, -1);\n    return false;\n  } else {\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n}\n\n\n/**\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/DragPan}\n */\nfunction handleDownEvent(mapBrowserEvent) {\n  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    this.lastCentroid = null;\n    if (!this.handlingDownUpSequence) {\n      view.setHint(ViewHint.INTERACTING, 1);\n    }\n    // stop any current animation\n    if (view.getAnimating()) {\n      view.setCenter(mapBrowserEvent.frameState.viewState.center);\n    }\n    if (this.kinetic_) {\n      this.kinetic_.begin();\n    }\n    // No kinetic as soon as more than one pointer on the screen is\n    // detected. This is to prevent nasty pans after pinch.\n    this.noKinetic_ = this.targetPointers.length > 1;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\nexport default DragPan;\n\n//# sourceMappingURL=DragPan.js.map"]},"metadata":{},"sourceType":"module"}