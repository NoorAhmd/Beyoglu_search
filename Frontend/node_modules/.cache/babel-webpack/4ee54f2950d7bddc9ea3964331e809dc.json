{"ast":null,"code":"import _slicedToArray from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/n.ah/Projects/ankamap/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { trigger, state, style, animate, transition, query, group, sequence } from '@angular/animations';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nimport * as ɵngcc5 from '@angular/cdk/bidi';\nvar _c0 = [\"mat-menu-item\", \"\"];\nvar _c1 = [\"*\"];\n\nfunction MatMenu_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n    ɵngcc0.ɵɵlistener(\"keydown\", function MatMenu_ng_template_0_Template_div_keydown_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1._handleKeydown($event);\n    })(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ctx_r3.closed.emit(\"click\");\n    })(\"@transformMenu.start\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4._isAnimating = true;\n    })(\"@transformMenu.done\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ctx_r5._onAnimationDone($event);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r0._classList)(\"@transformMenu\", ctx_r0._panelAnimationState);\n  }\n}\n\nvar MatMenuContent = /*#__PURE__*/function () {\n  /**\n   * @param {?} _template\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _injector\n   * @param {?} _viewContainerRef\n   * @param {?} _document\n   */\n  function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n    _classCallCheck(this, MatMenuContent);\n\n    this._template = _template;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._injector = _injector;\n    this._viewContainerRef = _viewContainerRef;\n    this._document = _document;\n    /**\n     * Emits when the menu content has been attached.\n     */\n\n    this._attached = new Subject();\n  }\n  /**\n   * Attaches the content with a particular context.\n   * \\@docs-private\n   * @param {?=} context\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuContent, [{\n    key: \"attach\",\n    value: function attach() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._portal) {\n        this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n      }\n\n      this.detach();\n\n      if (!this._outlet) {\n        this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n      }\n\n      var\n      /** @type {?} */\n      element = this._template.elementRef.nativeElement;\n      /** @type {?} */\n\n      // Because we support opening the same menu from different triggers (which in turn have their\n      // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n      // risk it staying attached to a pane that's no longer in the DOM.\n      element.parentNode.insertBefore(this._outlet.outletElement, element);\n\n      this._portal.attach(this._outlet, context);\n\n      this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._portal.isAttached) {\n        this._portal.detach();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._outlet) {\n        this._outlet.dispose();\n      }\n    }\n  }]);\n\n  return MatMenuContent;\n}();\n\nMatMenuContent.ɵfac = function MatMenuContent_Factory(t) {\n  return new (t || MatMenuContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nMatMenuContent.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatMenuContent,\n  selectors: [[\"ng-template\", \"matMenuContent\", \"\"]]\n});\n/** @nocollapse */\n\nMatMenuContent.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: ApplicationRef\n  }, {\n    type: Injector\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuContent, [{\n    type: Directive,\n    args: [{\n      selector: 'ng-template[matMenuContent]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }, {\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.ApplicationRef\n    }, {\n      type: ɵngcc0.Injector\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n */\n\n\nvar\n/** @type {?} */\nmatMenuAnimations = {\n  /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n  transformMenu: trigger('transformMenu', [state('void', style({\n    opacity: 0,\n    // This starts off from 0.01, instead of 0, because there's an issue in the Angular animations\n    // as of 4.2, which causes the animation to be skipped if it starts from 0.\n    transform: 'scale(0.01, 0.01)'\n  })), transition('void => enter', sequence([query('.mat-menu-content', style({\n    opacity: 0\n  })), animate('100ms linear', style({\n    opacity: 1,\n    transform: 'scale(1, 0.5)'\n  })), group([query('.mat-menu-content', animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', style({\n    opacity: 1\n  }))), animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({\n    transform: 'scale(1, 1)'\n  }))])])), transition('* => void', animate('150ms 50ms linear', style({\n    opacity: 0\n  })))]),\n\n  /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n  fadeInItems: trigger('fadeInItems', [// TODO(crisbeto): this is inside the `transformMenu`\n  // now. Remove next time we do breaking changes.\n  state('showing', style({\n    opacity: 1\n  })), transition('void => *', [style({\n    opacity: 0\n  }), animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')])])\n};\n/**\n * @deprecated\n * \\@breaking-change 7.0.0\n */\n\nvar\n/** @type {?} */\nfadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@breaking-change 7.0.0\n */\n\nvar\n/** @type {?} */\ntransformMenu = matMenuAnimations.transformMenu;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\n\nfunction throwMatMenuMissingError() {\n  throw Error(\"mat-menu-trigger: must pass in an mat-menu instance.\\n\\n    Example:\\n      <mat-menu #menu=\\\"matMenu\\\"></mat-menu>\\n      <button [matMenuTriggerFor]=\\\"menu\\\"></button>\");\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwMatMenuInvalidPositionX() {\n  throw Error(\"x-position value must be either 'before' or after'.\\n      Example: <mat-menu x-position=\\\"before\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwMatMenuInvalidPositionY() {\n  throw Error(\"y-position value must be either 'above' or below'.\\n      Example: <mat-menu y-position=\\\"above\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n */\n\n\nvar\n/** @type {?} */\nMAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\n\nvar MatMenuItemBase = function MatMenuItemBase() {\n  _classCallCheck(this, MatMenuItemBase);\n};\n\nvar\n/** @type {?} */\n_MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\n\n\nvar MatMenuItem = /*#__PURE__*/function (_MatMenuItemMixinBase2) {\n  _inherits(MatMenuItem, _MatMenuItemMixinBase2);\n\n  var _super = _createSuper(MatMenuItem);\n\n  /**\n   * @param {?} _elementRef\n   * @param {?=} document\n   * @param {?=} _focusMonitor\n   * @param {?=} _parentMenu\n   */\n  function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {\n    var _this;\n\n    _classCallCheck(this, MatMenuItem);\n\n    // @breaking-change 7.0.0 make `_focusMonitor` and `document` required params.\n    _this = _super.call(this);\n    _this._elementRef = _elementRef;\n    _this._focusMonitor = _focusMonitor;\n    _this._parentMenu = _parentMenu;\n    /**\n     * Stream that emits when the menu item is hovered.\n     */\n\n    _this._hovered = new Subject();\n    /**\n     * Whether the menu item is highlighted.\n     */\n\n    _this._highlighted = false;\n    /**\n     * Whether the menu item acts as a trigger for a sub-menu.\n     */\n\n    _this._triggersSubmenu = false;\n\n    if (_focusMonitor) {\n      // Start monitoring the element so it gets the appropriate focused classes. We want\n      // to show the focus style for menu items only when the focus was not caused by a\n      // mouse or touch interaction.\n      _focusMonitor.monitor(_this._getHostElement(), false);\n    }\n\n    if (_parentMenu && _parentMenu.addItem) {\n      _parentMenu.addItem(_assertThisInitialized(_this));\n    }\n\n    _this._document = document;\n    return _this;\n  }\n  /**\n   * Focuses the menu item.\n   * @param {?=} origin\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuItem, [{\n    key: \"focus\",\n    value: function focus() {\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      if (this._focusMonitor) {\n        this._focusMonitor.focusVia(this._getHostElement(), origin);\n      } else {\n        this._getHostElement().focus();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._focusMonitor) {\n        this._focusMonitor.stopMonitoring(this._getHostElement());\n      }\n\n      if (this._parentMenu && this._parentMenu.removeItem) {\n        this._parentMenu.removeItem(this);\n      }\n\n      this._hovered.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getTabIndex\",\n    value: function _getTabIndex() {\n      return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getHostElement\",\n    value: function _getHostElement() {\n      return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_checkDisabled\",\n    value: function _checkDisabled(event) {\n      if (this.disabled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleMouseEnter\",\n    value: function _handleMouseEnter() {\n      this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n\n  }, {\n    key: \"getLabel\",\n    value: function getLabel() {\n      var\n      /** @type {?} */\n      element = this._elementRef.nativeElement;\n      var\n      /** @type {?} */\n      textNodeType = this._document ? this._document.TEXT_NODE : 3;\n      var\n      /** @type {?} */\n      output = '';\n\n      if (element.childNodes) {\n        var\n        /** @type {?} */\n        length = element.childNodes.length; // Go through all the top-level text nodes and extract their text.\n        // We skip anything that's not a text node to prevent the text from\n        // being thrown off by something like an icon.\n\n        for (var\n        /** @type {?} */\n        i = 0; i < length; i++) {\n          if (element.childNodes[i].nodeType === textNodeType) {\n            output += element.childNodes[i].textContent;\n          }\n        }\n      }\n\n      return output.trim();\n    }\n  }]);\n\n  return MatMenuItem;\n}(_MatMenuItemMixinBase);\n\nMatMenuItem.ɵfac = function MatMenuItem_Factory(t) {\n  return new (t || MatMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8));\n};\n\nMatMenuItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: MatMenuItem,\n  selectors: [[\"\", \"mat-menu-item\", \"\"]],\n  hostAttrs: [\"role\", \"menuitem\", 1, \"mat-menu-item\"],\n  hostVars: 7,\n  hostBindings: function MatMenuItem_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) {\n        return ctx._checkDisabled($event);\n      })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() {\n        return ctx._handleMouseEnter();\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled.toString())(\"disabled\", ctx.disabled || null);\n      ɵngcc0.ɵɵclassProp(\"mat-menu-item-highlighted\", ctx._highlighted)(\"mat-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n    }\n  },\n  inputs: {\n    disabled: \"disabled\",\n    disableRipple: \"disableRipple\"\n  },\n  exportAs: [\"matMenuItem\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n  attrs: _c0,\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[\"matRipple\", \"\", 1, \"mat-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"]],\n  template: function MatMenuItem_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵprojection(0);\n      ɵngcc0.ɵɵelement(1, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n    }\n  },\n  directives: [ɵngcc2.MatRipple],\n  encapsulation: 2,\n  changeDetection: 0\n});\n/** @nocollapse */\n\nMatMenuItem.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: FocusMonitor\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_PANEL]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuItem, [{\n    type: Component,\n    args: [{\n      selector: '[mat-menu-item]',\n      exportAs: 'matMenuItem',\n      inputs: ['disabled', 'disableRipple'],\n      host: {\n        'role': 'menuitem',\n        'class': 'mat-menu-item',\n        '[class.mat-menu-item-highlighted]': '_highlighted',\n        '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n        '[attr.tabindex]': '_getTabIndex()',\n        '[attr.aria-disabled]': 'disabled.toString()',\n        '[attr.disabled]': 'disabled || null',\n        '(click)': '_checkDisabled($event)',\n        '(mouseenter)': '_handleMouseEnter()'\n      },\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: ɵngcc1.FocusMonitor\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_PANEL]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n */\n\n\nvar\n/** @type {?} */\nMAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n  providedIn: 'root',\n  factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\n\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    overlapTrigger: true,\n    xPosition: 'after',\n    yPosition: 'below',\n    backdropClass: 'cdk-overlay-transparent-backdrop'\n  };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n */\n\n\nvar\n/** @type {?} */\nMAT_MENU_BASE_ELEVATION = 2;\n\nvar MatMenu = /*#__PURE__*/function () {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _ngZone\n   * @param {?} _defaultOptions\n   */\n  function MatMenu(_elementRef, _ngZone, _defaultOptions) {\n    _classCallCheck(this, MatMenu);\n\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._defaultOptions = _defaultOptions;\n    this._xPosition = this._defaultOptions.xPosition;\n    this._yPosition = this._defaultOptions.yPosition;\n    /**\n     * Menu items inside the current menu.\n     */\n\n    this._items = [];\n    /**\n     * Emits whenever the amount of menu items changes.\n     */\n\n    this._itemChanges = new Subject();\n    /**\n     * Subscription to tab events on the menu panel\n     */\n\n    this._tabSubscription = Subscription.EMPTY;\n    /**\n     * Config object to be passed into the menu's ngClass\n     */\n\n    this._classList = {};\n    /**\n     * Current state of the panel animation.\n     */\n\n    this._panelAnimationState = 'void';\n    /**\n     * Emits whenever an animation on the menu completes.\n     */\n\n    this._animationDone = new Subject();\n    /**\n     * Class to be added to the backdrop element.\n     */\n\n    this.backdropClass = this._defaultOptions.backdropClass;\n    this._overlapTrigger = this._defaultOptions.overlapTrigger;\n    this._hasBackdrop = this._defaultOptions.hasBackdrop;\n    /**\n     * Event emitted when the menu is closed.\n     */\n\n    this.closed = new EventEmitter();\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * \\@breaking-change 7.0.0\n     */\n\n    this.close = this.closed;\n  }\n  /**\n   * Position of the menu in the X axis.\n   * @return {?}\n   */\n\n\n  _createClass(MatMenu, [{\n    key: \"xPosition\",\n    get: function get() {\n      return this._xPosition;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== 'before' && value !== 'after') {\n        throwMatMenuInvalidPositionX();\n      }\n\n      this._xPosition = value;\n      this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n\n  }, {\n    key: \"yPosition\",\n    get: function get() {\n      return this._yPosition;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== 'above' && value !== 'below') {\n        throwMatMenuInvalidPositionY();\n      }\n\n      this._yPosition = value;\n      this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n\n  }, {\n    key: \"overlapTrigger\",\n    get: function get() {\n      return this._overlapTrigger;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n\n  }, {\n    key: \"hasBackdrop\",\n    get: function get() {\n      return this._hasBackdrop;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n\n  }, {\n    key: \"panelClass\",\n    set: function set(classes) {\n      if (classes && classes.length) {\n        this._classList = classes.split(' ').reduce(function (obj, className) {\n          obj[className] = true;\n          return obj;\n        }, {});\n        this._elementRef.nativeElement.className = '';\n      }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 7.0.0\n     * @return {?}\n     */\n\n  }, {\n    key: \"classList\",\n    get: function get() {\n      return this.panelClass;\n    }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    ,\n    set: function set(classes) {\n      this.panelClass = classes;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this2 = this;\n\n      this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n      this._tabSubscription = this._keyManager.tabOut.subscribe(function () {\n        return _this2.closed.emit('tab');\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._tabSubscription.unsubscribe();\n\n      this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_hovered\",\n    value: function _hovered() {\n      return this._itemChanges.pipe(startWith(this._items), switchMap(function (items) {\n        return merge.apply(void 0, _toConsumableArray(items.map(function (item) {\n          return item._hovered;\n        })));\n      }));\n    }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleKeydown\",\n    value: function _handleKeydown(event) {\n      var\n      /** @type {?} */\n      keyCode = event.keyCode;\n\n      switch (keyCode) {\n        case ESCAPE:\n          this.closed.emit('keydown');\n          event.stopPropagation();\n          break;\n\n        case LEFT_ARROW:\n          if (this.parentMenu && this.direction === 'ltr') {\n            this.closed.emit('keydown');\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (this.parentMenu && this.direction === 'rtl') {\n            this.closed.emit('keydown');\n          }\n\n          break;\n\n        default:\n          if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n            this._keyManager.setFocusOrigin('keyboard');\n          }\n\n          this._keyManager.onKeydown(event);\n\n      }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focusFirstItem\",\n    value: function focusFirstItem() {\n      var _this3 = this;\n\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n      if (this.lazyContent) {\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n          return _this3._keyManager.setFocusOrigin(origin).setFirstItemActive();\n        });\n      } else {\n        this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n      }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetActiveItem\",\n    value: function resetActiveItem() {\n      this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(depth) {\n      // The elevation starts at the base and increases by one for each level.\n      var\n      /** @type {?} */\n      newElevation = \"mat-elevation-z\".concat(MAT_MENU_BASE_ELEVATION + depth);\n      var\n      /** @type {?} */\n      customElevation = Object.keys(this._classList).find(function (c) {\n        return c.startsWith('mat-elevation-z');\n      });\n\n      if (!customElevation || customElevation === this._previousElevation) {\n        if (this._previousElevation) {\n          this._classList[this._previousElevation] = false;\n        }\n\n        this._classList[newElevation] = true;\n        this._previousElevation = newElevation;\n      }\n    }\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      // We register the items through this method, rather than picking them up through\n      // `ContentChildren`, because we need the items to be picked up by their closest\n      // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n      // all descendant items will bleed into the top-level menu in the case where the consumer\n      // has `mat-menu` instances nested inside each other.\n      if (this._items.indexOf(item) === -1) {\n        this._items.push(item);\n\n        this._itemChanges.next(this._items);\n      }\n    }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(item) {\n      var\n      /** @type {?} */\n      index = this._items.indexOf(item);\n\n      if (this._items.indexOf(item) > -1) {\n        this._items.splice(index, 1);\n\n        this._itemChanges.next(this._items);\n      }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setPositionClasses\",\n    value: function setPositionClasses() {\n      var posX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.xPosition;\n      var posY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.yPosition;\n      var\n      /** @type {?} */\n      classes = this._classList;\n      classes['mat-menu-before'] = posX === 'before';\n      classes['mat-menu-after'] = posX === 'after';\n      classes['mat-menu-above'] = posY === 'above';\n      classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_startAnimation\",\n    value: function _startAnimation() {\n      // @breaking-change 7.0.0 Combine with _resetAnimation.\n      this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_resetAnimation\",\n    value: function _resetAnimation() {\n      // @breaking-change 7.0.0 Combine with _startAnimation.\n      this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_onAnimationDone\",\n    value: function _onAnimationDone(event) {\n      this._animationDone.next(event);\n\n      this._isAnimating = false; // Scroll the content element to the top once the animation is done. This is necessary, because\n      // we move focus to the first item while it's still being animated, which can throw the browser\n      // off when it determines the scroll position. Alternatively we can move focus when the\n      // animation is done, however moving focus asynchronously will interrupt screen readers\n      // which are in the process of reading out the menu already. We take the `element` from\n      // the `event` since we can't use a `ViewChild` to access the pane.\n\n      if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n        event.element.scrollTop = 0;\n      }\n    }\n  }]);\n\n  return MatMenu;\n}();\n\nMatMenu.ɵfac = function MatMenu_Factory(t) {\n  return new (t || MatMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS));\n};\n\nMatMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: MatMenu,\n  selectors: [[\"mat-menu\"]],\n  contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuContent, 1);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 0);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n    }\n  },\n  viewQuery: function MatMenu_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(TemplateRef, 1);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n    }\n  },\n  inputs: {\n    backdropClass: \"backdropClass\",\n    xPosition: \"xPosition\",\n    yPosition: \"yPosition\",\n    overlapTrigger: \"overlapTrigger\",\n    hasBackdrop: \"hasBackdrop\",\n    panelClass: [\"class\", \"panelClass\"],\n    classList: \"classList\"\n  },\n  outputs: {\n    closed: \"closed\",\n    close: \"close\"\n  },\n  exportAs: [\"matMenu\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: MAT_MENU_PANEL,\n    useExisting: MatMenu\n  }])],\n  ngContentSelectors: _c1,\n  decls: 1,\n  vars: 0,\n  consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-menu-panel\", 3, \"ngClass\", \"keydown\", \"click\"], [1, \"mat-menu-content\"]],\n  template: function MatMenu_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 2, \"ng-template\");\n    }\n  },\n  directives: [ɵngcc3.NgClass],\n  styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:2px;outline:0}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n  encapsulation: 2,\n  data: {\n    animation: [matMenuAnimations.transformMenu, matMenuAnimations.fadeInItems]\n  },\n  changeDetection: 0\n});\n/** @nocollapse */\n\nMatMenu.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_DEFAULT_OPTIONS]\n    }]\n  }];\n};\n\nMatMenu.propDecorators = {\n  \"backdropClass\": [{\n    type: Input\n  }],\n  \"xPosition\": [{\n    type: Input\n  }],\n  \"yPosition\": [{\n    type: Input\n  }],\n  \"templateRef\": [{\n    type: ViewChild,\n    args: [TemplateRef]\n  }],\n  \"items\": [{\n    type: ContentChildren,\n    args: [MatMenuItem]\n  }],\n  \"lazyContent\": [{\n    type: ContentChild,\n    args: [MatMenuContent]\n  }],\n  \"overlapTrigger\": [{\n    type: Input\n  }],\n  \"hasBackdrop\": [{\n    type: Input\n  }],\n  \"panelClass\": [{\n    type: Input,\n    args: ['class']\n  }],\n  \"classList\": [{\n    type: Input\n  }],\n  \"closed\": [{\n    type: Output\n  }],\n  \"close\": [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenu, [{\n    type: Component,\n    args: [{\n      selector: 'mat-menu',\n      template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_isAnimating = true\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\n      styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:2px;outline:0}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      exportAs: 'matMenu',\n      animations: [matMenuAnimations.transformMenu, matMenuAnimations.fadeInItems],\n      providers: [{\n        provide: MAT_MENU_PANEL,\n        useExisting: MatMenu\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_DEFAULT_OPTIONS]\n      }]\n    }];\n  }, {\n    backdropClass: [{\n      type: Input\n    }],\n    closed: [{\n      type: Output\n    }],\n    close: [{\n      type: Output\n    }],\n    xPosition: [{\n      type: Input\n    }],\n    yPosition: [{\n      type: Input\n    }],\n    overlapTrigger: [{\n      type: Input\n    }],\n    hasBackdrop: [{\n      type: Input\n    }],\n    panelClass: [{\n      type: Input,\n      args: ['class']\n    }],\n    classList: [{\n      type: Input\n    }],\n    templateRef: [{\n      type: ViewChild,\n      args: [TemplateRef]\n    }],\n    items: [{\n      type: ContentChildren,\n      args: [MatMenuItem]\n    }],\n    lazyContent: [{\n      type: ContentChild,\n      args: [MatMenuContent]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token that determines the scroll handling while the menu is open.\n */\n\n\nvar\n/** @type {?} */\nMAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\n\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n  return function () {\n    return overlay.scrollStrategies.reposition();\n  };\n}\n/**\n * \\@docs-private\n */\n\n\nvar\n/** @type {?} */\nMAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_MENU_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY\n};\n/**\n * Default top padding of the menu panel.\n */\n\nvar\n/** @type {?} */\nMENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\n\nvar MatMenuTrigger = /*#__PURE__*/function () {\n  /**\n   * @param {?} _overlay\n   * @param {?} _element\n   * @param {?} _viewContainerRef\n   * @param {?} _scrollStrategy\n   * @param {?} _parentMenu\n   * @param {?} _menuItemInstance\n   * @param {?} _dir\n   * @param {?=} _focusMonitor\n   */\n  function MatMenuTrigger(_overlay, _element, _viewContainerRef, _scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n    _classCallCheck(this, MatMenuTrigger);\n\n    this._overlay = _overlay;\n    this._element = _element;\n    this._viewContainerRef = _viewContainerRef;\n    this._scrollStrategy = _scrollStrategy;\n    this._parentMenu = _parentMenu;\n    this._menuItemInstance = _menuItemInstance;\n    this._dir = _dir;\n    this._focusMonitor = _focusMonitor;\n    this._overlayRef = null;\n    this._menuOpen = false;\n    this._closeSubscription = Subscription.EMPTY;\n    this._hoverSubscription = Subscription.EMPTY;\n    this._openedByMouse = false;\n    /**\n     * Event emitted when the associated menu is opened.\n     */\n\n    this.menuOpened = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * \\@breaking-change 7.0.0\n     */\n\n    this.onMenuOpen = this.menuOpened;\n    /**\n     * Event emitted when the associated menu is closed.\n     */\n\n    this.menuClosed = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * \\@breaking-change 7.0.0\n     */\n\n    this.onMenuClose = this.menuClosed;\n\n    if (_menuItemInstance) {\n      _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n    }\n  }\n  /**\n   * @deprecated\n   * \\@breaking-change 7.0.0\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuTrigger, [{\n    key: \"_deprecatedMatMenuTriggerFor\",\n    get: function get() {\n      return this.menu;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    ,\n    set: function set(v) {\n      this.menu = v;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this4 = this;\n\n      this._checkMenu();\n\n      this.menu.close.subscribe(function (reason) {\n        _this4._destroyMenu(); // If a click closed the menu, we should close the entire chain of nested menus.\n\n\n        if ((reason === 'click' || reason === 'tab') && _this4._parentMenu) {\n          _this4._parentMenu.closed.emit(reason);\n        }\n      });\n\n      this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n\n        this._overlayRef = null;\n      }\n\n      this._cleanUpSubscriptions();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n\n  }, {\n    key: \"menuOpen\",\n    get: function get() {\n      return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dir\",\n    get: function get() {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n\n  }, {\n    key: \"triggersSubmenu\",\n    value: function triggersSubmenu() {\n      return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu() {\n      return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"openMenu\",\n    value: function openMenu() {\n      var _this5 = this;\n\n      if (this._menuOpen) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      overlayRef = this._createOverlay();\n\n      this._setPosition(\n      /** @type {?} */\n      overlayRef.getConfig().positionStrategy);\n\n      overlayRef.attach(this._portal);\n\n      if (this.menu.lazyContent) {\n        this.menu.lazyContent.attach(this.menuData);\n      }\n\n      this._closeSubscription = this._menuClosingActions().subscribe(function () {\n        return _this5.closeMenu();\n      });\n\n      this._initMenu();\n\n      if (this.menu instanceof MatMenu) {\n        this.menu._startAnimation();\n      }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"closeMenu\",\n    value: function closeMenu() {\n      this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      if (this._focusMonitor) {\n        this._focusMonitor.focusVia(this._element.nativeElement, origin);\n      } else {\n        this._element.nativeElement.focus();\n      }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_destroyMenu\",\n    value: function _destroyMenu() {\n      var _this6 = this;\n\n      if (!this._overlayRef || !this.menuOpen) {\n        return;\n      }\n\n      var\n      /** @type {?} */\n      menu = this.menu;\n\n      this._closeSubscription.unsubscribe();\n\n      this._overlayRef.detach();\n\n      if (menu instanceof MatMenu) {\n        menu._resetAnimation();\n\n        if (menu.lazyContent) {\n          // Wait for the exit animation to finish before detaching the content.\n          menu._animationDone.pipe(filter(function (event) {\n            return event.toState === 'void';\n          }), take(1), // Interrupt if the content got re-attached.\n          takeUntil(menu.lazyContent._attached)).subscribe(function () {\n            return (\n              /** @type {?} */\n              menu.lazyContent.detach()\n            );\n          }, undefined, function () {\n            // No matter whether the content got re-attached, reset the menu.\n            _this6._resetMenu();\n          });\n        } else {\n          this._resetMenu();\n        }\n      } else {\n        this._resetMenu();\n\n        if (menu.lazyContent) {\n          menu.lazyContent.detach();\n        }\n      }\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_initMenu\",\n    value: function _initMenu() {\n      this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n      this.menu.direction = this.dir;\n\n      this._setMenuElevation();\n\n      this._setIsMenuOpen(true);\n\n      this.menu.focusFirstItem(this._openedByMouse ? 'mouse' : 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setMenuElevation\",\n    value: function _setMenuElevation() {\n      if (this.menu.setElevation) {\n        var\n        /** @type {?} */\n        depth = 0;\n        var\n        /** @type {?} */\n        parentMenu = this.menu.parentMenu;\n\n        while (parentMenu) {\n          depth++;\n          parentMenu = parentMenu.parentMenu;\n        }\n\n        this.menu.setElevation(depth);\n      }\n    }\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_resetMenu\",\n    value: function _resetMenu() {\n      this._setIsMenuOpen(false); // We should reset focus if the user is navigating using a keyboard or\n      // if we have a top-level trigger which might cause focus to be lost\n      // when clicking on the backdrop.\n\n\n      if (!this._openedByMouse) {\n        // Note that the focus style will show up both for `program` and\n        // `keyboard` so we don't have to specify which one it is.\n        this.focus();\n      } else if (!this.triggersSubmenu()) {\n        this.focus('mouse');\n      }\n\n      this._openedByMouse = false;\n    }\n    /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setIsMenuOpen\",\n    value: function _setIsMenuOpen(isOpen) {\n      this._menuOpen = isOpen;\n      this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n\n      if (this.triggersSubmenu()) {\n        this._menuItemInstance._highlighted = isOpen;\n      }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_checkMenu\",\n    value: function _checkMenu() {\n      if (!this.menu) {\n        throwMatMenuMissingError();\n      }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_createOverlay\",\n    value: function _createOverlay() {\n      if (!this._overlayRef) {\n        this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n\n        var\n        /** @type {?} */\n        config = this._getOverlayConfig();\n\n        this._subscribeToPositions(\n        /** @type {?} */\n        config.positionStrategy);\n\n        this._overlayRef = this._overlay.create(config);\n      }\n\n      return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n\n  }, {\n    key: \"_getOverlayConfig\",\n    value: function _getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withTransformOriginOn('.mat-menu-panel'),\n        hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\n        backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n        scrollStrategy: this._scrollStrategy(),\n        direction: this._dir\n      });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n\n  }, {\n    key: \"_subscribeToPositions\",\n    value: function _subscribeToPositions(position) {\n      var _this7 = this;\n\n      if (this.menu.setPositionClasses) {\n        position.positionChanges.subscribe(function (change) {\n          var\n          /** @type {?} */\n          posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n          var\n          /** @type {?} */\n          posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n          /** @type {?} */\n\n          _this7.menu.setPositionClasses(posX, posY);\n        });\n      }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(positionStrategy) {\n      var _ref = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'],\n          _ref2 = _slicedToArray(_ref, 2),\n          originX = _ref2[0],\n          originFallbackX = _ref2[1];\n\n      var _ref3 = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'],\n          _ref4 = _slicedToArray(_ref3, 2),\n          overlayY = _ref4[0],\n          overlayFallbackY = _ref4[1];\n\n      var originY = overlayY,\n          originFallbackY = overlayFallbackY;\n      var overlayX = originX,\n          overlayFallbackX = originFallbackX;\n      var\n      /** @type {?} */\n      offsetY = 0;\n\n      if (this.triggersSubmenu()) {\n        // When the menu is a sub-menu, it should always align itself\n        // to the edges of the trigger, instead of overlapping it.\n        overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n        offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n      } else if (!this.menu.overlapTrigger) {\n        originY = overlayY === 'top' ? 'bottom' : 'top';\n        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n      }\n\n      positionStrategy.withPositions([{\n        originX: originX,\n        originY: originY,\n        overlayX: overlayX,\n        overlayY: overlayY,\n        offsetY: offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayY,\n        offsetY: offsetY\n      }, {\n        originX: originX,\n        originY: originFallbackY,\n        overlayX: overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }]);\n    }\n    /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_cleanUpSubscriptions\",\n    value: function _cleanUpSubscriptions() {\n      this._closeSubscription.unsubscribe();\n\n      this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_menuClosingActions\",\n    value: function _menuClosingActions() {\n      var _this8 = this;\n\n      var\n      /** @type {?} */\n      backdrop =\n      /** @type {?} */\n      this._overlayRef.backdropClick();\n\n      var\n      /** @type {?} */\n      detachments =\n      /** @type {?} */\n      this._overlayRef.detachments();\n\n      var\n      /** @type {?} */\n      parentClose = this._parentMenu ? this._parentMenu.closed : of();\n      var\n      /** @type {?} */\n      hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(function (active) {\n        return active !== _this8._menuItemInstance;\n      }), filter(function () {\n        return _this8._menuOpen;\n      })) : of();\n      return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleMousedown\",\n    value: function _handleMousedown(event) {\n      if (!isFakeMousedownFromScreenReader(event)) {\n        this._openedByMouse = true; // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n        // we should prevent focus from moving onto it via click to avoid the\n        // highlight from lingering on the menu item.\n\n        if (this.triggersSubmenu()) {\n          event.preventDefault();\n        }\n      }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleKeydown\",\n    value: function _handleKeydown(event) {\n      var\n      /** @type {?} */\n      keyCode = event.keyCode;\n\n      if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === 'ltr' || keyCode === LEFT_ARROW && this.dir === 'rtl')) {\n        this.openMenu();\n      }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleClick\",\n    value: function _handleClick(event) {\n      if (this.triggersSubmenu()) {\n        // Stop event propagation to avoid closing the parent menu.\n        event.stopPropagation();\n        this.openMenu();\n      } else {\n        this.toggleMenu();\n      }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleHover\",\n    value: function _handleHover() {\n      var _this9 = this;\n\n      // Subscribe to changes in the hovered item in order to toggle the panel.\n      if (!this.triggersSubmenu()) {\n        return;\n      }\n\n      this._hoverSubscription = this._parentMenu._hovered().pipe(filter(function (active) {\n        return active === _this9._menuItemInstance && !active.disabled;\n      }), delay(0, asapScheduler)).subscribe(function () {\n        _this9._openedByMouse = true; // If the same menu is used between multiple triggers, it might still be animating\n        // while the new trigger tries to re-open it. Wait for the animation to finish\n        // before doing so. Also interrupt if the user moves to another item.\n\n        if (_this9.menu instanceof MatMenu && _this9.menu._isAnimating) {\n          _this9.menu._animationDone.pipe(take(1), takeUntil(_this9._parentMenu._hovered())).subscribe(function () {\n            return _this9.openMenu();\n          });\n        } else {\n          _this9.openMenu();\n        }\n      });\n    }\n  }]);\n\n  return MatMenuTrigger;\n}();\n\nMatMenuTrigger.ɵfac = function MatMenuTrigger_Factory(t) {\n  return new (t || MatMenuTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(MatMenu, 8), ɵngcc0.ɵɵdirectiveInject(MatMenuItem, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor));\n};\n\nMatMenuTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatMenuTrigger,\n  selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]],\n  hostAttrs: [\"aria-haspopup\", \"true\"],\n  hostVars: 1,\n  hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) {\n        return ctx._handleMousedown($event);\n      })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) {\n        return ctx._handleKeydown($event);\n      })(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) {\n        return ctx._handleClick($event);\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.menuOpen || null);\n    }\n  },\n  inputs: {\n    _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"],\n    menu: [\"matMenuTriggerFor\", \"menu\"],\n    menuData: [\"matMenuTriggerData\", \"menuData\"]\n  },\n  outputs: {\n    menuOpened: \"menuOpened\",\n    onMenuOpen: \"onMenuOpen\",\n    menuClosed: \"menuClosed\",\n    onMenuClose: \"onMenuClose\"\n  },\n  exportAs: [\"matMenuTrigger\"]\n});\n/** @nocollapse */\n\nMatMenuTrigger.ctorParameters = function () {\n  return [{\n    type: Overlay\n  }, {\n    type: ElementRef\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: MatMenu,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: MatMenuItem,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }, {\n    type: Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: FocusMonitor\n  }];\n};\n\nMatMenuTrigger.propDecorators = {\n  \"_deprecatedMatMenuTriggerFor\": [{\n    type: Input,\n    args: ['mat-menu-trigger-for']\n  }],\n  \"menu\": [{\n    type: Input,\n    args: ['matMenuTriggerFor']\n  }],\n  \"menuData\": [{\n    type: Input,\n    args: ['matMenuTriggerData']\n  }],\n  \"menuOpened\": [{\n    type: Output\n  }],\n  \"onMenuOpen\": [{\n    type: Output\n  }],\n  \"menuClosed\": [{\n    type: Output\n  }],\n  \"onMenuClose\": [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: \"[mat-menu-trigger-for], [matMenuTriggerFor]\",\n      host: {\n        'aria-haspopup': 'true',\n        '[attr.aria-expanded]': 'menuOpen || null',\n        '(mousedown)': '_handleMousedown($event)',\n        '(keydown)': '_handleKeydown($event)',\n        '(click)': '_handleClick($event)'\n      },\n      exportAs: 'matMenuTrigger'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc4.Overlay\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_SCROLL_STRATEGY]\n      }]\n    }, {\n      type: MatMenu,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: MatMenuItem,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }]\n    }, {\n      type: ɵngcc5.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc1.FocusMonitor\n    }];\n  }, {\n    menuOpened: [{\n      type: Output\n    }],\n    onMenuOpen: [{\n      type: Output\n    }],\n    menuClosed: [{\n      type: Output\n    }],\n    onMenuClose: [{\n      type: Output\n    }],\n    _deprecatedMatMenuTriggerFor: [{\n      type: Input,\n      args: ['mat-menu-trigger-for']\n    }],\n    menu: [{\n      type: Input,\n      args: ['matMenuTriggerFor']\n    }],\n    menuData: [{\n      type: Input,\n      args: ['matMenuTriggerData']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar MatMenuModule = function MatMenuModule() {\n  _classCallCheck(this, MatMenuModule);\n};\n\nMatMenuModule.ɵfac = function MatMenuModule_Factory(t) {\n  return new (t || MatMenuModule)();\n};\n\nMatMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: MatMenuModule\n});\nMatMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],\n  imports: [[CommonModule, MatCommonModule, MatRippleModule, OverlayModule], MatCommonModule]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMenuModule, {\n    declarations: function declarations() {\n      return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent];\n    },\n    imports: function imports() {\n      return [CommonModule, MatCommonModule, MatRippleModule, OverlayModule];\n    },\n    exports: function exports() {\n      return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule];\n    }\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, MatCommonModule, MatRippleModule, OverlayModule],\n      exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\n      declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\n      providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵa24, MatMenuItemBase as ɵb24, _MatMenuItemMixinBase as ɵc24, MAT_MENU_PANEL as ɵf24, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵd24, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵe24 }; //# sourceMappingURL=menu.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/@angular/material/__ivy_ngcc__/esm2015/menu.js"],"names":["Directive","TemplateRef","ComponentFactoryResolver","ApplicationRef","Injector","ViewContainerRef","Inject","InjectionToken","ChangeDetectionStrategy","Component","ElementRef","ViewEncapsulation","Optional","ContentChild","ContentChildren","EventEmitter","Input","NgZone","Output","ViewChild","Self","NgModule","TemplatePortal","DomPortalOutlet","DOCUMENT","CommonModule","Subject","merge","Subscription","asapScheduler","of","trigger","state","style","animate","transition","query","group","sequence","FocusMonitor","FocusKeyManager","isFakeMousedownFromScreenReader","mixinDisabled","mixinDisableRipple","MatCommonModule","MatRippleModule","coerceBooleanProperty","ESCAPE","LEFT_ARROW","RIGHT_ARROW","DOWN_ARROW","UP_ARROW","startWith","switchMap","take","delay","filter","takeUntil","Directionality","Overlay","OverlayConfig","OverlayModule","ɵngcc0","ɵngcc1","ɵngcc2","ɵngcc3","ɵngcc4","ɵngcc5","_c0","_c1","MatMenu_ng_template_0_Template","rf","ctx","_r2","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","MatMenu_ng_template_0_Template_div_keydown_0_listener","$event","ɵɵrestoreView","ctx_r1","ɵɵnextContext","_handleKeydown","MatMenu_ng_template_0_Template_div_click_0_listener","ctx_r3","closed","emit","MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener","ctx_r4","_isAnimating","MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener","ctx_r5","_onAnimationDone","ɵɵprojection","ɵɵelementEnd","ctx_r0","ɵɵproperty","_classList","_panelAnimationState","MatMenuContent","_template","_componentFactoryResolver","_appRef","_injector","_viewContainerRef","_document","_attached","context","_portal","detach","_outlet","createElement","element","elementRef","nativeElement","parentNode","insertBefore","outletElement","attach","next","isAttached","dispose","ɵfac","MatMenuContent_Factory","t","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","type","selectors","ctorParameters","undefined","decorators","args","ngDevMode","ɵsetClassMetadata","selector","matMenuAnimations","transformMenu","opacity","transform","fadeInItems","throwMatMenuMissingError","Error","throwMatMenuInvalidPositionX","throwMatMenuInvalidPositionY","MAT_MENU_PANEL","MatMenuItemBase","_MatMenuItemMixinBase","MatMenuItem","_elementRef","document","_focusMonitor","_parentMenu","_hovered","_highlighted","_triggersSubmenu","monitor","_getHostElement","addItem","origin","focusVia","focus","stopMonitoring","removeItem","complete","disabled","event","preventDefault","stopPropagation","textNodeType","TEXT_NODE","output","childNodes","length","i","nodeType","textContent","trim","MatMenuItem_Factory","ɵcmp","ɵɵdefineComponent","hostAttrs","hostVars","hostBindings","MatMenuItem_HostBindings","MatMenuItem_click_HostBindingHandler","_checkDisabled","MatMenuItem_mouseenter_HostBindingHandler","_handleMouseEnter","ɵɵattribute","_getTabIndex","toString","ɵɵclassProp","inputs","disableRipple","exportAs","features","ɵɵInheritDefinitionFeature","attrs","ngContentSelectors","decls","vars","consts","template","MatMenuItem_Template","ɵɵprojectionDef","ɵɵelement","ɵɵadvance","directives","MatRipple","encapsulation","changeDetection","host","OnPush","None","MAT_MENU_DEFAULT_OPTIONS","providedIn","factory","MAT_MENU_DEFAULT_OPTIONS_FACTORY","overlapTrigger","xPosition","yPosition","backdropClass","MAT_MENU_BASE_ELEVATION","MatMenu","_ngZone","_defaultOptions","_xPosition","_yPosition","_items","_itemChanges","_tabSubscription","EMPTY","_animationDone","_overlapTrigger","_hasBackdrop","hasBackdrop","close","value","setPositionClasses","classes","split","reduce","obj","className","panelClass","_keyManager","withWrap","withTypeAhead","tabOut","subscribe","unsubscribe","pipe","items","map","item","keyCode","parentMenu","direction","setFocusOrigin","onKeydown","lazyContent","onStable","asObservable","setFirstItemActive","setActiveItem","depth","newElevation","customElevation","Object","keys","find","c","startsWith","_previousElevation","indexOf","push","index","splice","posX","posY","toState","activeItemIndex","scrollTop","MatMenu_Factory","contentQueries","MatMenu_ContentQueries","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","first","viewQuery","MatMenu_Query","ɵɵviewQuery","templateRef","classList","outputs","ɵɵProvidersFeature","provide","useExisting","MatMenu_Template","ɵɵtemplate","NgClass","styles","data","animation","propDecorators","animations","providers","MAT_MENU_SCROLL_STRATEGY","MAT_MENU_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","useFactory","MENU_PANEL_TOP_PADDING","MatMenuTrigger","_overlay","_element","_scrollStrategy","_menuItemInstance","_dir","_overlayRef","_menuOpen","_closeSubscription","_hoverSubscription","_openedByMouse","menuOpened","onMenuOpen","menuClosed","onMenuClose","triggersSubmenu","menu","v","_checkMenu","reason","_destroyMenu","_handleHover","_cleanUpSubscriptions","closeMenu","openMenu","overlayRef","_createOverlay","_setPosition","getConfig","positionStrategy","menuData","_menuClosingActions","_initMenu","_startAnimation","menuOpen","_resetAnimation","_resetMenu","dir","_setMenuElevation","_setIsMenuOpen","focusFirstItem","setElevation","isOpen","config","_getOverlayConfig","_subscribeToPositions","create","position","flexibleConnectedTo","withTransformOriginOn","scrollStrategy","positionChanges","change","connectionPair","overlayX","overlayY","originX","originFallbackX","overlayFallbackY","originY","originFallbackY","overlayFallbackX","offsetY","withPositions","backdrop","backdropClick","detachments","parentClose","hover","active","toggleMenu","MatMenuTrigger_Factory","MatMenuTrigger_HostBindings","MatMenuTrigger_mousedown_HostBindingHandler","_handleMousedown","MatMenuTrigger_keydown_HostBindingHandler","MatMenuTrigger_click_HostBindingHandler","_handleClick","_deprecatedMatMenuTriggerFor","MatMenuModule","MatMenuModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","ngJitMode","ɵɵsetNgModuleScope","declarations","exports","ɵa24","ɵb24","ɵc24","ɵf24","ɵd24","ɵe24"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { trigger, state, style, animate, transition, query, group, sequence } from '@angular/animations';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nimport * as ɵngcc5 from '@angular/cdk/bidi';\n\nconst _c0 = [\"mat-menu-item\", \"\"];\nconst _c1 = [\"*\"];\nfunction MatMenu_ng_template_0_Template(rf, ctx) { if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n    ɵngcc0.ɵɵlistener(\"keydown\", function MatMenu_ng_template_0_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1._handleKeydown($event); })(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.closed.emit(\"click\"); })(\"@transformMenu.start\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4._isAnimating = true; })(\"@transformMenu.done\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5._onAnimationDone($event); });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r0._classList)(\"@transformMenu\", ctx_r0._panelAnimationState);\n} }\nclass MatMenuContent {\n    /**\n     * @param {?} _template\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     */\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n        /**\n         * Emits when the menu content has been attached.\n         */\n        this._attached = new Subject();\n    }\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    attach(context = {}) {\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n        }\n        const /** @type {?} */ element = this._template.elementRef.nativeElement; /** @type {?} */\n        ((\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        element.parentNode)).insertBefore(this._outlet.outletElement, element);\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    detach() {\n        if (this._portal.isAttached) {\n            this._portal.detach();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._outlet) {\n            this._outlet.dispose();\n        }\n    }\n}\nMatMenuContent.ɵfac = function MatMenuContent_Factory(t) { return new (t || MatMenuContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };\nMatMenuContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatMenuContent, selectors: [[\"ng-template\", \"matMenuContent\", \"\"]] });\n/** @nocollapse */\nMatMenuContent.ctorParameters = () => [\n    { type: TemplateRef, },\n    { type: ComponentFactoryResolver, },\n    { type: ApplicationRef, },\n    { type: Injector, },\n    { type: ViewContainerRef, },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuContent, [{\n        type: Directive,\n        args: [{\n                selector: 'ng-template[matMenuContent]'\n            }]\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n */\nconst /** @type {?} */ matMenuAnimations = {\n    /**\n       * This animation controls the menu panel's entry and exit from the page.\n       *\n       * When the menu panel is added to the DOM, it scales in and fades in its border.\n       *\n       * When the menu panel is removed from the DOM, it simply fades out after a brief\n       * delay to display the ripple.\n       */\n    transformMenu: trigger('transformMenu', [\n        state('void', style({\n            opacity: 0,\n            // This starts off from 0.01, instead of 0, because there's an issue in the Angular animations\n            // as of 4.2, which causes the animation to be skipped if it starts from 0.\n            transform: 'scale(0.01, 0.01)'\n        })),\n        transition('void => enter', sequence([\n            query('.mat-menu-content', style({ opacity: 0 })),\n            animate('100ms linear', style({ opacity: 1, transform: 'scale(1, 0.5)' })),\n            group([\n                query('.mat-menu-content', animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', style({ opacity: 1 }))),\n                animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({ transform: 'scale(1, 1)' })),\n            ])\n        ])),\n        transition('* => void', animate('150ms 50ms linear', style({ opacity: 0 })))\n    ]),\n    /**\n       * This animation fades in the background color and content of the menu panel\n       * after its containing element is scaled in.\n       */\n    fadeInItems: trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        state('showing', style({ opacity: 1 })),\n        transition('void => *', [\n            style({ opacity: 0 }),\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@breaking-change 7.0.0\n */\nconst /** @type {?} */ fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@breaking-change 7.0.0\n */\nconst /** @type {?} */ transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(`mat-menu-trigger: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(`x-position value must be either 'before' or after'.\n      Example: <mat-menu x-position=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(`y-position value must be either 'above' or below'.\n      Example: <mat-menu y-position=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n */\nconst /** @type {?} */ MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatMenuItemBase {\n}\nconst /** @type {?} */ _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nclass MatMenuItem extends _MatMenuItemMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?=} document\n     * @param {?=} _focusMonitor\n     * @param {?=} _parentMenu\n     */\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\n        // @breaking-change 7.0.0 make `_focusMonitor` and `document` required params.\n        super();\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._parentMenu = _parentMenu;\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        this._hovered = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(this._getHostElement(), false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(this);\n        }\n        this._document = document;\n    }\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n    focus(origin = 'program') {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin);\n        }\n        else {\n            this._getHostElement().focus();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._getHostElement());\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    _checkDisabled(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    _handleMouseEnter() {\n        this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    getLabel() {\n        const /** @type {?} */ element = this._elementRef.nativeElement;\n        const /** @type {?} */ textNodeType = this._document ? this._document.TEXT_NODE : 3;\n        let /** @type {?} */ output = '';\n        if (element.childNodes) {\n            const /** @type {?} */ length = element.childNodes.length;\n            // Go through all the top-level text nodes and extract their text.\n            // We skip anything that's not a text node to prevent the text from\n            // being thrown off by something like an icon.\n            for (let /** @type {?} */ i = 0; i < length; i++) {\n                if (element.childNodes[i].nodeType === textNodeType) {\n                    output += element.childNodes[i].textContent;\n                }\n            }\n        }\n        return output.trim();\n    }\n}\nMatMenuItem.ɵfac = function MatMenuItem_Factory(t) { return new (t || MatMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8)); };\nMatMenuItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatMenuItem, selectors: [[\"\", \"mat-menu-item\", \"\"]], hostAttrs: [\"role\", \"menuitem\", 1, \"mat-menu-item\"], hostVars: 7, hostBindings: function MatMenuItem_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) { return ctx._checkDisabled($event); })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() { return ctx._handleMouseEnter(); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled.toString())(\"disabled\", ctx.disabled || null);\n        ɵngcc0.ɵɵclassProp(\"mat-menu-item-highlighted\", ctx._highlighted)(\"mat-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n    } }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\" }, exportAs: [\"matMenuItem\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c0, ngContentSelectors: _c1, decls: 2, vars: 2, consts: [[\"matRipple\", \"\", 1, \"mat-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"]], template: function MatMenuItem_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelement(1, \"div\", 0);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n    } }, directives: [ɵngcc2.MatRipple], encapsulation: 2, changeDetection: 0 });\n/** @nocollapse */\nMatMenuItem.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    { type: FocusMonitor, },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional },] },\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuItem, [{\n        type: Component,\n        args: [{ selector: '[mat-menu-item]',\n                exportAs: 'matMenuItem',\n                inputs: ['disabled', 'disableRipple'],\n                host: {\n                    'role': 'menuitem',\n                    'class': 'mat-menu-item',\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n                    '[attr.tabindex]': '_getTabIndex()',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.disabled]': 'disabled || null',\n                    '(click)': '_checkDisabled($event)',\n                    '(mouseenter)': '_handleMouseEnter()'\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\" }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ɵngcc1.FocusMonitor }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_PANEL]\n            }, {\n                type: Optional\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n */\nconst /** @type {?} */ MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: true,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n */\nconst /** @type {?} */ MAT_MENU_BASE_ELEVATION = 2;\nclass MatMenu {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} _defaultOptions\n     */\n    constructor(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Menu items inside the current menu.\n         */\n        this._items = [];\n        /**\n         * Emits whenever the amount of menu items changes.\n         */\n        this._itemChanges = new Subject();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@breaking-change 7.0.0\n         */\n        this.close = this.closed;\n    }\n    /**\n     * Position of the menu in the X axis.\n     * @return {?}\n     */\n    get xPosition() { return this._xPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set xPosition(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMatMenuInvalidPositionX();\n        }\n        this._xPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n    get yPosition() { return this._yPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set yPosition(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMatMenuInvalidPositionY();\n        }\n        this._yPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n    get overlapTrigger() { return this._overlapTrigger; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set overlapTrigger(value) {\n        this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n    get hasBackdrop() { return this._hasBackdrop; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hasBackdrop(value) {\n        this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n    set panelClass(classes) {\n        if (classes && classes.length) {\n            this._classList = classes.split(' ').reduce((obj, className) => {\n                obj[className] = true;\n                return obj;\n            }, {});\n            this._elementRef.nativeElement.className = '';\n        }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 7.0.0\n     * @return {?}\n     */\n    get classList() { return this.panelClass; }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    set classList(classes) { this.panelClass = classes; }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n        this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._tabSubscription.unsubscribe();\n        this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    _hovered() {\n        return this._itemChanges.pipe(startWith(this._items), switchMap(items => merge(...items.map(item => item._hovered))));\n    }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        const /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case ESCAPE:\n                this.closed.emit('keydown');\n                event.stopPropagation();\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    this._keyManager.setFocusOrigin('keyboard');\n                }\n                this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    focusFirstItem(origin = 'program') {\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n        if (this.lazyContent) {\n            this._ngZone.onStable.asObservable()\n                .pipe(take(1))\n                .subscribe(() => this._keyManager.setFocusOrigin(origin).setFirstItemActive());\n        }\n        else {\n            this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n        }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    resetActiveItem() {\n        this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    setElevation(depth) {\n        // The elevation starts at the base and increases by one for each level.\n        const /** @type {?} */ newElevation = `mat-elevation-z${MAT_MENU_BASE_ELEVATION + depth}`;\n        const /** @type {?} */ customElevation = Object.keys(this._classList).find(c => c.startsWith('mat-elevation-z'));\n        if (!customElevation || customElevation === this._previousElevation) {\n            if (this._previousElevation) {\n                this._classList[this._previousElevation] = false;\n            }\n            this._classList[newElevation] = true;\n            this._previousElevation = newElevation;\n        }\n    }\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    addItem(item) {\n        // We register the items through this method, rather than picking them up through\n        // `ContentChildren`, because we need the items to be picked up by their closest\n        // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n        // all descendant items will bleed into the top-level menu in the case where the consumer\n        // has `mat-menu` instances nested inside each other.\n        if (this._items.indexOf(item) === -1) {\n            this._items.push(item);\n            this._itemChanges.next(this._items);\n        }\n    }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    removeItem(item) {\n        const /** @type {?} */ index = this._items.indexOf(item);\n        if (this._items.indexOf(item) > -1) {\n            this._items.splice(index, 1);\n            this._itemChanges.next(this._items);\n        }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n        const /** @type {?} */ classes = this._classList;\n        classes['mat-menu-before'] = posX === 'before';\n        classes['mat-menu-after'] = posX === 'after';\n        classes['mat-menu-above'] = posY === 'above';\n        classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    _startAnimation() {\n        // @breaking-change 7.0.0 Combine with _resetAnimation.\n        this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    _resetAnimation() {\n        // @breaking-change 7.0.0 Combine with _startAnimation.\n        this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationDone(event) {\n        this._animationDone.next(event);\n        this._isAnimating = false;\n        // Scroll the content element to the top once the animation is done. This is necessary, because\n        // we move focus to the first item while it's still being animated, which can throw the browser\n        // off when it determines the scroll position. Alternatively we can move focus when the\n        // animation is done, however moving focus asynchronously will interrupt screen readers\n        // which are in the process of reading out the menu already. We take the `element` from\n        // the `event` since we can't use a `ViewChild` to access the pane.\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n            event.element.scrollTop = 0;\n        }\n    }\n}\nMatMenu.ɵfac = function MatMenu_Factory(t) { return new (t || MatMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS)); };\nMatMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatMenu, selectors: [[\"mat-menu\"]], contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuContent, 1);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 0);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n    } }, viewQuery: function MatMenu_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 1);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n    } }, inputs: { backdropClass: \"backdropClass\", xPosition: \"xPosition\", yPosition: \"yPosition\", overlapTrigger: \"overlapTrigger\", hasBackdrop: \"hasBackdrop\", panelClass: [\"class\", \"panelClass\"], classList: \"classList\" }, outputs: { closed: \"closed\", close: \"close\" }, exportAs: [\"matMenu\"], features: [ɵngcc0.ɵɵProvidersFeature([\n            { provide: MAT_MENU_PANEL, useExisting: MatMenu }\n        ])], ngContentSelectors: _c1, decls: 1, vars: 0, consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-menu-panel\", 3, \"ngClass\", \"keydown\", \"click\"], [1, \"mat-menu-content\"]], template: function MatMenu_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 2, \"ng-template\");\n    } }, directives: [ɵngcc3.NgClass], styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:2px;outline:0}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"], encapsulation: 2, data: { animation: [\n            matMenuAnimations.transformMenu,\n            matMenuAnimations.fadeInItems\n        ] }, changeDetection: 0 });\n/** @nocollapse */\nMatMenu.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: NgZone, },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] },] },\n];\nMatMenu.propDecorators = {\n    \"backdropClass\": [{ type: Input },],\n    \"xPosition\": [{ type: Input },],\n    \"yPosition\": [{ type: Input },],\n    \"templateRef\": [{ type: ViewChild, args: [TemplateRef,] },],\n    \"items\": [{ type: ContentChildren, args: [MatMenuItem,] },],\n    \"lazyContent\": [{ type: ContentChild, args: [MatMenuContent,] },],\n    \"overlapTrigger\": [{ type: Input },],\n    \"hasBackdrop\": [{ type: Input },],\n    \"panelClass\": [{ type: Input, args: ['class',] },],\n    \"classList\": [{ type: Input },],\n    \"closed\": [{ type: Output },],\n    \"close\": [{ type: Output },],\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenu, [{\n        type: Component,\n        args: [{ selector: 'mat-menu',\n                template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_isAnimating = true\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:2px;outline:0}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matMenu',\n                animations: [\n                    matMenuAnimations.transformMenu,\n                    matMenuAnimations.fadeInItems\n                ], providers: [\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu }\n                ]\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_DEFAULT_OPTIONS]\n            }] }]; }, { backdropClass: [{\n            type: Input\n        }], closed: [{\n            type: Output\n        }], close: [{\n            type: Output\n        }], xPosition: [{\n            type: Input\n        }], yPosition: [{\n            type: Input\n        }], overlapTrigger: [{\n            type: Input\n        }], hasBackdrop: [{\n            type: Input\n        }], panelClass: [{\n            type: Input,\n            args: ['class']\n        }], classList: [{\n            type: Input\n        }], templateRef: [{\n            type: ViewChild,\n            args: [TemplateRef]\n        }], items: [{\n            type: ContentChildren,\n            args: [MatMenuItem]\n        }], lazyContent: [{\n            type: ContentChild,\n            args: [MatMenuContent]\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n */\nconst /** @type {?} */ MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/**\n * \\@docs-private\n */\nconst /** @type {?} */ MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n */\nconst /** @type {?} */ MENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nclass MatMenuTrigger {\n    /**\n     * @param {?} _overlay\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} _scrollStrategy\n     * @param {?} _parentMenu\n     * @param {?} _menuItemInstance\n     * @param {?} _dir\n     * @param {?=} _focusMonitor\n     */\n    constructor(_overlay, _element, _viewContainerRef, _scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._scrollStrategy = _scrollStrategy;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closeSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        this._openedByMouse = false;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@breaking-change 7.0.0\n         */\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@breaking-change 7.0.0\n         */\n        this.onMenuClose = this.menuClosed;\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n    }\n    /**\n     * @deprecated\n     * \\@breaking-change 7.0.0\n     * @return {?}\n     */\n    get _deprecatedMatMenuTriggerFor() {\n        return this.menu;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set _deprecatedMatMenuTriggerFor(v) {\n        this.menu = v;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._checkMenu();\n        this.menu.close.subscribe(reason => {\n            this._destroyMenu();\n            // If a click closed the menu, we should close the entire chain of nested menus.\n            if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\n                this._parentMenu.closed.emit(reason);\n            }\n        });\n        this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._cleanUpSubscriptions();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n    get menuOpen() {\n        return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    triggersSubmenu() {\n        return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    toggleMenu() {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    openMenu() {\n        if (this._menuOpen) {\n            return;\n        }\n        const /** @type {?} */ overlayRef = this._createOverlay();\n        this._setPosition(/** @type {?} */ (overlayRef.getConfig().positionStrategy));\n        overlayRef.attach(this._portal);\n        if (this.menu.lazyContent) {\n            this.menu.lazyContent.attach(this.menuData);\n        }\n        this._closeSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\n        this._initMenu();\n        if (this.menu instanceof MatMenu) {\n            this.menu._startAnimation();\n        }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    closeMenu() {\n        this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n    focus(origin = 'program') {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._element.nativeElement, origin);\n        }\n        else {\n            this._element.nativeElement.focus();\n        }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n    _destroyMenu() {\n        if (!this._overlayRef || !this.menuOpen) {\n            return;\n        }\n        const /** @type {?} */ menu = this.menu;\n        this._closeSubscription.unsubscribe();\n        this._overlayRef.detach();\n        if (menu instanceof MatMenu) {\n            menu._resetAnimation();\n            if (menu.lazyContent) {\n                // Wait for the exit animation to finish before detaching the content.\n                menu._animationDone\n                    .pipe(filter(event => event.toState === 'void'), take(1), \n                // Interrupt if the content got re-attached.\n                takeUntil(menu.lazyContent._attached))\n                    .subscribe(() => /** @type {?} */ ((menu.lazyContent)).detach(), undefined, () => {\n                    // No matter whether the content got re-attached, reset the menu.\n                    this._resetMenu();\n                });\n            }\n            else {\n                this._resetMenu();\n            }\n        }\n        else {\n            this._resetMenu();\n            if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        }\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n    _initMenu() {\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n        this.menu.direction = this.dir;\n        this._setMenuElevation();\n        this._setIsMenuOpen(true);\n        this.menu.focusFirstItem(this._openedByMouse ? 'mouse' : 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n    _setMenuElevation() {\n        if (this.menu.setElevation) {\n            let /** @type {?} */ depth = 0;\n            let /** @type {?} */ parentMenu = this.menu.parentMenu;\n            while (parentMenu) {\n                depth++;\n                parentMenu = parentMenu.parentMenu;\n            }\n            this.menu.setElevation(depth);\n        }\n    }\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n    _resetMenu() {\n        this._setIsMenuOpen(false);\n        // We should reset focus if the user is navigating using a keyboard or\n        // if we have a top-level trigger which might cause focus to be lost\n        // when clicking on the backdrop.\n        if (!this._openedByMouse) {\n            // Note that the focus style will show up both for `program` and\n            // `keyboard` so we don't have to specify which one it is.\n            this.focus();\n        }\n        else if (!this.triggersSubmenu()) {\n            this.focus('mouse');\n        }\n        this._openedByMouse = false;\n    }\n    /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n    _setIsMenuOpen(isOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n            this._menuItemInstance._highlighted = isOpen;\n        }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n    _checkMenu() {\n        if (!this.menu) {\n            throwMatMenuMissingError();\n        }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n            const /** @type {?} */ config = this._getOverlayConfig();\n            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\n            this._overlayRef = this._overlay.create(config);\n        }\n        return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withTransformOriginOn('.mat-menu-panel'),\n            hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir\n        });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n    _subscribeToPositions(position) {\n        if (this.menu.setPositionClasses) {\n            position.positionChanges.subscribe(change => {\n                const /** @type {?} */ posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                const /** @type {?} */ posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above'; /** @type {?} */\n                ((this.menu.setPositionClasses))(posX, posY);\n            });\n        }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    _setPosition(positionStrategy) {\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        let /** @type {?} */ offsetY = 0;\n        if (this.triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n        }\n        else if (!this.menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX, originY, overlayX, overlayY, offsetY },\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ]);\n    }\n    /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n    _cleanUpSubscriptions() {\n        this._closeSubscription.unsubscribe();\n        this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n    _menuClosingActions() {\n        const /** @type {?} */ backdrop = /** @type {?} */ ((this._overlayRef)).backdropClick();\n        const /** @type {?} */ detachments = /** @type {?} */ ((this._overlayRef)).detachments();\n        const /** @type {?} */ parentClose = this._parentMenu ? this._parentMenu.closed : of();\n        const /** @type {?} */ hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(active => active !== this._menuItemInstance), filter(() => this._menuOpen)) : of();\n        return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleMousedown(event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            this._openedByMouse = true;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        const /** @type {?} */ keyCode = event.keyCode;\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this.openMenu();\n        }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n    _handleHover() {\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (!this.triggersSubmenu()) {\n            return;\n        }\n        this._hoverSubscription = this._parentMenu._hovered()\n            .pipe(filter(active => active === this._menuItemInstance && !active.disabled), delay(0, asapScheduler))\n            .subscribe(() => {\n            this._openedByMouse = true;\n            // If the same menu is used between multiple triggers, it might still be animating\n            // while the new trigger tries to re-open it. Wait for the animation to finish\n            // before doing so. Also interrupt if the user moves to another item.\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\n                this.menu._animationDone\n                    .pipe(take(1), takeUntil(this._parentMenu._hovered()))\n                    .subscribe(() => this.openMenu());\n            }\n            else {\n                this.openMenu();\n            }\n        });\n    }\n}\nMatMenuTrigger.ɵfac = function MatMenuTrigger_Factory(t) { return new (t || MatMenuTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(MatMenu, 8), ɵngcc0.ɵɵdirectiveInject(MatMenuItem, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor)); };\nMatMenuTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatMenuTrigger, selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]], hostAttrs: [\"aria-haspopup\", \"true\"], hostVars: 1, hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) { return ctx._handleMousedown($event); })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) { return ctx._handleClick($event); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.menuOpen || null);\n    } }, inputs: { _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"], menu: [\"matMenuTriggerFor\", \"menu\"], menuData: [\"matMenuTriggerData\", \"menuData\"] }, outputs: { menuOpened: \"menuOpened\", onMenuOpen: \"onMenuOpen\", menuClosed: \"menuClosed\", onMenuClose: \"onMenuClose\" }, exportAs: [\"matMenuTrigger\"] });\n/** @nocollapse */\nMatMenuTrigger.ctorParameters = () => [\n    { type: Overlay, },\n    { type: ElementRef, },\n    { type: ViewContainerRef, },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] },] },\n    { type: MatMenu, decorators: [{ type: Optional },] },\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self },] },\n    { type: Directionality, decorators: [{ type: Optional },] },\n    { type: FocusMonitor, },\n];\nMatMenuTrigger.propDecorators = {\n    \"_deprecatedMatMenuTriggerFor\": [{ type: Input, args: ['mat-menu-trigger-for',] },],\n    \"menu\": [{ type: Input, args: ['matMenuTriggerFor',] },],\n    \"menuData\": [{ type: Input, args: ['matMenuTriggerData',] },],\n    \"menuOpened\": [{ type: Output },],\n    \"onMenuOpen\": [{ type: Output },],\n    \"menuClosed\": [{ type: Output },],\n    \"onMenuClose\": [{ type: Output },],\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuTrigger, [{\n        type: Directive,\n        args: [{\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\n                host: {\n                    'aria-haspopup': 'true',\n                    '[attr.aria-expanded]': 'menuOpen || null',\n                    '(mousedown)': '_handleMousedown($event)',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(click)': '_handleClick($event)'\n                },\n                exportAs: 'matMenuTrigger'\n            }]\n    }], function () { return [{ type: ɵngcc4.Overlay }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_SCROLL_STRATEGY]\n            }] }, { type: MatMenu, decorators: [{\n                type: Optional\n            }] }, { type: MatMenuItem, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }] }, { type: ɵngcc5.Directionality, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc1.FocusMonitor }]; }, { menuOpened: [{\n            type: Output\n        }], onMenuOpen: [{\n            type: Output\n        }], menuClosed: [{\n            type: Output\n        }], onMenuClose: [{\n            type: Output\n        }], _deprecatedMatMenuTriggerFor: [{\n            type: Input,\n            args: ['mat-menu-trigger-for']\n        }], menu: [{\n            type: Input,\n            args: ['matMenuTriggerFor']\n        }], menuData: [{\n            type: Input,\n            args: ['matMenuTriggerData']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass MatMenuModule {\n}\nMatMenuModule.ɵfac = function MatMenuModule_Factory(t) { return new (t || MatMenuModule)(); };\nMatMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatMenuModule });\nMatMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\n            CommonModule,\n            MatCommonModule,\n            MatRippleModule,\n            OverlayModule,\n        ], MatCommonModule] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMenuModule, { declarations: function () { return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent]; }, imports: function () { return [CommonModule,\n        MatCommonModule,\n        MatRippleModule,\n        OverlayModule]; }, exports: function () { return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule]; } }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    CommonModule,\n                    MatCommonModule,\n                    MatRippleModule,\n                    OverlayModule,\n                ],\n                exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\n                declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵa24, MatMenuItemBase as ɵb24, _MatMenuItemMixinBase as ɵc24, MAT_MENU_PANEL as ɵf24, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵd24, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵe24 };\n\n//# sourceMappingURL=menu.js.map"]},"metadata":{},"sourceType":"module"}