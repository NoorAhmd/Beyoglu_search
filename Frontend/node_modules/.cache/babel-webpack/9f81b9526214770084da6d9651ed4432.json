{"ast":null,"code":"/**\n * @module ol/reproj\n */\nimport { createCanvasContext2D } from './dom.js';\nimport { containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { solveLinearSystem } from './math.js';\nimport { getPointResolution, transform } from './proj.js';\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {module:ol/proj/Projection} sourceProj Source projection.\n * @param {module:ol/proj/Projection} targetProj Target projection.\n * @param {module:ol/coordinate~Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\n\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data\n\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  } // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n\n  var sourceExtent = sourceProj.getExtent();\n\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.\n */\n\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {module:ol/extent~Extent} targetExtent Target extent.\n * @param {module:ol/reproj/Triangulation} triangulation\n * Calculated triangulation.\n * @param {Array.<{extent: module:ol/extent~Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\n\n\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n  var targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0],\n        y0 = source[0][1];\n    var x1 = source[1][0],\n        y1 = source[1][1];\n    var x2 = source[2][0],\n        y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n\n  return context.canvas;\n} //# sourceMappingURL=reproj.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/reproj.js"],"names":["createCanvasContext2D","containsCoordinate","createEmpty","extend","getHeight","getTopLeft","getWidth","solveLinearSystem","getPointResolution","transform","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","undefined","sourceMetersPerUnit","sourceExtent","getExtent","compensationFactor","isFinite","enlargeClipPoint","centroidX","centroidY","x","y","dX","dY","distance","Math","sqrt","round","render","width","height","pixelRatio","targetExtent","triangulation","sources","gutter","opt_renderEdges","context","length","canvas","scale","sourceDataExtent","forEach","src","i","arr","extent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","image","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","u1","v1","u2","v2","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","save","beginPath","p0","p1","p2","moveTo","lineTo","clip","translate","restore","strokeStyle","lineWidth","closePath","stroke"],"mappings":"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","sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D} from './dom.js';\nimport {containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {module:ol/proj/Projection} sourceProj Source projection.\n * @param {module:ol/proj/Projection} targetProj Target projection.\n * @param {module:ol/coordinate~Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj,\n  targetCenter, targetResolution) {\n\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n        sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {module:ol/extent~Extent} targetExtent Target extent.\n * @param {module:ol/reproj/Triangulation} triangulation\n * Calculated triangulation.\n * @param {Array.<{extent: module:ol/extent~Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio,\n  sourceResolution, sourceExtent, targetResolution, targetExtent,\n  triangulation, sources, gutter, opt_renderEdges) {\n\n  var context = createCanvasContext2D(Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function(src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(\n    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  var stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function(src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n\n    stitchContext.drawImage(\n      src.image,\n      gutter, gutter,\n      src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n      xPos * stitchScale, yPos * stitchScale,\n      srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  var targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0], y0 = source[0][1];\n    var x1 = source[1][0], y1 = source[1][1];\n    var x2 = source[2][0], y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    var augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n\n    context.transform(\n      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY);\n\n    context.scale(sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio);\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n\n//# sourceMappingURL=reproj.js.map"]},"metadata":{},"sourceType":"module"}