{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport { asString } from '../../color.js';\nimport { snap } from '../../geom/flat/simplify.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport CanvasInstruction, { fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction } from '../canvas/Instruction.js';\nimport CanvasReplay from '../canvas/Replay.js';\n\nvar CanvasPolygonReplay = function (CanvasReplay) {\n  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if (CanvasReplay) CanvasPolygonReplay.__proto__ = CanvasReplay;\n  CanvasPolygonReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    var this$1 = this;\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this$1.coordinates.length;\n      var myEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this$1.instructions.push(moveToLineToInstruction);\n      this$1.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this$1.instructions.push(closePathInstruction);\n        this$1.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    this.endGeometry(circleGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n    var this$1 = this;\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this$1.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.finish = function finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    var tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   */\n\n\n  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_(geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonReplay;\n}(CanvasReplay);\n\nexport default CanvasPolygonReplay; //# sourceMappingURL=PolygonReplay.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/render/canvas/PolygonReplay.js"],"names":["asString","snap","defaultFillStyle","CanvasInstruction","fillInstruction","strokeInstruction","beginPathInstruction","closePathInstruction","CanvasReplay","CanvasPolygonReplay","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","__proto__","prototype","Object","create","constructor","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","this$1","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","geometry","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport {asString} from '../../color.js';\nimport {snap} from '../../geom/flat/simplify.js';\nimport {defaultFillStyle} from '../canvas.js';\nimport CanvasInstruction, {\n  fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction\n} from '../canvas/Instruction.js';\nimport CanvasReplay from '../canvas/Replay.js';\n\n\nvar CanvasPolygonReplay = (function (CanvasReplay) {\n  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if ( CanvasReplay ) CanvasPolygonReplay.__proto__ = CanvasReplay;\n  CanvasPolygonReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );\n  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n\n  /**\n   * @param {Array.<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array.<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_ (flatCoordinates, offset, ends, stride) {\n    var this$1 = this;\n\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this$1.coordinates.length;\n      var myEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this$1.instructions.push(moveToLineToInstruction);\n      this$1.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this$1.instructions.push(closePathInstruction);\n        this$1.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawCircle = function drawCircle (circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(\n      flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(circleGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {\n    var this$1 = this;\n\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this$1.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasPolygonReplay.prototype.finish = function finish () {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  };\n\n  /**\n   * @private\n   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n   */\n  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_ (geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonReplay;\n}(CanvasReplay));\n\n\nexport default CanvasPolygonReplay;\n\n//# sourceMappingURL=PolygonReplay.js.map"]},"metadata":{},"sourceType":"module"}