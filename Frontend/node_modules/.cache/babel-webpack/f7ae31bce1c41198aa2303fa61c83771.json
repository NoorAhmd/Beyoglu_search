{"ast":null,"code":"/**\n * @module ol/renderer/Layer\n */\nimport { getUid } from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport TileState from '../TileState.js';\nimport { listen } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { FALSE, UNDEFINED } from '../functions.js';\nimport SourceState from '../source/State.js';\n\nvar LayerRenderer = function (Observable) {\n  function LayerRenderer(layer) {\n    Observable.call(this);\n    /**\n     * @private\n     * @type {module:ol/layer/Layer}\n     */\n\n    this.layer_ = layer;\n  }\n\n  if (Observable) LayerRenderer.__proto__ = Observable;\n  LayerRenderer.prototype = Object.create(Observable && Observable.prototype);\n  LayerRenderer.prototype.constructor = LayerRenderer;\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {module:ol/source/Tile} source Tile source.\n   * @param {module:ol/proj/Projection} projection Projection of the tiles.\n   * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, module:ol/TileRange):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n\n  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {module:ol/TileRange} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function (zoom, tileRange) {\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  };\n  /**\n   * @return {module:ol/layer/Layer} Layer.\n   */\n\n\n  LayerRenderer.prototype.getLayer = function getLayer() {\n    return this.layer_;\n  };\n  /**\n   * Handle changes in image state.\n   * @param {module:ol/events/Event} event Image change event.\n   * @private\n   */\n\n\n  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_(event) {\n    var image =\n    /** @type {module:ol/Image} */\n    event.target;\n\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {module:ol/ImageBase} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.loadImage = function loadImage(image) {\n    var imageState = image.getState();\n\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      listen(image, EventType.CHANGE, this.handleImageChange_, this);\n    }\n\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState.LOADED;\n  };\n  /**\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible() {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      this.changed();\n    }\n  };\n  /**\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {module:ol/source/Tile} tileSource Tile source.\n       * @param {module:ol/PluggableMap} map Map.\n       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource).toString();\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n      /** @type {module:ol/PluggableMap~PostRenderFunction} */\n      postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {module:ol/TileRange} tileRange Tile range.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles(usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource).toString();\n    var zKey = z.toString();\n\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/proj/Projection} projection Projection.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n\n\n  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n    var tileSourceKey = getUid(tileSource).toString();\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  };\n\n  return LayerRenderer;\n}(Observable);\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}\n *     callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @return {T|undefined} Callback result.\n * @template S,T\n */\n\n\nLayerRenderer.prototype.forEachFeatureAtCoordinate = UNDEFINED;\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @return {boolean} Is there a feature at the given coordinate?\n */\n\nLayerRenderer.prototype.hasFeatureAtCoordinate = FALSE;\nexport default LayerRenderer; //# sourceMappingURL=Layer.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/renderer/Layer.js"],"names":["getUid","ImageState","Observable","TileState","listen","EventType","FALSE","UNDEFINED","SourceState","LayerRenderer","layer","call","layer_","__proto__","prototype","Object","create","constructor","createLoadedTileFinder","source","projection","tiles","zoom","tileRange","callback","tile","tileCoord","toString","forEachLoadedTile","getLayer","handleImageChange_","event","image","target","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","CHANGE","IDLE","load","getVisible","getSourceState","READY","changed","scheduleExpireCache","frameState","tileSource","canExpireCache","postRenderFunction","map","tileSourceKey","usedTiles","expireCache","viewState","bind","postRenderFunctions","push","updateUsedTiles","z","zKey","extend","manageTilePyramid","tileGrid","pixelRatio","extent","currentZ","preload","opt_tileCallback","opt_this","wantedTiles","tileQueue","minZoom","getMinZoom","tileResolution","x","y","getTileRangeForExtentAndZ","getResolution","minX","maxX","minY","maxY","getTile","getKey","isKeyQueued","enqueue","getTileCoordCenter","undefined","useTile","forEachFeatureAtCoordinate","hasFeatureAtCoordinate"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport {getUid} from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport TileState from '../TileState.js';\nimport {listen} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {FALSE, UNDEFINED} from '../functions.js';\nimport SourceState from '../source/State.js';\n\nvar LayerRenderer = (function (Observable) {\n  function LayerRenderer(layer) {\n\n    Observable.call(this);\n\n    /**\n     * @private\n     * @type {module:ol/layer/Layer}\n     */\n    this.layer_ = layer;\n\n  }\n\n  if ( Observable ) LayerRenderer.__proto__ = Observable;\n  LayerRenderer.prototype = Object.create( Observable && Observable.prototype );\n  LayerRenderer.prototype.constructor = LayerRenderer;\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {module:ol/source/Tile} source Tile source.\n   * @param {module:ol/proj/Projection} projection Projection of the tiles.\n   * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, module:ol/TileRange):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {module:ol/TileRange} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function(zoom, tileRange) {\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  };\n\n  /**\n   * @return {module:ol/layer/Layer} Layer.\n   */\n  LayerRenderer.prototype.getLayer = function getLayer () {\n    return this.layer_;\n  };\n\n  /**\n   * Handle changes in image state.\n   * @param {module:ol/events/Event} event Image change event.\n   * @private\n   */\n  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {\n    var image = /** @type {module:ol/Image} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {module:ol/ImageBase} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  LayerRenderer.prototype.loadImage = function loadImage (image) {\n    var imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      listen(image, EventType.CHANGE, this.handleImageChange_, this);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  };\n\n  /**\n   * @protected\n   */\n  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {\n    var layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      this.changed();\n    }\n  };\n\n  /**\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @protected\n   */\n  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {module:ol/source/Tile} tileSource Tile source.\n       * @param {module:ol/PluggableMap} map Map.\n       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function(tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource).toString();\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {module:ol/PluggableMap~PostRenderFunction} */ (postRenderFunction)\n      );\n    }\n  };\n\n  /**\n   * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {module:ol/TileRange} tileRange Tile range.\n   * @protected\n   */\n  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource).toString();\n    var zKey = z.toString();\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  };\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n   * @param {module:ol/source/Tile} tileSource Tile source.\n   * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/proj/Projection} projection Projection.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback,\n    opt_this\n  ) {\n    var tileSourceKey = getUid(tileSource).toString();\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  };\n\n  return LayerRenderer;\n}(Observable));\n\n\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}\n *     callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @return {T|undefined} Callback result.\n * @template S,T\n */\nLayerRenderer.prototype.forEachFeatureAtCoordinate = UNDEFINED;\n\n\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @return {boolean} Is there a feature at the given coordinate?\n */\nLayerRenderer.prototype.hasFeatureAtCoordinate = FALSE;\n\n\nexport default LayerRenderer;\n\n//# sourceMappingURL=Layer.js.map"]},"metadata":{},"sourceType":"module"}