{"ast":null,"code":"/**\n * @module ol/Observable\n */\nimport { listen, unlistenByKey, unlisten, listenOnce } from './events.js';\nimport EventTarget from './events/EventTarget.js';\nimport EventType from './events/EventType.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires module:ol/events/Event~Event\n * @api\n */\n\nvar Observable = function (EventTarget) {\n  function Observable() {\n    EventTarget.call(this);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.revision_ = 0;\n  }\n\n  if (EventTarget) Observable.__proto__ = EventTarget;\n  Observable.prototype = Object.create(EventTarget && EventTarget.prototype);\n  Observable.prototype.constructor = Observable;\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n\n  Observable.prototype.changed = function changed() {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n\n\n  Observable.prototype.getRevision = function getRevision() {\n    return this.revision_;\n  };\n  /**\n   * Listen for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.on = function on(type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listen(this$1, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return listen(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\n   * Listen once for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.once = function once(type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listenOnce(this$1, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return listenOnce(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @api\n   */\n\n\n  Observable.prototype.un = function un(type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        unlisten(this$1, type[i], listener);\n      }\n\n      return;\n    } else {\n      unlisten(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n\n  return Observable;\n}(EventTarget);\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\n\n\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(\n    /** @type {module:ol/events~EventsKey} */\n    key);\n  }\n}\nexport default Observable; //# sourceMappingURL=Observable.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/Observable.js"],"names":["listen","unlistenByKey","unlisten","listenOnce","EventTarget","EventType","Observable","call","revision_","__proto__","prototype","Object","create","constructor","changed","dispatchEvent","CHANGE","getRevision","on","type","listener","this$1","Array","isArray","len","length","keys","i","once","un","ii","unByKey","key"],"mappings":"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","sourcesContent":["/**\n * @module ol/Observable\n */\nimport {listen, unlistenByKey, unlisten, listenOnce} from './events.js';\nimport EventTarget from './events/EventTarget.js';\nimport EventType from './events/EventType.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires module:ol/events/Event~Event\n * @api\n */\nvar Observable = (function (EventTarget) {\n  function Observable() {\n\n    EventTarget.call(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.revision_ = 0;\n\n  }\n\n  if ( EventTarget ) Observable.__proto__ = EventTarget;\n  Observable.prototype = Object.create( EventTarget && EventTarget.prototype );\n  Observable.prototype.constructor = Observable;\n\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n  Observable.prototype.changed = function changed () {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  };\n\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n  Observable.prototype.getRevision = function getRevision () {\n    return this.revision_;\n  };\n\n  /**\n   * Listen for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n  Observable.prototype.on = function on (type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listen(this$1, type[i], listener);\n      }\n      return keys;\n    } else {\n      return listen(this, /** @type {string} */ (type), listener);\n    }\n  };\n\n  /**\n   * Listen once for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n  Observable.prototype.once = function once (type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listenOnce(this$1, type[i], listener);\n      }\n      return keys;\n    } else {\n      return listenOnce(this, /** @type {string} */ (type), listener);\n    }\n  };\n\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array.<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @api\n   */\n  Observable.prototype.un = function un (type, listener) {\n    var this$1 = this;\n\n    if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        unlisten(this$1, type[i], listener);\n      }\n      return;\n    } else {\n      unlisten(this, /** @type {string} */ (type), listener);\n    }\n  };\n\n  return Observable;\n}(EventTarget));\n\n\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(/** @type {module:ol/events~EventsKey} */ (key));\n  }\n}\n\n\nexport default Observable;\n\n//# sourceMappingURL=Observable.js.map"]},"metadata":{},"sourceType":"module"}