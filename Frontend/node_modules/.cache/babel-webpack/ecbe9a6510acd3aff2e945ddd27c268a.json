{"ast":null,"code":"/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from '../flat/reverse.js';\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n\n    offset = end;\n  }\n\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    if (!linearRingIsOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n\n    offset = end;\n  }\n\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n\n  return offset;\n} //# sourceMappingURL=orient.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/ankamap/node_modules/ol/geom/flat/orient.js"],"names":["coordinates","reverseCoordinates","linearRingIsClockwise","flatCoordinates","offset","end","stride","edge","x1","y1","x2","y2","linearRingIsOriented","ends","opt_right","right","undefined","i","ii","length","isClockwise","linearRingsAreOriented","endss","orientLinearRings","reverse","orientLinearRingsArray"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from '../flat/reverse.js';\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge > 0;\n}\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(\n      flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    if (!linearRingIsOriented(\n      flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(\n      flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ?\n      (right && isClockwise) || (!right && !isClockwise) :\n      (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n}\n\n//# sourceMappingURL=orient.js.map"]},"metadata":{},"sourceType":"module"}