{"ast":null,"code":"/**\n * @module ol/geom/Polygon\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport Point from '../geom/Point.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { offset as sphereOffset } from '../sphere.js';\nimport { linearRings as linearRingsArea } from '../geom/flat/area.js';\nimport { assignClosestArrayPoint, arrayMaxSquaredDelta } from '../geom/flat/closest.js';\nimport { linearRingsContainsXY } from '../geom/flat/contains.js';\nimport { deflateCoordinatesArray } from '../geom/flat/deflate.js';\nimport { inflateCoordinatesArray } from '../geom/flat/inflate.js';\nimport { getInteriorPointOfArray } from '../geom/flat/interiorpoint.js';\nimport { intersectsLinearRingArray } from '../geom/flat/intersectsextent.js';\nimport { linearRingIsOriented, orientLinearRings } from '../geom/flat/orient.js';\nimport { quantizeArray } from '../geom/flat/simplify.js';\nimport { modulo } from '../math.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\n\nvar Polygon = function (SimpleGeometry) {\n  function Polygon(coordinates, opt_layout, opt_ends) {\n    SimpleGeometry.call(this);\n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n\n    this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.flatInteriorPointRevision_ = -1;\n    /**\n     * @private\n     * @type {module:ol/coordinate~Coordinate}\n     */\n\n    this.flatInteriorPoint_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, coordinates);\n      this.ends_ = opt_ends;\n    } else {\n      this.setCoordinates(coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) Polygon.__proto__ = SimpleGeometry;\n  Polygon.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  Polygon.prototype.constructor = Polygon;\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {module:ol/geom/LinearRing} linearRing Linear ring.\n   * @api\n   */\n\n  Polygon.prototype.appendLinearRing = function appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!module:ol/geom/Polygon} Clone.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.clone = function clone() {\n    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.containsXY = function containsXY(x, y) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  Polygon.prototype.getArea = function getArea() {\n    return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n    var flatCoordinates;\n\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array.<number>} Ends.\n   */\n\n\n  Polygon.prototype.getEnds = function getEnds() {\n    return this.ends_;\n  };\n  /**\n   * @return {Array.<number>} Interior point.\n   */\n\n\n  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n\n    return this.flatInteriorPoint_;\n  };\n  /**\n   * Return an interior point of the polygon.\n   * @return {module:ol/geom/Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  Polygon.prototype.getInteriorPoint = function getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRingCount = function getLinearRingCount() {\n    return this.ends_.length;\n  };\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {module:ol/geom/LinearRing} Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRing = function getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array.<module:ol/geom/LinearRing>} Linear rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRings = function getLinearRings() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n\n    return linearRings;\n  };\n  /**\n   * @return {Array.<number>} Oriented flat coordinates.\n   */\n\n\n  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n\n      if (linearRingIsOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Polygon.prototype.getType = function getType() {\n    return GeometryType.POLYGON;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Polygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.\n   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(SimpleGeometry);\n\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {module:ol/coordinate~Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {module:ol/geom/Polygon} The \"circular\" polygon.\n * @api\n */\n\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array.<number>} */\n\n  var flatCoordinates = [];\n\n  for (var i = 0; i < n; ++i) {\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {module:ol/extent~Extent} extent The extent.\n * @return {module:ol/geom/Polygon} The polygon.\n * @api\n */\n\nexport function fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {module:ol/geom/Circle} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {module:ol/geom/Polygon} Polygon geometry.\n * @api\n */\n\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {module:ol/coordinate~Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\n\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n\n  polygon.changed();\n} //# sourceMappingURL=Polygon.js.map","map":{"version":3,"sources":["/Users/n.ah/Projects/Beyoglu_search/Frontend/node_modules/ol/geom/Polygon.js"],"names":["extend","closestSquaredDistanceXY","getCenter","GeometryLayout","GeometryType","LinearRing","Point","SimpleGeometry","offset","sphereOffset","linearRings","linearRingsArea","assignClosestArrayPoint","arrayMaxSquaredDelta","linearRingsContainsXY","deflateCoordinatesArray","inflateCoordinatesArray","getInteriorPointOfArray","intersectsLinearRingArray","linearRingIsOriented","orientLinearRings","quantizeArray","modulo","Polygon","coordinates","opt_layout","opt_ends","call","ends_","flatInteriorPointRevision_","flatInteriorPoint_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","undefined","setFlatCoordinates","setCoordinates","__proto__","prototype","Object","create","constructor","appendLinearRing","linearRing","flatCoordinates","getFlatCoordinates","slice","push","length","changed","clone","layout","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","containsXY","getOrientedFlatCoordinates","getArea","getCoordinates","opt_right","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPoint","XYM","getLinearRingCount","getLinearRing","index","getLinearRings","ends","i","ii","end","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","POLYGON","intersectsExtent","extent","setLayout","circular","center","radius","opt_n","opt_sphereRadius","n","PI","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","getLayout","arrayLength","Array","j","polygon","makeRegular","getRadius","startAngle","angle","cos","sin"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/Polygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, getCenter} from '../extent.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport Point from '../geom/Point.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {offset as sphereOffset} from '../sphere.js';\nimport {linearRings as linearRingsArea} from '../geom/flat/area.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from '../geom/flat/closest.js';\nimport {linearRingsContainsXY} from '../geom/flat/contains.js';\nimport {deflateCoordinatesArray} from '../geom/flat/deflate.js';\nimport {inflateCoordinatesArray} from '../geom/flat/inflate.js';\nimport {getInteriorPointOfArray} from '../geom/flat/interiorpoint.js';\nimport {intersectsLinearRingArray} from '../geom/flat/intersectsextent.js';\nimport {linearRingIsOriented, orientLinearRings} from '../geom/flat/orient.js';\nimport {quantizeArray} from '../geom/flat/simplify.js';\nimport {modulo} from '../math.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = (function (SimpleGeometry) {\n  function Polygon(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {module:ol/coordinate~Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, coordinates);\n      this.ends_ = opt_ends;\n    } else {\n      this.setCoordinates(coordinates, opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) Polygon.__proto__ = SimpleGeometry;\n  Polygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Polygon.prototype.constructor = Polygon;\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {module:ol/geom/LinearRing} linearRing Linear ring.\n   * @api\n   */\n  Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!module:ol/geom/Polygon} Clone.\n   * @override\n   * @api\n   */\n  Polygon.prototype.clone = function clone () {\n    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  Polygon.prototype.getArea = function getArea () {\n    return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(\n        flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(\n      flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array.<number>} Ends.\n   */\n  Polygon.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * @return {Array.<number>} Interior point.\n   */\n  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\n        flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  };\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {module:ol/geom/Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  Polygon.prototype.getInteriorPoint = function getInteriorPoint () {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  Polygon.prototype.getLinearRingCount = function getLinearRingCount () {\n    return this.ends_.length;\n  };\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {module:ol/geom/LinearRing} Linear ring.\n   * @api\n   */\n  Polygon.prototype.getLinearRing = function getLinearRing (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array.<module:ol/geom/LinearRing>} Linear rings.\n   * @api\n   */\n  Polygon.prototype.getLinearRings = function getLinearRings () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  };\n\n  /**\n   * @return {Array.<number>} Oriented flat coordinates.\n   */\n  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingIsOriented(\n        flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRings(\n              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Polygon.prototype.getType = function getType () {\n    return GeometryType.POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.\n   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(SimpleGeometry));\n\n\nexport default Polygon;\n\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {module:ol/coordinate~Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {module:ol/geom/Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array.<number>} */\n  var flatCoordinates = [];\n  for (var i = 0; i < n; ++i) {\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {module:ol/extent~Extent} extent The extent.\n * @return {module:ol/geom/Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates =\n      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n\n\n/**\n * Create a regular polygon from a circle.\n * @param {module:ol/geom/Circle} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {module:ol/geom/Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {module:ol/coordinate~Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + (modulo(i, sides) * 2 * Math.PI / sides);\n    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\n    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\n  }\n  polygon.changed();\n}\n\n//# sourceMappingURL=Polygon.js.map"]},"metadata":{},"sourceType":"module"}